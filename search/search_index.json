{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scimpler: SCIM integrations made simpler","text":"<p><code>scimpler</code> makes it easier to ensure both Service Provider and Provisioning Client integrate with SCIM 2.0 protocol flawlessly. It implements definitions, validation rules, and operations, as specified in RFC-7643  and RFC-7644.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>All SCIM-defined resource and API message schemas</li> <li>Custom resource schemas and extensions</li> <li>SCIM requests and responses validation</li> <li>Filters with SCIM-defined and custom operators</li> <li>Data sorting</li> <li>Attribute-based data filtering</li> <li>Convenient SCIM data access and composition</li> <li>Optional integration with marshmallow schemas</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Use pip to install <code>scimpler</code>.</p> <pre><code>pip install scimpler\n</code></pre> <p>If you want to integrate with marshmallow, install <code>scimpler</code> with optional dependencies.</p> <pre><code>pip install \"scimpler[marshmallow]\"\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#set-service-provider-configuration","title":"Set Service Provider configuration","text":"<pre><code>from scimpler import config\n\nconfig.set_service_provider_config(\n    config.ServiceProviderConfig.create(\n        patch={\"supported\": True}\n    )\n)\n</code></pre>"},{"location":"#validate-request","title":"Validate request","text":"<pre><code>from scimpler import query_string, validator\nfrom scimpler.schemas import UserSchema\n\nquery_string_handler = query_string.ResourceObjectPatch()\nval = validator.ResourceObjectPatch(resource_schema=UserSchema())\n\nrequest_query_string = {\n    \"attributes\": \"name,bad^attributeName\"\n}\nrequest_data = {\n    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\n    \"Operations\": [\n        {\n            \"op\": \"add\",\n            \"path\": \"nickName\",\n            \"value\": \"Pagerous\",\n        },\n        {\n            \"op\": \"replace\",\n            \"path\": \"emails[type eq 'home']\",\n            \"value\": 42,\n        },\n        {\n            \"op\": \"remove\",\n            \"path\": \"name.nonExisting\"\n        },\n        {\n            \"op\": \"replace\",\n            \"path\": \"ims[ty\"\n        }\n    ]\n}\n\nquery_string_issues = query_string_handler.validate(request_query_string)\nrequest_issues = val.validate_request(request_data)\n\nprint(\"query_string_issues:\\n\", query_string_issues.to_dict(message=True))\nprint(\"request_issues:\\n\", request_issues.to_dict(message=True))\n</code></pre> <p>Output <pre><code>query_string_issues:\n{\n  \"attributes\": {\n    \"1\": {\n      \"_errors\": [\n        {\"code\": 17, \"message\": \"bad attribute name \"bad^attributeName\"\"}\n      ]\n    }\n  }\n}\n\nrequest_issues:\n{\n  \"body\": {\n    \"Operations\": {\n      \"1\": {\n        \"value\": {\n          \"errors\": [{\"code\": 2, \"message\": \"bad type, expecting 'complex'\"}]\n        }\n      },\n      \"2\": {\n        \"path\": {\n          \"errors\": [{\"code\": 28, \"message\": \"unknown modification target\"}]\n        }\n      }\n      \"3\": {\n        \"path\": {\n          \"errors\": [{\"code\": 1, \"message\": \"bad value syntax\"}]\n        },\n        \"value\": {\n          \"errors\": [{\"code\": 5, \"message\": \"missing\"}]\n        }\n      },\n    }\n  }\n}\n</code></pre></p>"},{"location":"#deserialize-or-serialize-data","title":"Deserialize (or serialize) data","text":"<p><pre><code>from scimpler.schemas import UserSchema\n\ndata = {\n    \"schemas\": [\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\n    ],\n    \"externalId\": \"1\",\n    \"userName\": \"Pagerous\",\n    \"name\": {\n        \"formatted\": \"Arkadiusz Pajor\",\n        \"familyName\": \"Pajor\",\n        \"givenName\": \"Arkadiusz\"\n    },\n    \"profileUrl\": \"https://www.linkedin.com/in/arkadiusz-pajor/\",\n    \"emails\": [\n        {\n            \"value\": \"arkadiuszpajor97@gmail.com\",\n            \"type\": \"work\",\n            \"primary\": True\n        }\n    ],\n}\nuser = UserSchema()\n\ndeserialized = user.deserialize(data)\n\n# convenient, case-insensitive data access\nprint(deserialized[\"name.formatted\"])\nprint(deserialized[\"pRoFiLeUrL\"])\nprint(deserialized[\"emails\"][0].get(\"display\"))\n</code></pre> Output <pre><code>Arkadiusz Pajor\nhttps://www.linkedin.com/in/arkadiusz-pajor/\nMissing\n</code></pre></p>"},{"location":"#validate-response","title":"Validate response","text":"<p><pre><code>from scimpler.data import AttrValuePresenceConfig\nfrom scimpler.schemas import UserSchema\nfrom scimpler import validator\n\nresponse_data = {\n    \"schemas\": [\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\n    ],\n    \"id\": \"1\",\n    \"externalId\": \"1\",\n    \"userName\": \"Pagerous\",\n    \"password\": \"12345678\",\n    \"name\": {\n        \"formatted\": \"Arkadiusz Pajor\",\n        \"familyName\": \"Pajor\",\n        \"givenName\": \"Arkadiusz\"\n    },\n    \"profileUrl\": \"https://www.linkedin.com/in/arkadiusz-pajor/\",\n    \"emails\": [\n        {\n            \"value\": \"arkadiuszpajor97@gmail.com\",\n            \"type\": \"work\",\n            \"primary\": True\n        }\n    ],\n    \"meta\": {\n        \"resourceType\": \"User\",\n        \"created\": \"1997-10-17T00:00:00\",\n        \"lastModified\": \"2024-09-09T22:13:00\",\n        \"location\": \"https://example.com/v2/Users/1\",\n    }\n}\nval = validator.ResourceObjectGet(resource_schema=UserSchema())\n\nresponse_issues = val.validate_response(\n    status_code=201,\n    body=response_data,\n    presence_config=AttrValuePresenceConfig(\n        \"RESPONSE\",\n        attr_reps=[\"name.familyName\", \"emails.primary\"],\n        include=False\n    )\n)\n\nprint(response_issues.to_dict(message=True))\n</code></pre> Output <pre><code>{\n  \"body\": {\n    \"name\": {\n      \"familyName\": {\n        \"_errors\": [{\"code\": 7, \"message\": \"must not be returned\"}]\n      }\n    },\n    \"password\": {\n      \"_errors\": [{\"code\": 7, \"message\": \"must not be returned\"}]\n    },\n    \"emails\": {\n      \"0\": {\n        \"primary\": {\n          \"_errors\": [{\"code\": 7, \"message\": \"must not be returned\"}]\n        }\n      }\n    }\n  },\n  \"status\": {\n    \"_errors\": [\n      {\"code\": 19, \"message\": \"bad status code, expecting '200'\"}\n    ]\n  }\n}\n</code></pre></p> <p>See User's Guide for detailed features description. Want to know more? Check API Reference. </p>"},{"location":"compliance/","title":"Compliance","text":"<p>Below tables contain statements from RFC7643  and RFC7644 (sometimes redacted, to make them easier to understand without the full context).</p> <p>For every statement there is an information if a particular desired behavior is validated by <code>scimpler</code> or / and if it is supported by the packaged classes and functions.</p> <p><code>scimpler</code> provides almost stateless validation (it uses few in-memory registries for smooth usage), so it works best for syntax and part of semantics validation. Any behavior that spans on multiple SCIM operations (e.g., value uniqueness)m or requires to correlate requests with responses, is not validated and should be ensured by you. </p> <p>The  symbol means that the desired behavior is validated / supported. The  symbol means the opposite.  No symbol means the statement is irrelevant or too abstract and can not be efficiently validated / supported.</p> <p>Info</p> <p>You are free to use the tables as check-lists to make sure your implementation is compliant with SCIM 2.0.</p> <p>For more information about <code>scimpler</code> capabilities, see User's Guide and API Reference.</p>"},{"location":"compliance/#core-schema","title":"Core Schema","text":""},{"location":"compliance/#scim-schema","title":"SCIM Schema","text":"Desired Behavior Validated Supported <code>Schema</code> is a collection of attribute definitions that describe the contents of an entire or partial resource. The attribute definitions specify the name of the attribute, the metadata such as type, cardinality, mutability, and returnability. <code>Singular Attribute</code> is a resource attribute that contains 0..1 values. <code>Multi-valued Attribute</code> is a resource attribute that contains 0..n values. <code>Simple Attribute</code> is a singular or multi-valued attribute whose value is a primitive. A simple attribute MUST NOT contain sub-attributes. <code>Complex Attribute</code> is a singular or multi-valued attribute whose value is a composition of one or more simple attributes. <code>Sub-Attribute</code> is a simple attribute that is contained within a complex attribute. A SCIM resource is a collection of attributes identified by one or more schemas. SCIM resources are represented in JSON format. SCIM resources MUST specify schema via the <code>schemas</code> attribute. Attribute names MUST conform to the following ABNF rules: <code>ATTRNAME = ALPHA *(nameChar)</code> <code>nameChar = \"$\" / \"-\" / \"_\" / DIGIT / ALPHA</code> All attribute names are case insensitive. All attributes have a set of characteristics: <code>required</code>, <code>canonicalValues</code>, <code>caseExact</code>, <code>mutability</code>, <code>returned</code>, <code>uniqueness</code>, <code>referenceTypes</code>. SCIM extensions SHOULD NOT introduce new data types. An attribute with SCIM schema type <code>string</code> MAY specify a required data format. When <code>canonicalValues</code> is specified for <code>string</code> attribute, service providers MAY restrict accepted values to the specified values. A <code>boolean</code> attribute is represented by literals: <code>true</code> and <code>false</code>. A <code>boolean</code> attribute has no case sensitivity or uniqueness. A <code>decimal</code> attribute is a real number with at least one digit to the left and right of the period. A <code>decimal</code> attribute has no case sensitivity. An <code>integer</code> attribute is a whole number with no fractional digits or decimal. Integers must preserve JSON format, with additional constraint that the value MUST NOT contain fractional or exponent parts. An <code>integer</code> attribute has no case sensitivity. A <code>dateTime</code> attribute values MUST be encoded as a valid xsd:dateTime and MUST include both a date and a time. A <code>dateTime</code> attribute has no case sensitivity or uniqueness. A <code>dateTime</code> attribute is represented as a JSON string. A <code>binary</code> attribute MUST be base64 encoded. In case where a URL-safe encoding is required, a <code>binary</code> attribute MAY specify that base64 URL encoding is used. Unless otherwise specified in the <code>binary</code> attribute definition, trailing padding characters MAY be omitted. In JSON representation, the encoded <code>binary</code> values are represented as a JSON string. A <code>binary</code> attribute is case exact and has no uniqueness. A <code>reference</code> attribute MAY be a SCIM resource, an external link to a resource, or an identifier such as a URN. <code>reference</code> attribute values MUST be the absolute or relative URIs of the target resources. Relative URIs should be resolved as specified in RFC3986. Base URI for relative URI resolution MUST include all URI components and path segments up to, but not including, the endpoint URI. In JSON representation, the URI value is represented as a JSON string. A <code>reference</code> attribute is case exact. A <code>reference</code> attribute has a <code>referenceTypes</code> property that indicates what types of resources may be linked. A reference URI MUST be to an HTTP-addressable resource. An HTTP client performing a GET operation on a reference URI MUST receive the target resource or an appropriate HTTP response code. SCIM service provider MAY choose to enforce referential integrity for reference types referring to SCIM resources. Servers and clients MUST NOT require or expect attributes to be in any specific order when an object is either generated or analyzed. A <code>complex</code> attribute has no uniqueness or case sensitivity. A <code>complex</code> attribute MUST NOT contain sub-attributes that have sub-attributes (i.e., that are complex). Multi-valued attributes contain a list of elements using the JSON array format. Multi-valued elements can be objects with a set of sub-attributes and values, using the JSON object format, in which case they SHALL be considered to be complex attributes. If not otherwise defined, the default set of sub-attributes for multi-valued attribute is as follows: <code>type</code>, <code>primary</code>, <code>display</code>, <code>value</code>, and <code>$ref</code>. A <code>type</code> default sub-attribute is a label indicating the attribute's function. A <code>primary</code> default sub-attribute is a boolean value indicating the \"primary\" or preferred attribute value for the attribute. The <code>primary</code> sub-attribute value <code>true</code> MUST appear no more than once. If not specified, the value of <code>primary</code> sub-attribute SHALL be assumed to be <code>false</code>. A <code>display</code> default sub-attribute is a human-readable name, primarily used for display purposes and having a mutability of <code>immutable</code>. A <code>value</code> default sub-attribute is a significant value. A <code>$ref</code> default sub-attribute is reference URI of a target resource. A value of <code>$ref</code> sub-attribute SHALL be considered comparable to URIs without a version or with a different version. When returning multi-valued attributes, service providers SHOULD canonicalize the value returned when appropriate. Service providers MAY return element objects with the same <code>value</code> sub-attribute more than once with a different <code>type</code> sub-attribute, but SHOULD NOT return the same (type, value) combination more than once per attribute. When defining schema for multi-valued attributes, it is considered a good practice to provide a <code>type</code> sub-attribute that MAY be used for the purpose of canonicalization of values. In the schema definition for an attribute, the service provider MAY define the recommended canonical values. Unassigned values, the <code>null</code> value, or an empty array SHALL be considered to be equivalent in state. Assigning an attribute with the value <code>null</code> or an empty array has the effect of making the attribute \"unassigned\". When a resource is expressed in JSON format, unassigned attributes, although they are defined in schema, MAY be omitted for compactness."},{"location":"compliance/#scim-resources","title":"SCIM Resources","text":"Desired Behavior Validated Supported Each SCIM resource is a JSON object that has the following components: resource type, <code>schemas</code> attribute, common attributes, core attributes, and extended attributes. Each SCIM resource has a resource type (<code>meta.resourceType</code> attribute) that defines the resource's core attribute schema and any attribute extension schema, as well as the endpoint where objects of the same type may be found. The <code>schemas</code> attribute is a required attribute and is an array of Strings containing URIs that are used to indicate the namespaces of the SCIM schemas that define the attributes present in the current JSON structure. Each <code>schemas</code> attribute value must be a unique URI. Duplicate values MUST NOT be included. All representations of SCIM schemas MUST include a non-empty array with value(s) of the URIs supported by that representation. The <code>schemas</code>attribute for a resource MUST only contain values defined as <code>schema</code> and <code>schemaExtensions</code> for the resource's defined <code>meta.resourceType</code>. The order of <code>schemas</code> attribute value is not specified and MUST NOT impact behavior. Common attributes are not defined in any particular schema but SHALL be assumed to be present in every resource, regardless of the value of <code>schemas</code> attribute. Core attributes are those attributes that sit at the top level of the JSON object together with the common attributes. The list of valid attributes is specified by the resource's resource type <code>schema</code> attribute. Extended schema attributes are specified by the resource's resource type <code>schemaExtensions</code> attribute. Extended attributes are kept in their own sub-attribute namespace identified by the schema extension URI. Each SCIM resource includes the following common attributes: <code>id</code>, <code>externalId</code>, and <code>meta</code>. Except <code>ServiceProviderConfig</code> and <code>ResourceType</code> server discovery endpoints and their associated resources, these attributes MUST be defined for all resources, including any extended resource types. When accepted by a service provider, the attributes <code>id</code> and <code>meta</code> MUST be assigned values by the service provider. Each representation of the resource MUST include a non-empty <code>id</code> value. The identifier MUST be unique across the SCIM service provider's entire set of resources. The identifier MUST be a stable, non-reassignable identifier that does not change when the same resource is returned in subsequent requests. The value of the <code>id</code> attribute is always issued by the service provider and MUST NOT be specified by the client. The string <code>bulkId</code> is a reserved keyword and MUST NOT be used within any unique identifier value. The <code>id</code> attribute characteristics are: case-sensitive, read-only, always returned. Each resource MAY include a non-empty <code>externalId</code> value. The value of the <code>externalId</code> attribute is always issued by the provisioning client and MUST NOT be specified by the service provider. The service provider MUST always interpret the <code>externalId</code> as scoped to the provisioning domain. It is assumed that the <code>externalId</code> uniqueness, even if not enforced, is controlled by the client setting the value. The <code>externalId</code> characteristics are: case-sensitive, read-write. All <code>meta</code> sub-attributes are assigned by the service-provider. All <code>meta</code> sub-attributes are returned by default. The <code>meta</code> attribute SHALL be ignored when provided by clients. The <code>meta.resourceType</code> sub-attribute is the name of the resource type of the resource. It is read-only and case-sensitive. The <code>meta.created</code> sub-attribute is the <code>dateTime</code> that the resource was added to the service provider. The <code>meta.lastModified</code> sub-attribute is the most recent <code>dateTime</code> that the details of this resource were updated at the service provider. If a resource has never been modified since its initial creation, the value MUST be the same as the value of <code>meta.created</code>. The <code>meta.location</code> sub-attribute is the URI of the resource being returned. The value MUST be the same as the <code>Content-Location</code> HTTP response header. The <code>meta.version</code> sub-attribute is the case-sensitive version of the resource being returned. The value MUST be the same as the <code>E-Tag</code> HTTP response header. If a service provider provides <code>meta.version</code> for a representation and the generation of entity-tag does not satisfy all the characteristics of a strong validator, then the origin server MUST mark the \"version\" as weak by prefixing its opaque value with <code>W/</code>. Each resource type defines the name, endpoint, base schema, and any schema extensions registered for use with the resource type. Each value in the <code>schemas</code> attribute indicates additive schema that MAY exist in a SCIM resource representation. The <code>schemas</code> attribute MUST contain at least one value, which SHALL be the base schema for the resource. The <code>schemas</code> attribute MAY contain additional values indicating extended schemas that are in use. Schema extensions SHOULD avoid redefining any attributes defined in this specification and SHOULD follow conventions defined in this specification. Except for the base object schema, the schema extension URI SHALL be used as a JSON container to distinguish attributes belonging to the extension namespace for base schema attributes. In order to determine which URI value in the <code>schemas</code> attribute is the base schema and which is an extended schema for any given resource, the resource's <code>meta.resourceType</code> sub-attribute value MAY be used to retrieve the resource's <code>ResourceType</code> schema."},{"location":"compliance/#user-resource-schema","title":"\"User\" Resource Schema","text":"Desired Behavior Validated Supported The core schema for <code>User</code> is identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:User</code>. The <code>userName</code> attribute is a service provider's unique identifier for the user. Each User MUST include a non-empty <code>userName</code> value. The <code>userName</code> attribute MUST be unique across the service provider's entire set of Users. The <code>userName</code> attribute is required and case-insensitive. The <code>name</code> complex attribute contains components for the user's name: <code>formatted</code>, <code>familyName</code>, <code>givenName</code>, <code>middleName</code>, <code>honorificPrefix</code>, <code>honorificSuffix</code>. Service providers MAY return just the full name as a single string in the <code>name.formatted</code> sub-attribute, or they MAY return just the individual component attributes using the other sub-attributes of <code>name</code>, or they MAY return both. All components of the <code>name</code> attribute SHOULD be describing the same name, with the formatted name indicating how the component attributes should be combined. The <code>name.formatted</code> sub-attribute is the full name, including all middle names, titles, and suffixes as appropriate, formated for display. The <code>name.familyName</code> sub-attribute is the family name of the User, or last name in most Western languages. The <code>name.givenName</code> sub-attribute is the given name of the User, or first name in most Western languages. The <code>name.middleName</code> sub-attribute is the middle name(s) of the User. The <code>name.honorificPrefix</code> sub-attribute is the honorific prefix(es) of the User, or title in most Western languages. The <code>name.honorificSuffix</code> sub-attribute is the honorific suffix(es) of the USer, or suffix in most Western languages. The <code>displayName</code> attribute is the name of the user, suitable for display to end-users. Each user returned MAY include a non-empty <code>displayName</code> value. The <code>displayName</code> SHOULD be the full name of the User being described, if known, but MAY be a username or handle, if that is all that is available. The provided value of <code>displayName</code> SHOULD be the primary textual label by which the user is normally displayed by the service provider when presenting it to end-users. The <code>nickName</code> is the casual way to address the user in real life. This attribute SHOULD NOT be used to represent a User's username. The <code>profileUrl</code> attribute is a URI that points to a location representing the user's online profile. The <code>title</code> attribute is the user's title. The <code>userType</code> attribute is used to identify the relation between the organization and the user. The <code>preferredLanguage</code> attribute indicates the user's preferred written or spoken natural languages. The format of the <code>preferredLanguage</code> value is the same as the HTTP <code>Accept-Language</code> header field (not including \"Accept-Language:\"). The <code>locale</code> attribute is used to indicate the user's default location for purposes of localizing such items as currency, date time format, or numerical representations. A valid value of <code>locale</code> is a language tag as defined in RFC5646. The <code>timezone</code> attribute is the user's timezone, expressed in IANA Time Zone database format. The <code>active</code> attribute is a boolean value indicating the user's administrative status. The <code>password</code> attribute is intended to be used as a means to set, replace, or compare a password. The cleartext value or the hashed value of a <code>password</code> SHALL NOT be returnable by the service provider. If the service provider holds the value of the <code>password</code> locally, the value SHOULD be hashed. When a password is set or changed by the client, the cleartext password SHOULD be processed by the service provider as follows: prepare the cleartext value for international language comparison, validate the value against server password policy, and ensure that the value is encrypted. A service provider that immediately passes the cleartext value of the <code>password</code> on to another system or programming interface MUST pass the value directly over a secured connection. If the value of the <code>password</code> needs to be temporarily persisted for a period of time before provisioning, them the value MUST be protected by some method, such as encryption. Testing for an equality match for <code>password</code> MAY be supported if there is an existing stored hashed value. The mutability of the <code>password</code> attribute is <code>writeOnly</code>, indicating that the value MUST NOT be returned by a service provider in any form. The value of <code>emails</code> SHOULD be specified and canonicalized according to RFC5321. The <code>emails.display</code> sub-attribute MAY be used to return the canonicalized representation of the email value. The <code>emails.type</code> sub-attribute is used to provide a classification meaningful to the user. The value of <code>phoneNumbers</code> SHOULD be specified and canonicalized (when appropriate) according to the format defined in RFC3966. The <code>phoneNumbers.display</code> sub-attribute MAY be used to return the canonicalized representation of the phone number value. The <code>phoneNumbers.type</code> sub-attribute is used to provide a classification meaningful to the user. The <code>ims</code> attribute contains instant messaging addresses for the user. Service providers SHOULD, when appropriate, remove all whitespace and convert the <code>ims</code> address to lowercase. No official canonicalization rules exist for <code>ims</code>, but service providers MAY specify canonicalization rules. The <code>photos</code> attribute contains URIs that points to a resource locations representing the user's images. The <code>photos</code> MUST be files rather than a web pages containing an image. The <code>photos</code> attribute SHOULD NOT be used to send down arbitrary photos. The <code>photos.type</code> sub-attribute defines the following canonical values to represent photo sizes: <code>photo</code> and <code>thumbnail</code>. The <code>addresses</code> attribute contains physical mailing addresses for the user. All <code>addresses</code> sub-attributes are optional. The <code>addresses.formatted</code> sub-attribute is the full mailing address, formatted for display or use with a mailing label. It MAY contain newlines. The <code>addresses.streetAddress</code> sub-attribute is the full street address component. It MAY contain newlines. The <code>addresses.locality</code> sub-attribute is the city or locality component. The <code>addresses.region</code> sub-attribute is the state or region component. The <code>addresses.postalCode</code> sub-attribute is the zip code or postal code component. The <code>addresses.country</code> sub-attribute is the country name component. If <code>addresses.country</code> is specified, the value MUST be in ISO 3166-1 <code>alpha-2</code> code format. The <code>groups</code> attribute is a list of groups to which the user belongs, either through direct membership, through nested groups, or dynamically calculated. The canonical types are <code>direct</code> and <code>indirect</code>. Direct group membership indicates that the user is directly associated with the group and SHOULD indicate that clients may modify membership through the <code>Group</code> resource. Indirect membership indicates that user membership is transitive or dynamic and implies that clients cannot modify indirect group membership through the <code>Group</code> resource. If the service provider exposes a <code>Group</code> resource, the <code>groups.value</code> sub-attribute MUST be the <code>id</code>, and the <code>$ref</code> sub-attribute MUST be the URI of the corresponding <code>Group</code> resources to which the user belongs. The <code>groups</code> attribute is read-only. The group membership changes MUST be applied via the <code>Group</code> resource. The <code>entitlements</code> attribute is a list of entitlements for the user that represent a thing the user has. The <code>roles</code> attribute is a list of roles the user that collectively represent who the user is. The <code>x509Certificates</code> attribute is a list of certificates associated with the resource. Each value of <code>x509Certificates</code> attribute contains exactly one DER-encoded X.509 certificate, which MUST be base64 encoded. A single value of <code>x509Certificates</code> attribute MUST NOT contain multiple certificates and so does not contain the encoding \"SEQUENCE OF Certificate\" in any guise."},{"location":"compliance/#group-resource-schema","title":"\"Group\" Resource Schema","text":"Desired Behavior Validated Supported The core schema for <code>Group</code> is identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:Group</code>. The <code>displayName</code> attribute is a human-readable name for the group. The <code>members</code> attribute is a list of members of the Group. While values MAY be added or removed, sub-attributes of <code>members</code> are <code>immutable</code>. The <code>members.value</code> sub-attribute contains the value of an <code>id</code> attribute of a SCIM resource. The <code>members.$ref</code> sub-attribute must be the URI of a SCIM resource such as <code>User</code> or <code>Group</code>. Service providers MAY require clients to provide a non-empty <code>members.value</code> by setting the <code>required</code> characteristic."},{"location":"compliance/#enterprise-user-schema-extension","title":"Enterprise User Schema Extension","text":"Desired Behavior Validated Supported The enterprise <code>User</code> extension is defined using the following schema URI: <code>urn:ietf:params:scim:schemas:extension:enterprise:2.0:User</code>. The <code>employeeNumber</code> attribute is a string identifier, assigned to a person. The <code>costCenter</code> attribute identifies the name of a cost center. The <code>organization</code> attribute identifies the name of an organization. The <code>division</code> attribute identifies the name of a division. The <code>department</code> attribute identifies the name of a department. The <code>manager</code> complex attribute is the user's manager. The <code>manager.value</code> sub-attribute is the <code>id</code> of the SCIM resource representing the user's manager. The <code>manager.$ref</code> sub-attribute is the URI of the SCIM resource representing the user's manager. The <code>manager.displayName</code> sub-attribute is the display name of the user's manager. It is read-only."},{"location":"compliance/#service-provider-configuration-schema","title":"Service Provider Configuration Schema","text":"Desired Behavior Validated Supported Service provider's configuration is identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig</code> All attributes are read-only. The <code>id</code> attribute is not required for the service provider configuration resource. All attributes are required unless otherwise specified. The <code>documentationUri</code> attribute is optional, an HTTP-addressable URL pointing to the service provider's human-consumable help documentation. The <code>patch</code> attribute is a complex type that specifies PATCH configuration options. The <code>patch.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>bulk</code> attribute is a complex type that specifies bulk configuration options. The <code>bulk.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>bulk.maxOperations</code> sub-attribute value specifies the maximum number of operations. The <code>bulk.maxPayloadSize</code> sub-attribute value specifies the maximum payload size in bytes. The <code>filter</code> is a complex type that specifies filter options. The <code>filter.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>filter.maxResults</code> sub-attribute value specifies the maximum number of resources returned in a response. The <code>changePassword</code> is a complex type that specifies configuration options related to changing a password. The <code>changePassword.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>sort</code> is a complex type that specifies sort configuration options. The <code>sort.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>etag</code> is a complex type that specifies <code>ETag</code> configuration options. The <code>etag.supported</code> sub-attribute value specifies whether or not the operation is supported. The <code>authenticationSchemas</code> is a multi-valued complex type that specifies supported authentication scheme properties. To enable seamless discovery of configurations, the service provider SHOULD, with the appropriate security considerations, make the <code>authenticationSchemes</code> attribute publicly accessible without prior authentication. The <code>authenticationSchemas.type</code> sub-attribute is the authentication scheme. The <code>authenticationSchemas.name</code> sub-attribute is the common authentication scheme name. The <code>authenticationSchemas.description</code> sub-attribute is a description of the authentication scheme. The <code>authenticationSchemas.specUri</code> sub-attribute is an optional, HTTP-addressable URL pointing to the authentication scheme's specification. The <code>authenticationSchemas.documentationUri</code> sub-attribute is an optional, HTTP-addressable URL pointing to the authentication scheme's usage documentation."},{"location":"compliance/#resourcetype-schema","title":"ResourceType Schema","text":"Desired Behavior Validated Supported Resource type resources are identified using the following schema URI: <code>urn:ietf:params:scim:schemas:core:2.0:ResourceType</code>. All attributes are read-only. All attributes are required unless otherwise specified. The <code>id</code> attribute is optional, the resource type's server unique id. The <code>name</code> attribute is the resource type name. When applicable, service providers MUST specify the name of the resource. Resource type's name is referenced by the <code>meta.resourceType</code> sub-attribute in all resources. The <code>description</code> attribute is optional, the resource type's human-readable description. When applicable, service providers MUST specify the description of the resource. The <code>endpoint</code> attribute is the resource type's HTTP-addressable endpoint relative to the Base URL of the service provider. The <code>schema</code> attribute is the resource type's primary/base schema URI. The <code>schema</code> attribute MUST be equal to the <code>id</code> attribute of the associated <code>Schema</code> resource. The <code>schemaExtensions</code> attribute is an optional list of URIs of the resource type's schema extensions. The <code>schemaExtensions.schema</code> sub-attribute is the URI of an extended schema. The <code>schemaExtensions.schema</code> sub-attribute MUST be equal to the <code>id</code> attribute of a <code>Schema</code> resource. The <code>schemaExtensions.required</code> is a boolean value that specifies whether or not the schema extension is required for the resource type. If <code>schemaExtensions.required</code> is <code>true</code>, a resource of this type MUST include this schema extension and also include any attributes declared as required in this schema extension."},{"location":"compliance/#schema-definition","title":"Schema Definition","text":"Desired Behavior Validated Supported The schema is identified by the following URI: <code>urn:ietf:params:scim:schemas:core:2.0:Schema</code>. All attributes are read-only. Except for <code>id</code> attribute, which is always returned, all attributes are returned by default. All attributes are case-insensitive unless otherwise specified. <code>Schema</code> resource MAY contain a complex object within a sub-attribute. All attributes are required unless otherwise specified. The <code>id</code> attribute is the unique URI of the schema. When applicable, service providers MUST specify the URI of the schema. The schema <code>id</code> can be registered and is portable between different service providers and clients. The <code>name</code> attribute is the schema's human-readable name. When applicable, service providers SHOULD specify the name of the schema. The <code>description</code> attribute is the schema's human-readable description. When applicable, service providers SHOULD specify the description of the schema. The <code>attributes</code> attribute is a complex type that defines service provider attributes and their qualities. The <code>attributes.name</code> sub-attribute is the attribute's name. The <code>attributes.type</code> sub-attribute is the attribute's data type. Valid values of <code>attributes.type</code> are: <code>string</code>, <code>boolean</code>, <code>decimal</code>, <code>integer</code>, <code>dateTime</code>, <code>reference</code>, and <code>complex</code>. When an <code>attributes.type</code> is <code>complex</code>, there SHOULD be a corresponding schema attribute <code>subAttributes</code> defined, listing the sub-attributes of the attribute. The <code>attributes.subAttributes</code> sub-attribute defines a set of sub-attributes of a <code>complex</code> attribute. It has the same schema as <code>attributes</code>. The <code>attributes.multiValued</code> sub-attribute is a boolean value indicating the attribute's plurality. The <code>attributes.description</code> sub-attribute is the attribute's human-readable description. When applicable, service providers SHOULD specify the description of an attribute. The <code>attributes.required</code> sub-attribute is a boolean value that specifies whether or not the attribute is required. The <code>attributes.canonicalValues</code> sub-attribute is a optional collection of suggested canonical values that MAY be used. In some cases, service providers MAY choose to ignore values that are not canonical. The <code>attributes.caseExact</code> sub-attribute is a boolean value that specifies whether or not a string attribute is case-sensitive. The server SHALL use case sensitivity when evaluating filters. For attributes that are case-sensitive, the server SHALL preserve case for any value submitted. For attributes that are case-insensitive, the server MAY alter case for a submitted value. The <code>attributes.mutability</code> sub-attribute is a single keyword indicating the circumstances under which the value of the attribute can be (re)defined. The <code>attributes.mutability</code> sub-attribute set to <code>readOnly</code> means that the attribute SHALL NOT be modified. The <code>attributes.mutability</code> sub-attribute set to <code>readWrite</code> means that the attribute MAY be updated and read at any time. The <code>attributes.mutability</code> sub-attribute set to <code>immutable</code> means that the attribute MAY be defined at resource creation (POST) or at record replacement (PUT), but SHALL NOT be updated. The <code>attributes.mutability</code> sub-attribute set to <code>writeOnly</code> means that the attribute MAY be updated at any time, but values SHALL NOT be returned. The <code>attributes.returned</code> sub-attribute is a single keyword that indicates when an attribute and associated values are returned in response. The <code>attributes.returned</code> sub-attribute set to <code>always</code> means that the attribute is always returned, regardless of the contents of the <code>attributes</code> parameter. The <code>attributes.returned</code> sub-attribute set to <code>never</code> means that the attribute is never returned. Attributes that must not be returned MAY be used in a search filter. The <code>attributes.returned</code> sub-attribute set to <code>default</code> means that the attribute is returned by default in all SCIM operation responses where attribute values are returned. The behavior can be altered by the <code>attributes</code> and <code>excludedAttributes</code> parameters. The <code>attributes.returned</code> sub-attribute set to <code>request</code> means that the attribute is returned in response to any PUT, POST, or PATCH operations if the attribute was specified by the client. The attribute with <code>attributes.returned</code> characteristic set to <code>request</code> is returned in a SCIM query operation only if specified in the <code>attributes</code> parameter. If an attribute has <code>uniqueness</code> configured as \"global\", the value SHOULD  be globally unique. No two resources on any server SHOULD possess the same value. The <code>attributes.uniqueness</code> sub-attribute is a single keyword value that specifies how the service provider enforces uniqueness of attribute values. A server MAY reject an invalid value based on uniqueness by returning HTTP response code 400. A client MAY enforce uniqueness on the client side to a greater degree than the service provider enforces. The <code>attributes.uniqueness</code> sub-attribute set to <code>none</code> means that the values are not intended to be unique in any way. The <code>attributes.uniqueness</code> sub-attribute set to <code>server</code> means that the value SHOULD be unique within the context of the current SCIM endpoint (or tenancy) and MAY be globally unique. No two resources on the same server SHOULD possess the same value. The <code>attributes.uniqueness</code> sub-attribute set to <code>global</code> means that the value SHOULD  be globally unique. No two resources on any server SHOULD possess the same value. The <code>attributes.referenceTypes</code> sub-attribute is a multi-valued array of JSON strings that indicate the SCIM resource types that may be referenced. Valid values of <code>attributes.referenceTypes</code> are: a SCIM resource type, <code>external</code> - indicating that the resource is an external resource, <code>uri</code> - indicating that the reference is to a service endpoint or an identifier. The <code>attributes.referenceTypes</code> is only applicable for attributes that are of type <code>reference</code>."},{"location":"compliance/#protocol","title":"Protocol","text":""},{"location":"compliance/#background","title":"Background","text":"Desired Behavior Validated Supported Both resources and messages are passed in the form of JSON-based structures in the message body of an HTTP request or response. SCIM uses a media type of <code>application/scim+json</code>. A SCIM resource is a JSON object that may be created, maintained, and retrieved via HTTP request methods. Each JSON resource representation contains a <code>schemas</code> attribute that contains a list of one or more URIs that indicate included SCIM schemas that are used to indicate the attributes contained withing a resource. Specific information about what attributes are defined within a schema MAY be obtained by querying a SCIM service provider's <code>/Schemas</code> endpoint for a schema definition. SCIM clients should expect that some attribute schema may change from service provider to service provider. As with SCIM resource, SCIM message is a JSON object that contains a <code>schemas</code> attribute with a URI whose namespace prefix MUST begin with <code>urn:ietf:params:scim:api:</code>. As SCIM protocol messages are fixed and defined by SCIM specifications and registered extensions, SCIM message schemas using the above prefix URN SHALL NOT be discoverable using the <code>/Schemas</code> endpoint. SCIM client SHOULD NOT expect a service provider to return SCIM resources with exactly the same schema and values as submitted. SCIM responses SHALL reflect resource state as interpreted by the SCIM service provider."},{"location":"compliance/#scim-endpoints-and-http-methods","title":"SCIM Endpoints and HTTP Methods","text":"Desired Behavior Validated Supported Service providers that support extended resources SHOULD define resource endpoints using the convention of pluralizing the resource name defined in the extended schema, by appending an 's'. Given that there are cases where resource pluralization is ambiguous, e.g., a resource named \"Person\" is legitimately \"Persons\" and \"People\", clients SHOULD discover resource endpoints via the <code>/ResourceTypes</code> endpoint. Error status codes SHOULD be transmitted via the HTTP status code of the response (if possible) and SHOULD also be specified in the body of the response."},{"location":"compliance/#creating-resources","title":"Creating Resources","text":"Desired Behavior Validated Supported To create new resources, clients send HTTP POST requests to the resource endpoint. In the request body, attributes whose mutability is <code>readOnly</code> SHALL be ignored. Attributes whose mutability is <code>readWrite</code> and that are omitted from the request body MAY be assumed to be not asserted by the client. The service provider MAY assign a default value to non-asserted attributes in the final resource representation. Service providers MAY take into account whether or not a client has access to all of the resource's attributes when deciding whether or not non-asserted attributes should be defaulted. Clients that intend to override existing or server-defaulted values for attributes MAY specify <code>null</code> for a single-valued attribute or an empty array <code>[]</code> for a multi-valued attribute to clear all values. When the service provider successfully creates the new resource, an HTTP response SHALL be returned with HTTP status code 201 (Created). The response body SHOULD contain the service provider's representation of the newly created resource. The URI of the created resource SHALL include, in the HTTP <code>Location</code> header and the HTTP body, a JSON representation with the attribute <code>meta.location</code>. If the service provider determines that the creation of the requested resource conflicts with existing resources (e.g., a <code>User</code> resource with a duplicate <code>userName</code>), the service provider MUST return HTTP status code 409 (Conflict) with a <code>scimType</code> error code of <code>uniqueness</code>. When adding a resource to a specific endpoint, the <code>meta.resourceType</code> sub-attribute SHALL be set by the HTTP service provider to the corresponding resource type for the endpoint."},{"location":"compliance/#retrieving-resources","title":"Retrieving Resources","text":"Desired Behavior Validated Supported Resources MAY be retrieved via opaque, unique URLs or via queries. The attributes returned are defined in the server's attribute schema and may be modified by request parameters. By default, resource attributes returned in a response are those attributes whose characteristic <code>returned</code> setting is <code>always</code> or <code>default</code>. To retrieve a known resource, clients send GET requests to the resource endpoint. If the resource exists, the server responds with HTTP status code 200 (OK) and includes the result in the body of the response. Queries MAY be made against a single resource or a resource type endpoint, or the service provider Base URI. SCIM service providers MAY support additional query parameters not specified here and SHOULD ignore any query parameters they do not recognize instead of rejecting the query for versioning compatibility reasons. Responses MUST be identified using the following URI: <code>urn:ietf:params:scim:api:messages:2.0:ListResponse</code>. The <code>totalResults</code> attribute is the total number of results returned by the list or query operation. The value of <code>totalResults</code> may be larger than the number of resources returned, such as when returning a single page of results where multiple pages are available. The value of <code>totalResults</code> is required. The <code>Resources</code> attribute is a multi-valued list of complex objects containing the requested resources. The <code>Resources</code> MAY be a subset of the full set of resources if pagination is requested. The <code>Resources</code> attribute is required if <code>totalResults</code> is non-zero. The <code>startIndex</code> attribute is the 1-based index of the first result in the current set of list results. The <code>startIndex</code> attribute value is required when partial results are returned due to pagination. The <code>itemsPerPage</code> attribute is the numer of resources returned in a list response page. The <code>itemsPerPage</code> attribute value is required when partial results are returned due to pagination. A query that does not return any matches SHALL return success (HTTP status code 200) with <code>totalResults</code> set to a value of <code>0</code>. A query against a server root indicates that all resources within the server SHALL be included, subject to filtering. If a SCIM service provider determines that too many results would be returned, the server SHALL reject the request by returning an HTTP response with HTTP status code 400 (Bad Request) and JSON attribute <code>scimType</code> set to <code>tooMany</code>. For filtered attributes that are not part of a particular resource type, the service provider SHALL treat the attribute as if there is no attribute value.  For example, a presence or equality filter for an undefined attribute evaluates to false. Filtering is an OPTIONAL parameter for SCIM service providers. Clients MAY discover service provider filter capabilities by looking at the <code>filter</code> attribute of the <code>ServiceProviderConfig</code> endpoint. Clients MAY request a subset of resources by specifying the <code>filter</code> query parameter containing a filter expression. When specified, only those resources matching the filter expression SHALL be returned. The expression language that is used with the <code>filter</code> parameter supports references to attributes and literals. Attribute names and attribute operators used in filters are case insensitive. The <code>filter</code> parameter MUST contain at least one valid expression. Each <code>filter</code> expression MUST contain an attribute name followed by an attribute operator and optional value. Multiple <code>filter</code> expressions MAY be combined using logical operators. The <code>filter</code> expressions MAY be grouped together using round brackets. If <code>eq</code> operator is used, the attribute and operator values must be identical for a match. If <code>ne</code> operator is used, the attribute and operator values must differ. If <code>co</code> operator is used, the entire operator value must be a substring of the attribute value for a match. If <code>sw</code> operator is used, the entire operator value must be a substring of the attribute value, starting at the beginning of the attribute value. If <code>ew</code> operator is used, the entire operator value must be a substring of the attribute value, matching at the end of the attribute value. If <code>pr</code> operator is used, if the attribute has a non-empty or non-null value, or if it contains a non-empty node for complex attributes, there is a match. If <code>gt</code> operator is used, if the attribute value is greater than the operator value, there is a match. If <code>ge</code> operator is used, if the attribute value is greater than or equal to the operator value, there is a match. If <code>lt</code> operator is used, if the attribute value is less than the operator value, there is a match. If <code>le</code> operator is used, if the attribute value is less than or equal to the operator value, there is a match. The <code>gt</code>, <code>ge</code>, <code>lt</code>, and <code>le</code> operators can be used together with string, dateTime and numeric attributes. Boolean and Binary attributes with gr / ge / lt / le <code>filter</code> operators SHALL cause a failed response (HTTP status code 400) with <code>scimType</code> of <code>invalidFilter</code>. If <code>and</code> operator is used, the filter is only a match if both expressions evaluate to <code>true</code>. If <code>or</code> operator is used, the filter is a match if either expression evaluates to <code>true</code>. If <code>not</code> operator is used, the filter is a match if the expression evaluates to <code>false</code>. Boolean expressions MAY be grouped using parentheses to change the standard order of operations. Service providers MAY support complex filters where expressions MUST be applied to the same value of a parent attribute specified immediately before the left square bracket <code>[</code>. The expression within square brackets MUST be a valid filter expression based upon sub-attributes of the parent attribute. Nested expressions MAY be used. Filters MUST be evaluated using the following order of operations, in order of precedence: 1. Grouping orders, 2. Logical operators - where <code>not</code> takes precedence over <code>and</code>, which takes precedence over <code>or</code>, 3. Attribute operators. If the specified attribute in a <code>filter</code> expression is a multi-valued attribute, the filter matches if any of the values of the specified attribute match the specific criterion. For singular complex attributes, a fully qualified sub-attribute MUST be specified using standard attribute notation. For singular complex attributes, a fully qualified sub-attribute MUST be specified using standard attribute notation. When applying a comparison or presence filter to a defaulted attribute, the service provider SHALL use the value that was returned to the client that last created or modified the attribute. Providers MAY support additional <code>filter</code> operations if they choose. Providers MUST decline to <code>filter</code> results if the specified filter operation is not recognized and return an HTTP 400 error with a <code>scimType</code> error of <code>invalidFilter</code> and an appropriate human-readable response. When comparing attributes of type String, the case sensitivity for String type attributes SHALL be determined by the attribute's <code>caseExact</code> characteristic. Clients MAY query by schema or schema extensions by using a filter expression including the <code>schemas</code> attribute. SCIM filters MUST conform to the following ABNF rules:  <code>FILTER = attrExp / logExp / valuePath / *1\"not\" \"(\" FILTER \")\"</code><code>valuePath = attrPath \"[\" valFilter \"]\"</code><code>valFilter = attrExp / logExp / *1\"not\" \"(\" valFilter \")\"</code><code>attrExp = (attrPath SP \"pr\") / (attrPath SP compareOp SP compValue)</code><code>logExp = FILTER SP (\"and\" / \"or\") SP FILTER</code><code>compValue = false / null / true / number / string</code><code>compareOp = \"eq\" / \"ne\" / \"co\" / \"sw\" / \"ew\" / \"gt\" / \"lt\" / \"ge\" / \"le\"</code><code>attrPath = [URI \":\"] ATTRNAME *1subAttr</code><code>ATTRNAME = ALPHA *(nameChar)</code><code>nameChar = \"-\" / \"_\" / DIGIT / ALPHA</code><code>subAttr = \".\" ATTRNAME</code> Sort is OPTIONAL. Clients MAY discover sort capability by looking at the <code>sort</code> attribute of the service provider configuration. The <code>sortBy</code> parameter specifies the attribute whose value SHALL be used to order the returned responses. If the <code>sortBy</code> attribute corresponds to a singular attribute, resources are sorted according to that attribute's value. If it's a multi-valued attribute, resources are sorted by the value of the primary attribute, if any, or else the first value in the list, if any. If the attribute is complex, the attribute name must be a path to a sub-attribute in standard attribute notation. For all attribute types, if there is no data for the specified <code>sortBy</code> value, they are sorted via the <code>sortOrder</code> parameter, i.e., they are ordered last if ascending and first if descending. If a value for <code>sortBy</code> is provided and no <code>sortOrder</code> is specified, <code>sortOrder</code> SHALL default to ascending. The <code>sortOrder</code> MUST sort according to the attribute type; i.e., for case-insensitive attributes, sort the result using case-insensitive Unicode alphabetic sort order with no specific locale implied, and for case-exact attribute types, sort the result using case-sensitive Unicode alphabetic sort order. Pagination is not stateful and clients MUST be prepared to handle inconsistent results. The <code>startIndex</code> parameter is 1-based index of the first query result. A value of <code>startIndex</code> less than <code>1</code> SHALL be interpreted as <code>1</code>. The <code>count</code> parameter is non-negative integer. Specifies the desired maximum number of query results per page. A negative value of <code>count</code> SHALL be interpreted as <code>0</code>. A <code>count</code> value of <code>0</code> indicates that no resource results are to be returned except for <code>totalResults</code>. When <code>count</code> is specified, the service provider MUST NOT return more results than specified, although it MAY return fewer results. If <code>count</code> is unspecified, the maximum number of results is set by the service provider. The <code>attributes</code> and <code>excludedAttributes</code> parameters control which attributes SHALL be returned with a returned resource. SCIM clients MAY use <code>attributes</code> or <code>excludedAttributes</code>, which are optional parameters, which MUST be supported by SCIM service providers. The <code>attributes</code> parameter is multi-valued list of strings indicating the names of resource attributes to return in the response, overriding the set of attributes that would be returned by default. Attribute names MUST be in standard attribute notation form. The <code>excludedAttributes</code> parameter is multi-valued list of strings indicating the names of resource attributes to be removed from the default set of attributes to return. This parameter SHALL have no effect on attributes whose schema <code>returned</code> setting is <code>always</code>. Attribute names MUST be in standard attribute notation form. Clients MAY execute queries without passing parameters on the URL by using the HTTP POST verb combined with the <code>/.search</code> path extension. The inclusion of <code>/.search</code> on the end of a valid SCIM endpoint SHALL be used to indicate that the HTTP POST verb is intended to be a query operation To create a new query result set, a SCIM client sends an HTTP POST request to the desired SCIM resource endpoint. The body of the POST request MAY include any of these parameters: <code>attributes</code>, <code>excludedAttributes</code>, <code>filter</code>, <code>sortBy</code>, <code>sortOrder</code>, <code>startIndex</code>, <code>count</code> (meaning unchanged). Query requests MUST be identified using the following URI: <code>urn:ietf:params:scim:api:messages:2.0:SearchRequest</code>."},{"location":"compliance/#modifying-resources","title":"Modifying Resources","text":"Desired Behavior Validated Supported Implementers MUST support HTTP PUT. Resources such as Groups may be very large. Hence, implementers SHOULD support HTTP PATCH to enable partial resource modifications. Service provider support for HTTP PATCH may be discovered by querying the service provider configuration. HTTP PUT MUST NOT be used to create new resources. As the PUT operation's intent is to replace all attributes, SCIM clients MAY send all attributes, regardless of each attribute's mutability. Any values provided for <code>readWrite</code> and <code>writeOnly</code> attributes in HTTP PUT SHALL replace the existing attribute values. In the PUT operation, attributes whose mutability is <code>readWrite</code> that are omitted from the request body MAY be assumed to be not asserted by the client. The service provider MAY assume that any existing values are to be cleared, or the service provider MAY assign a default value to the final resource representation. In the PUT operation, service providers MAY take into account whether or not a client has access to, or understands, all of the resource's attributes when deciding whether non-asserted attributes SHALL be removed or defaulted. In the PUT operation, clients that want to override a server's defaults MAY specify <code>null</code> for a single-valued attribute, or an empty array <code>[]</code> for a multi-valued attribute, to clear all values. In the PUT operation, if one or more values are already set for an <code>immutable</code> attribute, the input value(s) MUST match, or HTTP status code 400 SHOULD be returned with a <code>scimType</code> error code of <code>mutability</code>. In the PUT operation, for <code>immutable</code> attribute(s), if the service provider has no existing values, the new value(s) SHALL be applied. In the PUT operation, any values for <code>readOnly</code> attributes SHALL be ignored. In the PUT operation, if an attribute is <code>required</code>, clients MUST specify the attribute in the PUT request. Unless otherwise specified, a successful PUT operation returns a <code>200 OK</code> response code an the entire resource within the response body, enabling the client to correlate the client's and the service provider's views of the updated resource. HTTP PATCH is an OPTIONAL server function that enables clients to update one or more attributes of a SCIM resource using a sequence of operations to <code>add</code>, <code>remove</code>, or <code>replace</code> values. Clients may discover service provider support for PATCH by querying the service provider configuration. The body of each HTTP PATCH request MUST contain the <code>schemas</code> attribute with the URI value of <code>urn:ietf:params:scim:api:messages:2.0:PatchOp</code>. The body of an HTTP PATCH request MUST contain the attribute <code>Operations</code>, whose value is an array of one or more PATCH operations. Each PATCH operation object MUST have exactly one <code>op</code> member, whose value indicates the operation to perform and MAY be one of <code>add</code>, <code>remove</code>, or <code>replace</code>. In the PATCH operation, the <code>path</code> attribute value is a String containing an attribute path describing the target of the operation. The <code>path</code> attribute is OPTIONAL for <code>add</code> and <code>replace</code> and is REQUIRED for <code>remove</code> operations. In the PATCH operation, the <code>path</code> attribute is described by the ABNF syntax rule:<code>PATH = attrPath / valuePath [subAttr]</code> Each PATCH operation against an attribute MUST be compatible with the attribute's mutability and schema. A client MUST NOT modify an attribute that has mutability <code>readOnly</code> or <code>immutable</code>. However, a client MAY <code>add</code> a value to an <code>immutable</code> attribute if the attribute had no previous value. An operation that is not compatible with an attribute's mutability or schema SHALL return the appropriate HTTP response status code and a JSON detail error response. For multi-valued attributes, a PATCH operation that sets a value's <code>primary</code> sub-attribute to <code>true</code> SHALL cause the server to automatically set <code>primary</code> to <code>false</code> for any other values in the array. The PATCH request, regardless of the number of operations, SHALL be treated as atomic. If a single operation encounters an error condition, the original SCIM resource MUST be restored, and a failure status SHALL be returned. If the PATCH operation request fails, the server SHALL return an HTTP response status code and a JSON detail error response. On successful completion, the server either MUST return a 200 OK response code and the entire resource within the response body, subject to the <code>attributes</code> query parameter, or MAY return HTTP status code 204 (No Content) and the appropriate response headers for a successful PATCH request. The server MUST return a 200 OK if the <code>attributes</code> parameter is specified in the request. The PATCH <code>add</code> operation MUST contain a <code>value</code> member whose content specifies the value to be added. The value MAY be a quoted value, or it may be a JSON object containing the sub-attributes of the complex attribute specified in the operation's <code>path</code>. If <code>path</code> in PATCH <code>add</code> is omitted, the target location is assumed to be the resource itself. The <code>value</code> parameter contains a set of attributes to be added to the resource. In the PATCH <code>add</code> operation, if the target location does not exist, the attribute and value are added. In the PATCH <code>add</code> operation, if the target location specifies a complex attribute, a set of sub-attributes SHALL be specified in the <code>value</code> parameter. In the PATCH <code>add</code> operation, if the target location specifies a multi-valued attribute, a new value is added to the attribute. In the PATCH <code>add</code> operation, if the target location specifies a single-valued attribute, the existing value is replaced. In the PATCH <code>add</code> operation, if the target location already contains the value specified, no changes SHOULD be made to the resource, and a success response SHOULD be returned. Unless other operations change the resource, this operation SHALL NOT change the modify timestamp of the resource. In the PATCH <code>remove</code> operation, if <code>path</code> is unspecified, the operation fails with HTTP status code 400 and a <code>scimType</code> error code of <code>noTarget</code>. In the PATCH <code>remove</code> operation, if the target location is a single-value attribute, the attribute and its associated value is removed, and the attribute SHALL be considered unassigned. In the PATCH <code>remove</code> operation, if the target location is a multi-valued attribute and no filter is specified, the attribute and all values are removed, and the attribute SHALL be considered unassigned. In the PATCH <code>remove</code> operation, if the target location is a multi-valued attribute and a complex filter is specified comparing a <code>value</code>, the values matched by the filter are removed. If no other values remain after removal of the selected values, the multi-valued attribute SHALL be considered unassigned. In the PATCH <code>remove</code> operation, if the target location is a complex multi-valued attribute and a complex filter is specified based on the attribute's sub-attributes, the matching records are removed. Sub-attributes whose values have been removed SHALL be considered unassigned. If the complex multi-valued attribute has no remaining records, the attribute SHALL be considered unassigned. In the PATCH <code>remove</code> operation, if an attribute is removed or becomes unassigned and is defined as a required attribute or a read-only attribute, the server SHALL return an HTTP response status code and a JSON detail error response, with a <code>scimType</code> error code of <code>mutability</code>. In the PATCH <code>replace</code> operation, if the <code>path</code> parameter is omitted, the target is assumed to be the resource itself. In this case, the <code>value</code> attribute SHALL contain a list of one or more attributes that are to be replaced. In the PATCH <code>replace</code> operation, if the target location specifies an attribute that does not exist, the service provider SHALL treat the operation as an <code>add</code>. In the PATCH <code>replace</code> operation, if the target location specifies a complex attribute, a set of sub-attributes SHALL be specified in the <code>value</code> parameter, which replaces any existing values or adds where an attribute did not previously exist. Sub-attributes that are not specified in the <code>value</code> parameter are left unchanged. In the PATCH <code>replace</code> operation, if the target location is a multi-valued attribute and a value selection (<code>valuePath</code>) filter is specified that matches one or more values of the multi-valued attribute, then all matching record values SHALL be replaced. In the PATCH <code>replace</code> operation, if the target location is a complex multi-valued attribute with a value selection filter (<code>valuePath</code>) and a specific sub-attribute (e.g., <code>addresses[type eq \"work\"].streetAddress</code>), the matching sub-attribute of all matching records is replaced. In the PATCH <code>replace</code> operation, if the target location is a multi-valued attribute for which a value selection filter (<code>valuePath</code>) has been supplied and no record match was made, the service provider SHALL indicate failure by returning HTTP status code 400 and a <code>scimType</code> error code of <code>noTarget</code>."},{"location":"compliance/#deleting-resources","title":"Deleting Resources","text":"Desired Behavior Validated Supported Service providers MAY choose not to permanently delete the resource but MUST return a 404 (Not Found) error code for all operations associated with the previously deleted resources. Service providers MUST omit the resource from future query results. In addition, the service provider SHOULD NOT consider the deleted resource in conflict calculation. For example, if a User resource is deleted, a CREATE request for a <code>User</code> resource with the same <code>userName</code> as the previously deleted resource SHOULD NOT fail with a 409 error due to <code>userName</code> conflict."},{"location":"compliance/#bulk-operations","title":"Bulk Operations","text":"Desired Behavior Validated Supported Support for bulk requests can be discovered by querying the service provider configuration. Bulk requests are identified using the following schema URI: \"urn:ietf:params:scim:api:messages:2.0:BulkRequest\". Bulk responses are identified using the following URI: \"urn:ietf:params:scim:api:messages:2.0:BulkResponse\". The <code>failOnErrors</code> attribute is an integer specifying the number of errors that the service provider will accept before the operation is terminated and an error response is returned. Optional in the request. Not valid in a response. The <code>Operations</code> attribute defines operations within a bulk job. Each operation corresponds to a single HTTP request against a resource endpoint. The <code>Operations.method</code> sub-attribute is the HTTP method of the current operation. Possible values are <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code>. Required. The <code>Operations.bulkId</code> sub-attribute is the transient identifier of a newly created resource, unique within a bulk request and created by the client. Required when <code>Operations.method</code> is POST. The <code>Operations.version</code> sub-attribute is the current resource version. Version MAY be used if the service provider supports entity-tags and <code>Operations.method</code> is <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code>. The <code>Operations.path</code> sub-attribute is the resource's relative path to the SCIM service provider's root. If <code>Operations.method</code> is <code>POST</code>, the value must specify a resource type endpoint, e.g., <code>/Users</code> or <code>/Groups</code>, whereas all other <code>Operations.method</code> values must specify the path to a specific resource. Required in a request. The <code>Operations.data</code> sub-attribute is the resource data as it would appear for a single SCIM POST, PUT, or PATCH operation. Required in a request when <code>Operations.method</code> is <code>POST</code>, <code>PUT</code>, or <code>PATCH</code>. The <code>Operations.location</code> sub-attribute is the resource endpoint URL. Required in a response, except in the event of a POST failure. The <code>Operations.response</code> sub-attribute is the HTTP response body for the specified request operation. When indicating a response with an HTTP status other than a 200-series response, the response body MUST be included. For normal completion, the server MAY elect to omit the response body. The <code>Operations.status</code> sub-attribute is the HTTP response status code for the requested operation. When indicating an error, the <code>Operations.response</code> sub-attribute MUST contain the details error response. If a bulk job is processed successfully, HTTP response code 200 OK MUST be returned; otherwise, an appropriate HTTP error code MUST be returned. The service provider MUST continue performing as many changes as possible and disregard partial failures. The client MAY override this behavior by specifying a value for the <code>failOnErrors</code> attribute. To be able to reference a newly created resource, the <code>bulkId</code> attribute MAY be specified when creating new resources. The <code>bulkId</code> is defined by the client as a surrogate identifier in a POST operation. The service provider MUST return the same <code>bulkId</code> together with the newly created resource. The <code>bulkId</code> can then be used by the client to map the service provider id with the <code>bulkId</code> of the created resource. The service provider MUST replace <code>bulkId</code> with the permanent resource id once created. A SCIM service provider MAY elect to optimize the sequence of operations received (e.g., to improve processing performance). When doing so, the service provider MUST ensure that the client's intent is preserved and the same stateful result is achieved as for non-optimized processing. The service provider MUST try to resolve circular cross-references between resources in a single bulk job but MAY stop after a failed attempt and instead return HTTP status code 409 (Conflict). Extensions that include references to other resources MUST be handled in the same way by the service provider. The service provider MUST define the maximum number of operations and maximum payload size a client may send in a single request. These limits MAY be retrieved from the service provider configuration. If either limit is exceeded, the service provider MUST return HTTP response code 413 (Payload Too Large).  The returned response MUST specify the limit exceeded in the body of the error response."},{"location":"compliance/#data-inputoutput-formats","title":"Data Input/Output Formats","text":"Desired Behavior Validated Supported Servers MUST accept requests and be able to return JSON-structured responses using UTF-8 encoding. UTF-8 SHALL be the default encoding format. Clients using other encodings MUST specify the format in which the data is submitted via an HTTP <code>Content-Type</code> header and MAY specify the desired response data format via HTTP <code>Accept</code> header. Service providers MUST support the <code>Accept</code> header <code>Accept: application/scim+json</code> and SHOULD support the header <code>Accept: application/json</code>. The format defaults to <code>application/scim+json</code> if no format is specified. Singular attributes are encoded as string name-value pairs in JSON. Multi-valued attributes in JSON are encoded as arrays. Elements with nested elements are represented as objects in JSON."},{"location":"compliance/#additional-operation-response-parameters","title":"Additional Operation Response Parameters","text":"Desired Behavior Validated Supported For any SCIM operation where a resource representation is returned, the attributes returned are defined as the minimum attribute set plus default attribute set. The minimum set is composed of those attributes that have their <code>returned</code> characteristic set to <code>always</code>. The default attribute set is composed of those attributes that have the <code>returned</code> characteristic set to <code>default</code>. Clients MAY request a partial resource representation on any operation that returns a resource within the response by specifying either of the mutually exclusive URL query parameters <code>attributes</code> or <code>excludedAttributes</code>. When <code>attributes</code> is specified, the default list of attributes SHALL be overridden, and each resource returned MUST contain the minimum set of resource attributes and any attributes or sub-attributes explicitly requested by this parameter. The query parameter attributes value is a comma-separated list of resource attribute names in standard attribute notation. When <code>excludedAttributes</code> is specified, each resource returned MUST contain the minimum set of resource attributes. Additionally, the default set of attributes minus those attributes listed in this parameter is returned. The query parameter attributes value is a comma-separated list of resource attribute names in standard attribute notation."},{"location":"compliance/#attribute-notation","title":"Attribute Notation","text":"Desired Behavior Validated Supported Attributes are uniquely identified by prefixing the attribute name with its schema URN separated by a colon character. Clients MAY omit core schema attribute URN prefixes but SHOULD fully qualify extended attributes with the associated schema extension URN. All facets of the fully encoded attribute name are case insensitive."},{"location":"compliance/#me-authenticated-subject-alias","title":"\"/Me\" Authenticated Subject Alias","text":"Desired Behavior Validated Supported A client MAY use a URL of the form <code>&lt;base-URI&gt;/Me</code> as URI alias for the User or other resource associated with the currently authenticated subject for any SCIM operation. A service provider that does NOT support this feature SHOULD respond with HTTP status code 501. A service provider MAY choose to redirect the client using HTTP status code 308 to the resource associated with the authenticated subject. A service provider MAY process the SCIM request directly. In any response, the HTTP <code>Location</code> header MUST be the permanent location of the aliased resource associated with the authenticated subject. When using the SCIM Create Resource command (HTTP POST) with the <code>/Me</code> alias, the desired resource type being created is at the discretion of the service provider, based on the authenticated subject (if not anonymous) making the request and any request body attributes (e.g., <code>schemas</code>)."},{"location":"compliance/#http-status-and-error-response-handling","title":"HTTP Status and Error Response Handling","text":"Desired Behavior Validated Supported The SCIM protocol uses the HTTP response status codes to indicate operation success or failure. In addition to returning an HTTP response code, implementers MUST return the errors in the body of the response in a JSON format. Error responses are identified using the following <code>schema</code> URI: <code>urn:ietf:params:scim:api:messages:2.0:Error</code>. The <code>status</code> attribute is the required HTTP status code expressed as a JSON string. The <code>scimType</code> attribute is an optional SCIM detail error keyword. The <code>detail</code> attribute is a detailed human-readable message."},{"location":"compliance/#scim-protocol-versioning","title":"SCIM Protocol Versioning","text":"Desired Behavior Validated Supported The Base URL MAY be appended with a version identifier as a separate segment in the URL path. If version identifier is specified, it MUST appear in the URL path immediately preceding the resource endpoint and conform to the following scheme: the character <code>v</code> followed by the desired SCIM version number, e.g., a version <code>v2</code> User request is specified as <code>/v2/Users</code>. When version identifier is specified, service providers MUST perform the operation using the desired version or reject the request. When version identifier is omitted, service providers SHOULD perform the operation using the most recent SCIM protocol version supported by the service provider."},{"location":"compliance/#versioning-resources","title":"Versioning Resources","text":"Desired Behavior Validated Supported The SCIM protocol supports resource versioning via standard HTTP ETags. Service providers MAY support weak ETags as the preferred mechanism for performing conditional retrievals and ensuring that clients do not inadvertently overwrite each other's changes, respectively. When supported, SCIM Etags MUST be specified as an HTTP header and SHOULD be specified within the <code>meta.version</code> sub-attribute contained in the resource."},{"location":"compliance/#service-provider-configuration-endpoints","title":"Service Provider Configuration Endpoints","text":"Desired Behavior Validated Supported SCIM defines three endpoints to facilitate discovery of SCIM service provider and schema that MAY be retrieved using HTTP GET: <code>/ServiceProviderConfig</code>, <code>/Schemas</code>, <code>/ResourceTypes</code>. An HTTP GET to <code>/ServiceProviderConfig</code> endpoint returns a JSON structure that describes the SCIM specification features available on a service provider. The <code>/ServiceProviderConfig</code> endpoint SHALL return responses with a JSON object using <code>schemas</code> attribute of <code>urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig</code>. An HTTP GET to <code>/Schemas</code> endpoint is used to retrieve information about resource schemas supported by a SCIM service provider. The <code>/Schemas</code> endpoint SHALL return all supported schemas in <code>ListResponse</code> format. Individual schema definitions can be returned by appending the schema URI to the <code>Schemas</code> endpoint. An HTTP GET to <code>/ResourceTypes</code> endpoint is used to discover the types of resources available on a SCIM service provider. Each resource type defines the endpoint, the core schema URI that defines the resource, and any supported schema extensions. In case where a request is for a specific <code>ResourceType</code> or <code>Schema</code>, the single JSON object is returned in the same way that a single User or Groups is retrieved. When returning multiple <code>ResourceTypes</code> or <code>Schemas</code>, the message form described by the <code>ListResponse</code> form SHALL be used. Query parameters such as for filtering, sorting, and pagination, SHALL be ignored. If a <code>filter</code> is provided, the service provider SHOULD respond with HTTP status code 403 (Forbidden)."},{"location":"compliance/#preparation-and-comparison-of-internationalized-strings","title":"Preparation and Comparison of Internationalized Strings","text":"Desired Behavior Validated Supported Before comparing or evaluating the uniqueness of a <code>userName</code> or <code>password</code> attribute, service providers MUST use the PRECIS preparation and comparison rules."},{"location":"compliance/#multi-tenancy","title":"Multi-Tenancy","text":"Desired Behavior Validated Supported Multi-tenancy is optional. The SCIM protocol does not define a scheme for multi-tenancy. The SCIM protocol deos not prescribe the mechanisms whereby clients and service providers interact for: 1. Registering or provisioning Tenants, 2. Associating a subset of clients with a subset of the Tenants, 3. Indicating which tenant is associated with the data in a request or response, or indicating which Tenant is the subject of a query. The service provider MAY use one of the authentication mechanisms to determine the identity of the client and thus infer the associated Tenant. For implementations where a client is associated with more than one Tenant, the service provider MAY use one of the three methods for explicit specification of the Tenant: 1. A URL prefix: <code>https://www.example.com/Tenants/{tenant_id}/v2/Users</code>, 2. A sub-domain: <code>https://{tenant_id}.example.com/v2/Groups</code>, 3. An HTTP header. The service provider may choose to implement SCIM ids that are unique across all resources for all Tenants, but this is not required. The <code>externalId</code>, defined by the client, is required to be unique ONLY within the resources associated with the associated Tenant."},{"location":"compliance/#security-considerations","title":"Security Considerations","text":"Desired Behavior Validated Supported A SCIM client MUST NOT generate <code>userinfo</code> component when <code>http</code> URI reference is generated with a message. SCIM clients MUST require the use of TLS mechanism when communicating with SCIM service providers. The SCIM service provider MUST support TLS 1.2 and MAY support additional transport-layer mechanisms meeting its security requirements. When using TLS, the client MUST perform a TLS/SSL server identity check. Bearer tokens and cookies MUST contain sufficient entropy to prevent a random guessing attack. Bearer tokens and cookies MUST be exchanged using TLS. Bearer tokens MUST have a limited lifetime that can be determined directly or indirectly by the service provider. In OAuth 2.0, a client MAY use OAuth token refresh to obtain a new bearer token after authenticating to an authentication server. An HTTP cookie SHOULD last no longer than the lifetime of a browser session. An expiry time should be set that limits session cookie lifetime. SCIM clients requesting information using query filters that use HTTP GET SHOULD give consideration to the information content of the filters and whether or not their exposure in a URI would represent a breach of security or confidentiality through leakage in web browsers or server logs. For information that is legally considered \"personally identifiable information\", clients SHOULD query using HTTP POST. Servers that receive HTTP GET requests using filters that contain sensitive or confidential personal information SHOULD respond with HTTP status code 403. A <code>scimType</code> error code of <code>sensitive</code> may be returned to indicate that the request must be submitted using POST. For anonymous requests, the service provider MAY try to authenticate web user interface components that formulate the SCIM creation request (e.g. CAPTCHA). For anonymous requests, the service provider MAY limit the number of requests that any particular client MAY make in a period of time. For anonymous requests, for User resources, the service provider MAY default newly created resources with an <code>active</code> setting of <code>false</code>, and use a secondary confirmation process (e.g., email confirmation) to ensure that the resource created is real. Service providers SHOULD follow recommendations outlined in RFC6819 for secure storage and handling of sensitive data. Service providers SHOULD define an access control model that differentiates between individual client applications and their specific need to access information, and any User self-service rights to review and update personal profile information."},{"location":"users_guide/","title":"User's Guide","text":"<p><code>scimpler</code> provides functionalities that can be used both on Service Provider and Provisioning client sides. It is agnostic to any existing web frameworks, so it probably will not work out of the box in your case. However, most of the hard work has already been done for you. SCIM 2.0 protocol exactly specifies how the entities may, should, and must behave (depending on the case). <code>scimpler</code> maps all possible requirements and makes them ready to use.</p> <p><code>scimpler</code>, among many features, enables SCIM schema definition and stateless validation. This means that any requirement specified by the protocol that requires state is not checked by the library.</p> <p>Check below topics to learn more about <code>scimpler</code>.</p> <p>Schema definition Data validation Data deserialization and serialization Working with data Filtering Sorting Request and response validation Integrations</p>"},{"location":"users_guide/#schema-definition","title":"Schema definition","text":"<p><code>scimpler</code> provides all schemas specified by the standard, and some of them can be adjusted for a particular needs.</p> <p>Resource schemas and extensions</p> <ul> <li>urn:ietf:params:scim:schemas:core:2.0:User</li> <li>urn:ietf:params:scim:schemas:extension:Enterprise:2.0:User</li> <li>urn:ietf:params:scim:schemas:core:2.0:Group</li> <li>urn:ietf:params:scim:schemas:core:2.0:ResourceType</li> <li>urn:ietf:params:scim:schemas:core:2.0:Schema</li> <li>urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig</li> </ul> <p>API message schemas</p> <ul> <li>urn:ietf:params:scim:api:messages:2.0:Error</li> <li>urn:ietf:params:scim:api:messages:2.0:ListResponse</li> <li>urn:ietf:params:scim:api:messages:2.0:SearchRequest</li> <li>urn:ietf:params:scim:api:messages:2.0:PatchOp</li> <li>urn:ietf:params:scim:api:messages:2.0:BulkRequest</li> <li>urn:ietf:params:scim:api:messages:2.0:BulkResponse</li> </ul> <p>Schemas are stateless and thread-safe. All pre-defined schemas can be imported from <code>scimpler.schemas</code>. Every of them contains all attributes specified by the protocol. Since some of the attributes are not required, and may not be supported by Service Provider, they can be excluded from the schema, so for example, they do not appear in the schema representation.</p> <pre><code>from scimpler.schemas import UserSchema, EnterpriseUserSchemaExtension\nfrom scimpler.data import AttrFilter\n\nuser_schema = UserSchema(\n    AttrFilter(\n        attr_reps=[\"name.formatted\", \"x509Certificates\"],\n        include=False,\n    )\n)\nenterprise_extension = EnterpriseUserSchemaExtension(\n    AttrFilter(\n        attr_reps=[\"manager\"],\n        include=True,\n    )\n)\nuser_schema.extend(enterprise_extension, required=True)\n</code></pre> <p>Info</p> <p>Required attributes and sub-attributes (like <code>id</code> or <code>schemas</code> in resources) are included regardless the filter.</p> <p>To define custom schema or schema extension, one must inherit from <code>scimpler.data.ResourceSchema</code> or <code>scimpler.data.SchemaExtension</code>, respectively.</p> <pre><code>from scimpler.data import String, Integer, ResourceSchema, SchemaExtension\n\n\nclass VehicleSchema(ResourceSchema):\n    schema = \"my:schema:uri:1.0:Vehicle\"\n    name = \"Vehicle\"\n    plural_name = \"Vehicles\"\n    endpoint = \"/Vehicles\"\n    base_attrs = [\n        String(\"model\", required=True, case_exact=True),\n        Integer(\"capacity\", required=True),\n    ]\n\n\nclass VehicleExtension(SchemaExtension):\n    schema = \"my:extension:schema:uri:1.0:VehicleExtension\"\n    name = \"VehicleExtension\"\n    base_attrs = [Integer(\"wheels\")]\n\n\nvehicle_schema = VehicleSchema()\nvehicle_extension = VehicleExtension()\nvehicle_schema.extend(vehicle_extension)\n</code></pre> <p><code>User</code> and <code>Group</code> resource schemas can differ more than just attribute selection in your case. You can ignore included resource schema definitions and redefine them on your own, e.g. to make some attribute required, even if it is optional as per RFC-7643.</p> <pre><code>from scimpler.data import Attribute, ResourceSchema\n\nclass UserSchema(ResourceSchema):\n    schema = \"urn:ietf:params:scim:schemas:core:2.0:User\"\n    name = \"User\"\n    plural_name = \"Users\"\n    description = \"User Account\"\n    endpoint = \"/Users\"\n    base_attrs: list[Attribute] = [...]\n</code></pre> <p>Warning</p> <p>Redefining built-in resource schema removes all validations, pre-, and post-processing,  associated with the resource type.</p> <p>Info</p> <p>All provided validators for <code>User</code> attributes can be imported from <code>scimpler.schemas.user</code>.</p> <p>Every schema provides three main functionalities: data validation, deserialization, and serialization.</p>"},{"location":"users_guide/#data-validation","title":"Data validation","text":"<p>All built-in schemas incorporate validation rules described in RFC-7643. Check SCIM compliance for details.</p> <p>Below example presents schema-level data validation.</p> <pre><code>from scimpler.schemas import UserSchema\n\nuser = UserSchema()\ndata = {\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],\n    \"username\": \"Pagerous\",\n    \"id\": 42,\n}\n\nissues = user.validate(data)\n</code></pre> <p><code>validate</code> returns <code>scimpler.error.ValidationIssues</code> always.  It contains validation errors and validation warnings. Call <code>ValidationIssues.to_dict</code> to get nice representation of all validation errors and warnings that happened during the validation.</p> <p>It is also possible to validate data for every API message schema.</p> <pre><code>from scimpler.schemas import ListResponseSchema, UserSchema, GroupSchema\n\nlist_response = ListResponseSchema(\n    resource_schemas=[UserSchema(), GroupSchema()]\n)\ndata = {\n    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:ListResponse\"],\n    \"totalResults\": 2,\n    \"startIndex\": 1,\n    \"itemsPerPage\": 2,\n    \"Resources\": [\n        {\n            \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],\n            \"username\": \"Pagerous\",\n            \"id\": 42,\n        },\n        {\n            \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\n            \"displayName\": \"scimplerUsers\",\n            \"members\": [\n                {\n                    \"value\": 42,\n                    \"type\": \"GitHubUser\",\n                }\n            ]\n        }\n    ],\n}\n\nissues = list_response.validate(data)\nprint(issues.to_dict(message=True))\n</code></pre> <p>Output <pre><code>{\n  \"Resources\": {\n    \"0\": {\n      \"id\": {\n        \"_errors\": [\n          {\n            \"code\": 2,\n            \"message\": \"bad type, expecting 'string'\"\n          }\n        ]\n      }\n    },\n    \"1\": {\n      \"id\": {\n        \"_errors\": [\n          {\n            \"code\": 5,\n            \"message\": 'missing'\n          }\n        ]\n      },\n      \"members\": {\n        \"0\": {\n          \"value\": {\n            \"_errors\": [\n              {\n                \"code\": 2,\n                \"message\": \"bad type, expecting 'string'\"\n              }\n            ]\n          },\n          \"type\": {\n            \"_errors\": [\n              {\n                \"code\": 9,\n                \"message\": \"must be one of: ['user', 'group']\"\n              }\n            ]\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre></p> <p>Info</p> <p>By default, schema-level validation is performed out of SCIM request / response context, and some rules are not checked. To enable request-specific or response-specific validation, pass presence_config parameter to <code>validate</code> method.</p> <pre><code>from scimpler.data import AttrValuePresenceConfig\nfrom scimpler.schemas import UserSchema\n\n\nuser = UserSchema()\ndata = {...}\nissues = user.validate(data, presence_config=AttrValuePresenceConfig(\"RESPONSE\"))\n</code></pre>"},{"location":"users_guide/#data-deserialization-and-serialization","title":"Data deserialization and serialization","text":"<p>To deserialize the data, call <code>deserialize</code> method on selected schema.</p> <pre><code>from scimpler.schemas import UserSchema\n\ndata = {\n    \"schemas\": [\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\n    ],\n    \"externalId\": \"1\",\n    \"userName\": \"Pagerous\",\n    \"name\": {\n        \"formatted\": \"Arkadiusz Pajor\",\n        \"familyName\": \"Pajor\",\n        \"givenName\": \"Arkadiusz\"\n    },\n    \"profileUrl\": \"https://www.linkedin.com/in/arkadiusz-pajor/\",\n    \"emails\": [\n        {\n            \"value\": \"arkadiuszpajor97@gmail.com\",\n            \"type\": \"work\",\n            \"primary\": True\n        }\n    ],\n}\nuser = UserSchema()\n\ndeserialized = user.deserialize(data)\n</code></pre> <p>Warning</p> <p>The data is not validated during serialization and deserialization. You need to call <code>validate</code> method before.</p> <p>By default, there is no additional deserialization logic, and values come out as they are passed in. SCIM-compatible data types come from JSON and do not require additional processing.</p> <p>It is possible to configure custom deserialization. First way, is to call <code>set_deserializer</code> on <code>Attribute</code> class, so all instances of the given  type are deserialized in the same way.</p> <pre><code>from datetime import datetime\nfrom scimpler.data import DateTime\n\n\nDateTime.set_deserializer(datetime.fromisoformat)\n</code></pre> <p>The other way to define custom deserialization logic is to provide <code>deserializer</code> parameter when defining the schema.</p> <pre><code>from scimpler.data import ResourceSchema, String\n\n\ndef convert_to_lower(value: str) -&gt; str:\n    return value.lower()\n\n\nclass MyOwnResource(ResourceSchema):\n    name = \"MyOwnResource\"\n    endpoint = \"/MyOwnResources\"\n    base_attrs = [\n        String(\"myString\", deserializer=convert_to_lower)\n    ]\n</code></pre> <p>Serialization process and its configuration is analogous.</p> <p>Warning</p> <p>You are responsible for making sure the object returned from a deserializer is compatible with a serializer.</p> <p>The data must be validated before the deserialization and after the serialization. Otherwise, the validation is likely to fail due to bad value types.</p>"},{"location":"users_guide/#working-with-data","title":"Working with data","text":"<p><code>scimpler</code> makes use of <code>ScimData</code>, when working with data internally, but it is also returned from <code>deserialize</code> and <code>serialize</code> schema methods. It implements <code>MutableMapping</code> protocol, so it can be used like any dictionary. What it adds is custom logic for handling provided keys and default values.</p> <p>Let us consider below data, which is exemplary user resource document: <pre><code>data = {\n    \"schemas\": [\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\n    ],\n    \"externalId\": \"1\",\n    \"userName\": \"bjensen@example.com\",\n    \"name\": {\n        \"familyName\": \"Jensen\",\n        \"givenName\": \"Barbara\",\n    },\n    \"emails\": [\n        {\"value\": \"bjensen@example.com\", \"type\": \"work\", \"primary\": True},\n        {\"value\": \"babs@jensen.org\", \"type\": \"home\"},\n    ],\n    \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        \"employeeNumber\": \"1\",\n        \"costCenter\": \"4130\",\n        \"organization\": \"Universal Studios\",\n        \"division\": \"Theme Park\",\n        \"department\": \"Tour Operations\",\n        \"manager\": {\n            \"value\": \"26118915-6090-4610-87e4-49d8ca9f808d\",\n            \"$ref\": \"../Users/26118915-6090-4610-87e4-49d8ca9f808d\",\n            \"displayName\": \"John Doe\",\n        },\n    },\n}\n</code></pre> <code>ScimData</code> can be populated with it. <pre><code>from scimpler.data import ScimData\n\nscim_data = ScimData(data)\n</code></pre></p> <p>It is possible to read the attribute in a case-insensitive way. <pre><code>&gt;&gt;&gt; scim_data[\"USERNAME\"]\n\"bjensen@example.com\"\n</code></pre></p> <p>As well as specific sub-attribute. <pre><code>&gt;&gt;&gt; scim_data[\"name.givenname\"]\n\"Barbara\"\n</code></pre></p> <p>If you read sub-attribute of multi-valued complex attribute, you get all values for that sub-attribute. <pre><code>&gt;&gt;&gt; scim_data[\"emails.value\"]\n[\"bjensen@example.com\", \"babs@jensen.org\"]\n</code></pre></p> <p>To access attribute from extension, you need to provide extension schema URI. <pre><code>&gt;&gt;&gt; scim_data[\"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:manager.displayName\"]\n\"John Doe\"\n</code></pre></p> <p>A key in <code>ScimData</code> can be an instance of <code>AttrRep</code>  and <code>BoundedAttrRep</code>, what makes it very convenient to use, when you have schema instance.</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user = UserSchema()\n&gt;&gt;&gt; scim_data[user.attrs.emails__value]\n[\"bjensen@example.com\", \"babs@jensen.org\"]\n\n&gt;&gt;&gt; scim_data[user.attrs.manager__displayName]\n\"John Doe\"\n</code></pre> <p>If the value for the specified key can not be found, the special <code>Missing</code> object is returned to indicate the client did not provide value. It is required since <code>None</code> / <code>null</code> has special semantics of clearing the present value of the attribute in service provider.</p> <p>Setting the value is similar. SCIM requires the extension data to reside in its own namespace (which is schema URI). <code>ScimData</code> does it for you. It is enough to provide simple mapping of <code>BoundedAttrRep</code> to value.</p> <p><pre><code>print(\n    ScimData(\n        {\n            user.attrs.name__formatted: \"John Doe\",\n            user.attrs.userName: \"johndoe\",\n            user.attrs.emails: [{\"value\": \"john@doe.com\"}],\n            user.attrs.employeeNumber: \"42\",\n            user.attrs.manager__displayName: \"For Sure Not John Doe\"\n        }\n    ).to_dict()\n)\n</code></pre> Output <pre><code>{\n    \"name\": {\n        \"formatted\": \"John Doe\"\n    },\n    \"userName\": \"johndoe\",\n    \"emails\": [{\"value\": \"john@doe.com\"}],\n    \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        \"employeeNumber\": \"42\",\n        \"manager\": {\n            \"displayName\": \"For Sure Not John Doe\"\n        }\n    }\n}\n</code></pre></p> <p>You can add the key and value to existing data.</p> <pre><code>scim_data.set(user.attrs.nickName, \"johny\")\n</code></pre> <p>Every schema allows you to filter the data. This kind of filtering bases on attribute properties. Not to be confused with Filtering.</p> <pre><code>from scimpler.data import AttrFilter\n\n\n# resulting data will contain only \"readOnly\" attributes\nscim_data = user.filter(\n    scim_data, AttrFilter(filter_=lambda attr: attr.mutability == \"readOnly\")\n)\n</code></pre>"},{"location":"users_guide/#filtering","title":"Filtering","text":"<p>SCIM defines complex syntax for filter definition and <code>scimpler</code> supports it. <code>Filter</code> supports validation, deserialization, and serialization. You can also pass data to the deserialized filter to check if there is match.</p> <p><pre><code>from scimpler.data import Filter\n\n\nissues = Filter.validate(\n    \"userName eq 'johndoe' or (emails[type neq 'home'] and nickName sw 15)\"\n)\nprint(issues.to_dict(message=True))\n</code></pre> <pre><code>{\n    \"_errors\": [\n        {\n            \"code\": 104,\n            \"message\": \"unknown operator 'neq' in expression 'type neq 'home''\"\n        },\n        {\n            \"code\": 110,\n            \"message\": \"operand 15 is not compatible with 'sw' operator\"\n        }\n    ]\n}\n</code></pre></p> <p>Valid filter expression can be deserialized, and later the <code>Filter</code> instance can be serialized.</p> <p><pre><code>filter_ = Filter.deserialize(\n    \"userName eq 'johndoe' or (emails[type ne 'home'] and nickName sw 'j')\"\n)\nprint(filter_.serialize())\n</code></pre> <pre><code>userName eq 'johndoe' or (emails[type ne 'home'] and nickName sw 'j')\n</code></pre></p> <p><code>Filter</code> instance can be converted to dictionary.</p> <p><pre><code>print(filter_.to_dict())\n</code></pre> <pre><code>{\n    \"op\": \"or\",\n    \"sub_ops\": [\n        {\n            \"op\": \"eq\",\n            \"attr\": \"userName\",\n            \"value\": \"johndoe\"\n        },\n        {\n            \"op\": \"and\",\n            \"sub_ops\": [\n                {\n                    \"op\": \"complex\",\n                    \"attr\": \"emails\",\n                    \"sub_op\": {\n                        \"op\": \"ne\",\n                        \"attr\": \"type\",\n                        \"value\": \"home\"\n                    }\n                }, \n                {\n                    \"op\": \"sw\",\n                    \"attr\": \"nickName\",\n                    \"value\": \"j\"\n                }\n            ]\n        }\n    ]\n}\n</code></pre></p> <p>If the data is passed to filter, the flag indicating whether there is a match is returned.</p> <pre><code>filter_(  # True\n    {\n        \"userName\": \"johndoe\",\n        \"emails\": [{\"type\": \"home\", \"value\": \"home@example.com\"}]\n        \"nickName\": \"johny\"\n    }\n)\nfilter_(  # False\n    {\n        \"userName\": \"doejohn\",\n        \"emails\": [{\"type\": \"work\", \"value\": \"work@example.com\"}]\n        \"nickName\": \"doe\"\n    }\n)\n</code></pre> <p>It is possible to define custom unary and binary operators. It is enough to inherit from <code>UnaryAttributeOperator</code> or  <code>BinaryAttributeOperator</code>. These will be automatically available and supported when parsing <code>PATCH</code> operation paths.</p> <pre><code>from scimpler.data.operator import (\n    BinaryAttributeOperator,\n    UnaryAttributeOperator,\n)\n\n\nclass Regex(BinaryAttributeOperator):\n    op = \"re\"\n    supported_scim_types = {\"string\"}\n    supported_types = {str}\n\n    @staticmethod\n    def operator(attr_value: Any, op_value: Any) -&gt; bool:\n        return bool(re.fullmatch(op_value, attr_value))\n\n\nclass IsNice(UnaryAttributeOperator):\n    op = \"isNice\"\n    supported_scim_types = {\"string\"}\n    supported_types = {str}\n\n    @staticmethod\n    def operator(value: Any) -&gt; bool:\n        return value == \"Nice\"\n</code></pre>"},{"location":"users_guide/#sorting","title":"Sorting","text":"<p>Data in <code>scimpler</code> can be sorted in a way specified in RFC-7644. Sorting is implemented by  <code>Sorter</code>. It sorts the provided data according to  the configuration and the provided schemas. It is able to perform sorting of data items that belong  to the same schema, or to different schemas (e.g. <code>UserSchema</code> and <code>GroupSchema</code>).</p> <p>Sorting is performed in line with value types semantics. For \"string\" attributes, case-sensitivity and PRECIS profile is respected.</p> <p>If the data item misses the attribute the data is sorted by, it is ordered last (if ascending sorting).</p> <p><pre><code>from scimpler.data import AttrRep, Sorter\nfrom scimpler.schemas import GroupSchema, UserSchema\n\n\ngroup, user = GroupSchema(), UserSchema()\nsorter = Sorter(attr_rep=\"externalId\", asc=True)\nprint(\n    sorter(\n        [{\"externalId\": \"2\"}, {\"externalId\": \"1\"}, {\"externalId\": \"3\"}],\n        [user, group, user],\n    )\n)\n</code></pre> <pre><code>[{\"externalId\": \"1\"}, {\"externalId\": \"2\"}, {\"externalId\": \"3\"}]\n</code></pre></p>"},{"location":"users_guide/#request-and-response-validation","title":"Request and response validation","text":"<p><code>scimpler</code> provides reach request and response validations, for every endpoint and operation defined in SCIM protocol.</p> <p>Exemplary request validation: <pre><code>from scimpler import query_string, validator\nfrom scimpler.schemas import UserSchema\n\nquery_string_handler = query_string.ResourceObjectPatch()\nval = validator.ResourceObjectPatch(resource_schema=UserSchema())\n\nrequest_query_string = {\n    \"attributes\": \"name,bad^attributeName\"\n}\nrequest_data = {\n    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\n    \"Operations\": [\n        {\n            \"op\": \"add\",\n            \"path\": \"nickName\",\n            \"value\": \"Pagerous\",\n        },\n        {\n            \"op\": \"replace\",\n            \"path\": \"emails[type eq 'home']\",\n            \"value\": 42,\n        },\n        {\n            \"op\": \"remove\",\n            \"path\": \"name.nonExisting\"\n        },\n        {\n            \"op\": \"replace\",\n            \"path\": \"ims[ty\"\n        }\n    ]\n}\n\nquery_string_issues = query_string_handler.validate(request_query_string)\nrequest_issues = val.validate_request(request_data)\n</code></pre></p> <p>Exemplary response validation (you probably want to do it in tests, not production environment): <pre><code>from scimpler.data import AttrValuePresenceConfig\nfrom scimpler.schemas import UserSchema\nfrom scimpler import validator\n\nresponse_data = {\n    \"schemas\": [\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\n    ],\n    \"id\": \"1\",\n    \"externalId\": \"1\",\n    \"userName\": \"Pagerous\",\n    \"password\": \"12345678\",\n    \"name\": {\n        \"formatted\": \"Arkadiusz Pajor\",\n        \"familyName\": \"Pajor\",\n        \"givenName\": \"Arkadiusz\"\n    },\n    \"profileUrl\": \"https://www.linkedin.com/in/arkadiusz-pajor/\",\n    \"emails\": [\n        {\n            \"value\": \"arkadiuszpajor97@gmail.com\",\n            \"type\": \"work\",\n            \"primary\": True\n        }\n    ],\n    \"meta\": {\n        \"resourceType\": \"User\",\n        \"created\": \"1997-10-17T00:00:00\",\n        \"lastModified\": \"2024-09-09T22:13:00\",\n        \"location\": \"https://example.com/v2/Users/1\",\n    }\n}\nval = validator.ResourceObjectGet(resource_schema=UserSchema())\n\nresponse_issues = val.validate_response(\n    status_code=201,\n    body=response_data,\n    presence_config=AttrValuePresenceConfig(\n        \"RESPONSE\",\n        attr_reps=[\"name.familyName\", \"emails.primary\"],\n        include=False\n    )\n)\n</code></pre></p> <p>The error handling and selection of correct error response must be done by the implementer.</p> <p>See API Reference for more information.</p>"},{"location":"users_guide/#integrations","title":"Integrations","text":""},{"location":"users_guide/#marshmallow","title":"marshmallow","text":"<p><code>scimpler</code> can be integrated with <code>marshmallow</code> for request and response validation.</p> <pre><code>from scimpler import validator\nfrom scimpler.ext.marshmallow import create_request_schema\nfrom scimpler.schemas import UserSchema\n\n\nschema_cls = create_request_schema(\n    validator.ResourceObjectPatch(resource_schema=UserSchema())\n)\nschema = schema_cls()\n\nschema.load(...)\nschema.dump(...)\n</code></pre> <p>Returned object is <code>marshmallow.Schema</code>, but internally the actual validation is done by original <code>scimpler</code> schemas.</p> <p>To create response schema, you need to also provide callable that returns <code>scimpler.ext.marshmallow.ResponseContext</code>. It is required to pass additional things needed for validation (status code, headers,  attribute value presence config, filter, sorter, etc.), because <code>validate</code>, <code>load</code>, and <code>dump</code>  do not allow to pass them directly.</p> <pre><code>from scimpler import validator\nfrom scimpler.ext.marshmallow import create_response_schema, ResponseContext\nfrom scimpler.schemas import ListResponseSchema, UserSchema\n\n\nschema_cls = create_response_schema(\n    validator.ListResponseSchema(resource_schema=UserSchema()),\n    context_provider=lambda: ResponseContext(\n        status_code=get_status_code(),\n        filter_=get_request_filter(),\n    )\n)\nschema = schema_cls()\n</code></pre> <p>All parameters required by the specific validator are listed in the corresponding API Reference.</p>"},{"location":"api_reference/scimpler_config/","title":"scimpler.config","text":""},{"location":"api_reference/scimpler_config/#scimpler.config.ServiceProviderConfig","title":"<code>ServiceProviderConfig(documentation_uri, patch, bulk, filter, change_password, sort, etag, authentication_schemes)</code>  <code>dataclass</code>","text":"<p>Service provider configuration. Available fields as defined in  RFC-7643.</p>"},{"location":"api_reference/scimpler_config/#scimpler.config.ServiceProviderConfig.create","title":"<code>create(documentation_uri='', patch=None, bulk=None, filter_=None, change_password=None, sort=None, etag=None, authentication_schemes=None)</code>  <code>classmethod</code>","text":"<p>Creates <code>ServiceProviderConfig</code> with all values defaulted, so operations are not supported by default.</p> Source code in <code>src/scimpler/config.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    documentation_uri: str = \"\",\n    patch: Optional[dict[str, Any]] = None,\n    bulk: Optional[dict[str, Any]] = None,\n    filter_: Optional[dict[str, Any]] = None,\n    change_password: Optional[dict[str, Any]] = None,\n    sort: Optional[dict[str, Any]] = None,\n    etag: Optional[dict[str, Any]] = None,\n    authentication_schemes: Optional[list[dict[str, Any]]] = None,\n):\n    \"\"\"\n    Creates `ServiceProviderConfig` with all values defaulted, so operations are not supported\n    by default.\n    \"\"\"\n    return cls(\n        documentation_uri=documentation_uri,\n        patch=_GenericOption(**(patch or {})),\n        bulk=_BulkOption(**(bulk or {})),\n        filter=_FilterOption(**(filter_ or {})),\n        change_password=_GenericOption(**(change_password or {})),\n        sort=_GenericOption(**(sort or {})),\n        etag=_GenericOption(**(etag or {})),\n        authentication_schemes=[\n            _AuthenticationScheme(**item) for item in authentication_schemes or []\n        ],\n    )\n</code></pre>"},{"location":"api_reference/scimpler_config/#scimpler.config.set_service_provider_config","title":"<code>set_service_provider_config(config)</code>","text":"<p>Sets global service provider configuration.</p> Source code in <code>src/scimpler/config.py</code> <pre><code>def set_service_provider_config(config: ServiceProviderConfig) -&gt; None:\n    \"\"\"\n    Sets global service provider configuration.\n    \"\"\"\n    global service_provider_config\n    service_provider_config = config\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_filter/","title":"AttrFilter","text":"<p>Attribute filter that filters attributes by specified attribute names and conditions.</p> PARAMETER DESCRIPTION <code>attr_reps</code> <p>Attribute representations that should be included or excluded from the provided collection. Must be specified together with <code>include</code> parameter. If the attribute is in the <code>attr_names</code>, and <code>included</code> is set to <code>True</code>, it must pass the provided <code>filter_</code> anyway, to be included in a final result. Both attributes and sub-attributes are supported.</p> <p> TYPE: <code>Optional[Iterable[Union[str, AttrRep]]]</code> DEFAULT: <code>None</code> </p> <code>include</code> <p>If set to <code>True</code>, the <code>attr_names</code> determine attribute names to be included and eventually filtered by the filter supplied as <code>filter_</code> parameter. If set to <code>False</code>, the attributes will be excluded, regardless the <code>filter_</code>.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>filter_</code> <p>Callable that takes an <code>Attribute</code> instance on input and returns the flag indicating whether the attribute passed the filter.</p> <p> TYPE: <code>Optional[Callable[[Attribute], bool]]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; attr_filter = AttrFilter(\n&gt;&gt;&gt;     attr_reps=[\"nickName\", \"name.givenName\"],\n&gt;&gt;&gt;     include=False,\n&gt;&gt;&gt;     filter_=lambda attr: attr.mutability == \"readOnly\"\n&gt;&gt;&gt;)\n&gt;&gt;&gt; filtered_attrs = attr_filter(attrs=...)\n</code></pre> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    attr_reps: Optional[Iterable[Union[str, AttrRep]]] = None,\n    include: Optional[bool] = None,\n    filter_: Optional[Callable[[\"Attribute\"], bool]] = None,\n):\n    if attr_reps and include is None:\n        raise ValueError(\"'include' must be specified if 'attr_reps' is provided\")\n\n    # stores attr names specified directly, e.g. 'emails'\n    # will be here if specified as 'emails' and not 'emails.type'\n    self._direct_top_level: set[AttrName] = set()\n\n    self._complex_sub_attrs: dict[AttrName, set[AttrName]] = defaultdict(set)\n    if attr_reps is not None:\n        for attr_rep in attr_reps:\n            if isinstance(attr_rep, str):\n                attr_rep = AttrRepFactory.deserialize(attr_rep)\n            if attr_rep.is_sub_attr:\n                self._complex_sub_attrs[attr_rep.attr].add(attr_rep.sub_attr)\n            else:\n                self._direct_top_level.add(attr_rep.attr)\n\n    self._include = include\n    self._filter = filter_\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_name/","title":"AttrName","text":"<p>               Bases: <code>str</code></p> <p>Represents unbounded attribute name. Must conform attribute name notation, as specified in RFC-7643.</p> <p>Attribute names are case-insensitive.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided value is not valid attribute name.</p>"},{"location":"api_reference/scimpler_data/attr_rep/","title":"AttrRep","text":"<p>Representation of an unbounded attribute or sub-attribute (no schema association).</p> PARAMETER DESCRIPTION <code>attr</code> <p>The attribute name.</p> <p> TYPE: <code>str</code> </p> <code>sub_attr</code> <p>The sub-attribute name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/identifiers.py</code> <pre><code>def __init__(self, attr: str, sub_attr: Optional[str] = None):\n    \"\"\"\n    Args:\n        attr: The attribute name.\n        sub_attr: The sub-attribute name.\n    \"\"\"\n    attr = AttrName(attr)\n    str_: str = attr\n    if sub_attr is not None:\n        sub_attr = AttrName(sub_attr)\n        str_ += \".\" + sub_attr\n\n    self._attr = attr\n    self._sub_attr = sub_attr\n    self._str = str_\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_rep/#scimpler.data.AttrRep-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/attr_rep/#scimpler.data.AttrRep.attr","title":"<code>attr: AttrName</code>  <code>property</code>","text":"<p>The attribute name.</p>"},{"location":"api_reference/scimpler_data/attr_rep/#scimpler.data.AttrRep.is_sub_attr","title":"<code>is_sub_attr: bool</code>  <code>property</code>","text":"<p>Flag indicating whether <code>AttrRep</code> represents sub-attribute.</p>"},{"location":"api_reference/scimpler_data/attr_rep/#scimpler.data.AttrRep.sub_attr","title":"<code>sub_attr: AttrName</code>  <code>property</code>","text":"<p>The sub-attribute name. Raises:     AttributeError: If <code>AttrRep</code> has no sub-attribute name assigned, meaning it represents         top-level attribute.</p>"},{"location":"api_reference/scimpler_data/attr_rep/#scimpler.data.AttrRep-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attr_rep_factory/","title":"AttrRepFactory","text":"<p>Attribute representation factory. Able to validate string-based representations and deserialize them to <code>AttrRep</code> or <code>BoundedAttrRep</code>.</p>"},{"location":"api_reference/scimpler_data/attr_rep_factory/#scimpler.data.AttrRepFactory-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attr_rep_factory/#scimpler.data.AttrRepFactory.deserialize","title":"<code>deserialize(value)</code>  <code>classmethod</code>","text":"<p>Deserializes the provided <code>value</code> to <code>AttrRep</code> or <code>BoundedAttrRep</code>.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to deserialize.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided <code>value</code> is not valid attribute representation.</p> RETURNS DESCRIPTION <code>Union[AttrRep, BoundedAttrRep]</code> <p>Attribute representation. The type depends on the <code>value</code> content.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; AttrRepFactory.deserialize(\"name.formatted\")\n\"AttrRep(attr='name', sub_attr='formatted')\"\n&gt;&gt;&gt; AttrRepFactory.deserialize(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:core:2.0:Group:members.type\"\n&gt;&gt;&gt; )\n\"BoundedAttrRep(\n    schema='urn:ietf:params:scim:schemas:core:2.0:Group:members.type',\n    attr='members',\n    sub_attr='type'\n)\"\n</code></pre> Source code in <code>src/scimpler/data/identifiers.py</code> <pre><code>@classmethod\ndef deserialize(cls, value: str) -&gt; Union[AttrRep, BoundedAttrRep]:\n    \"\"\"\n    Deserializes the provided `value` to `AttrRep` or `BoundedAttrRep`.\n\n    Args:\n        value: The value to deserialize.\n\n    Raises:\n        ValueError: If the provided `value` is not valid attribute representation.\n\n    Returns:\n        Attribute representation. The type depends on the `value` content.\n\n    Examples:\n        &gt;&gt;&gt; AttrRepFactory.deserialize(\"name.formatted\")\n        \"AttrRep(attr='name', sub_attr='formatted')\"\n        &gt;&gt;&gt; AttrRepFactory.deserialize(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:core:2.0:Group:members.type\"\n        &gt;&gt;&gt; )\n        \"BoundedAttrRep(\n            schema='urn:ietf:params:scim:schemas:core:2.0:Group:members.type',\n            attr='members',\n            sub_attr='type'\n        )\"\n    \"\"\"\n    try:\n        return cls._deserialize(value)\n    except Exception:\n        raise ValueError(f\"{value!r} is not valid attribute representation\")\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_rep_factory/#scimpler.data.AttrRepFactory.validate","title":"<code>validate(value)</code>  <code>classmethod</code>","text":"<p>Validates if the provided <code>value</code> is valid attribute representation and returns validation issues.</p> Source code in <code>src/scimpler/data/identifiers.py</code> <pre><code>@classmethod\ndef validate(cls, value: str) -&gt; ValidationIssues:\n    \"\"\"\n    Validates if the provided `value` is valid attribute representation and returns\n    validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    match = _ATTR_REP.fullmatch(value)\n    if match is not None:\n        schema = match.group(1)\n        schema = schema[:-1] if schema else \"\"\n        if not schema or SchemaUri(schema) in schemas:\n            return issues\n    issues.add_error(\n        issue=ValidationError.bad_attribute_name(value),\n        proceed=False,\n    )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_value_presence_config/","title":"AttrValuePresenceConfig","text":"<p>Configuration for attribute presence, according to the data flow direction, attribute properties, and specified inclusion / exclusion.</p> PARAMETER DESCRIPTION <code>direction</code> <p>The direction of the data flow, can be either \"REQUEST\" or \"RESPONSE\"</p> <p> TYPE: <code>Union[str, DataDirection]</code> </p> <code>attr_reps</code> <p>Specifies which attributes should be included or excluded from the data. The <code>include</code> parameter must be specified together.</p> <p> TYPE: <code>Optional[Collection[Union[str, AttrRep, BoundedAttrRep]]]</code> DEFAULT: <code>None</code> </p> <code>include</code> <p>If set to True, it means the attributes should be included. Excluded otherwise. Has no effect if <code>attr_reps</code> is not provided.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>ignore_issuer</code> <p>Specifies for which attributes the attribute issuer  should be ignored when making presence checks</p> <p> TYPE: <code>Optional[Collection[Union[str, AttrRep, BoundedAttrRep]]]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/attr_value_presence.py</code> <pre><code>def __init__(\n    self,\n    direction: Union[str, DataDirection],\n    attr_reps: Optional[Collection[Union[str, AttrRep, BoundedAttrRep]]] = None,\n    include: Optional[bool] = None,\n    ignore_issuer: Optional[Collection[Union[str, AttrRep, BoundedAttrRep]]] = None,\n):\n    self._direction = DataDirection(direction)\n    self._attr_reps = [\n        AttrRepFactory.deserialize(attr_rep) if isinstance(attr_rep, str) else attr_rep\n        for attr_rep in (attr_reps or [])\n    ]\n    self._include = include\n\n    if self._attr_reps and self._include is None:\n        raise ValueError(\"'include' must be specified if 'attr_reps' is specified\")\n\n    self._ignore_issuer = [\n        AttrRepFactory.deserialize(attr_rep) if isinstance(attr_rep, str) else attr_rep\n        for attr_rep in (ignore_issuer or [])\n    ]\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_value_presence_config/#scimpler.data.AttrValuePresenceConfig-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attr_value_presence_config/#scimpler.data.AttrValuePresenceConfig.allowed","title":"<code>allowed(attr_rep)</code>","text":"<p>Returns boolean indicating whether the <code>attr_rep</code> is allowed to exist whenever the presence configuration is applied, according to its <code>attr_reps</code> and <code>include</code> configuration. It considers the value existence only, without any of its possible characteristics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.data import AttrRep\n&gt;&gt;&gt;\n&gt;&gt;&gt; presence_config = AttrValuePresenceConfig(\n&gt;&gt;&gt;     \"RESPONSE\", attr_reps=[AttrRep(attr=\"name\")], include=True\n&gt;&gt;&gt; )\n&gt;&gt;&gt; presence_config.allowed(AttrRep(attr=\"name\", sub_attr=\"formatted\"))\nTrue\n&gt;&gt;&gt; presence_config.allowed(AttrRep(attr=\"userName\"))\nFalse\n</code></pre> Source code in <code>src/scimpler/data/attr_value_presence.py</code> <pre><code>def allowed(self, attr_rep: AttrRep) -&gt; bool:\n    \"\"\"\n    Returns boolean indicating whether the `attr_rep` is allowed to exist whenever the\n    presence configuration is applied, according to its `attr_reps` and `include` configuration.\n    It considers the value existence only, without any of its possible characteristics.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.data import AttrRep\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; presence_config = AttrValuePresenceConfig(\n        &gt;&gt;&gt;     \"RESPONSE\", attr_reps=[AttrRep(attr=\"name\")], include=True\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; presence_config.allowed(AttrRep(attr=\"name\", sub_attr=\"formatted\"))\n        True\n        &gt;&gt;&gt; presence_config.allowed(AttrRep(attr=\"userName\"))\n        False\n    \"\"\"\n    if self._include is None:\n        return True\n\n    is_contained = self._is_contained(attr_rep)\n    if is_contained:\n        return self._include\n\n    is_sibling_contained = self._is_sibling_contained(attr_rep)\n    is_parent_contained = self._is_parent_contained(attr_rep)\n    if is_sibling_contained and not is_parent_contained and self._include:\n        return False\n\n    if is_parent_contained:\n        return self._include\n\n    is_child_contained = self._is_child_contained(attr_rep)\n    if is_child_contained and self._include:\n        return True\n\n    return not self._include\n</code></pre>"},{"location":"api_reference/scimpler_data/attr_value_presence_config/#scimpler.data.AttrValuePresenceConfig.from_data","title":"<code>from_data(data)</code>  <code>classmethod</code>","text":"<p>Creates <code>AttrValuePresenceConfig</code> from <code>data</code>. Searches for <code>attributes</code> or <code>excludedAttributes</code> and uses their values as <code>attr_reps</code>. Direction is always <code>RESPONSE</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; presence_config = AttrValuePresenceConfig.from_data(\n&gt;&gt;&gt;     {\"excludedAttributes\": [\"userName\", \"name.formatted\"]}\n&gt;&gt;&gt; )\n&gt;&gt;&gt;\n&gt;&gt;&gt; assert presence_config.direction == \"RESPONSE\"\n&gt;&gt;&gt; assert presence_config.include is False\n&gt;&gt;&gt; assert presence_config.attr_reps == [AttrRep(\"userName\"), AttrRep(\"name.formatted\")]\n</code></pre> Source code in <code>src/scimpler/data/attr_value_presence.py</code> <pre><code>@classmethod\ndef from_data(cls, data: Mapping) -&gt; \"AttrValuePresenceConfig\":\n    \"\"\"\n    Creates `AttrValuePresenceConfig` from `data`. Searches for `attributes` or\n    `excludedAttributes` and uses their values as `attr_reps`. Direction is always `RESPONSE`.\n\n    Examples:\n        &gt;&gt;&gt; presence_config = AttrValuePresenceConfig.from_data(\n        &gt;&gt;&gt;     {\"excludedAttributes\": [\"userName\", \"name.formatted\"]}\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; assert presence_config.direction == \"RESPONSE\"\n        &gt;&gt;&gt; assert presence_config.include is False\n        &gt;&gt;&gt; assert presence_config.attr_reps == [AttrRep(\"userName\"), AttrRep(\"name.formatted\")]\n    \"\"\"\n    attr_reps = data.get(\"attributes\")\n    if attr_reps:\n        include = True\n    else:\n        attr_reps = data.get(\"excludedAttributes\")\n        include = False\n    if attr_reps:\n        return AttrValuePresenceConfig(\"RESPONSE\", attr_reps, include)\n    return AttrValuePresenceConfig(\"RESPONSE\")\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/","title":"Attribute","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all attributes.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Description of the attribute.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>issuer</code> <p>The attribute's issuer. It can be specified if attribute is issued by a service provider or provisioning client. For example, resource's <code>id</code> attribute must  be always issued by the provider, and must not be sent in POST request</p> <p> TYPE: <code>Union[str, AttributeIssuer]</code> DEFAULT: <code>NOT_SPECIFIED</code> </p> <code>required</code> <p>Specifies if attribute is required.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>multi_valued</code> <p>Specifies if attribute is multivalued.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>canonical_values</code> <p>Specifies canonical values for the attribute.</p> <p> TYPE: <code>Optional[Collection]</code> DEFAULT: <code>None</code> </p> <code>restrict_canonical_values</code> <p>Flag that indicates whether validation error should be returned if provided value is not one of canonical values. If set to <code>False</code>, the validation warning is returned instead. Has no effect if there are no canonical values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>mutability</code> <p>Specifies attribute's mutability.</p> <p> TYPE: <code>Union[str, AttributeMutability]</code> DEFAULT: <code>'readWrite'</code> </p> <code>returned</code> <p>Specifies attribute's <code>returned</code> characteristic.</p> <p> TYPE: <code>Union[str, AttributeReturn]</code> DEFAULT: <code>'default'</code> </p> <code>validators</code> <p>Additional validators, which are run, if the initial, built-in validation succeeds.</p> <p> TYPE: <code>Optional[list[_AttributeValidator]]</code> DEFAULT: <code>None</code> </p> <code>deserializer</code> <p>Routine that defines attribute's value deserialization.</p> <p> TYPE: <code>Optional[_AttributeProcessor]</code> DEFAULT: <code>None</code> </p> <code>serializer</code> <p>Routine that defines attribute's value serialization.</p> <p> TYPE: <code>Optional[_AttributeProcessor]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    description: str = \"\",\n    issuer: Union[str, AttributeIssuer] = AttributeIssuer.NOT_SPECIFIED,\n    required: bool = False,\n    multi_valued: bool = False,\n    canonical_values: Optional[Collection] = None,\n    restrict_canonical_values: bool = False,\n    mutability: Union[str, AttributeMutability] = \"readWrite\",\n    returned: Union[str, AttributeReturn] = \"default\",\n    validators: Optional[list[_AttributeValidator]] = None,\n    deserializer: Optional[_AttributeProcessor] = None,\n    serializer: Optional[_AttributeProcessor] = None,\n):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        description: Description of the attribute.\n        issuer: The attribute's issuer. It can be specified if attribute is issued by a\n            service provider or provisioning client. For example, resource's `id` attribute must\n             be always issued by the provider, and must not be sent in POST request\n        required: Specifies if attribute is required.\n        multi_valued: Specifies if attribute is multivalued.\n        canonical_values: Specifies canonical values for the attribute.\n        restrict_canonical_values: Flag that indicates whether validation error should be\n            returned if provided value is not one of canonical values. If set to `False`,\n            the validation warning is returned instead. Has no effect if there are no canonical\n            values.\n        mutability: Specifies attribute's mutability.\n        returned: Specifies attribute's `returned` characteristic.\n        validators: Additional validators, which are run, if the initial, built-in validation\n            succeeds.\n        deserializer: Routine that defines attribute's value deserialization.\n        serializer: Routine that defines attribute's value serialization.\n    \"\"\"\n    self._name = AttrName(name)\n    self._description = description\n    self._issuer = AttributeIssuer(issuer)\n    self._required = required\n    self._canonical_values = list(canonical_values or [])\n    self._validate_canonical_values = restrict_canonical_values\n    self._multi_valued = multi_valued\n    self._mutability = AttributeMutability(mutability)\n    self._returned = AttributeReturn(returned)\n    self._validators = validators or []\n    self._deserializer = deserializer\n    self._serializer = serializer\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute.\n    \"\"\"\n    output = {\n        \"name\": self._name,\n        \"type\": str(self.scim_type),\n        \"multiValued\": self._multi_valued,\n        \"description\": self.description,\n        \"required\": self.required,\n        \"mutability\": self.mutability.value,\n        \"returned\": self.returned.value,\n    }\n    if self.canonical_values:\n        output[\"canonicalValues\"] = self.canonical_values\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute/#scimpler.data.attrs.Attribute.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/","title":"AttributeWithCaseExact","text":"<p>               Bases: <code>Attribute</code>, <code>ABC</code></p> <p>Includes case sensitivity specification to the attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the attribute.</p> <p> TYPE: <code>Union[str, AttrName]</code> </p> <code>case_exact</code> <p>The sensitivity of the attribute.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: Union[str, AttrName], *, case_exact: bool = False, **kwargs: Any):\n    super().__init__(name=name, **kwargs)\n    self._case_exact = case_exact\n    if not self._case_exact and self._canonical_values:\n        self._canonical_values = [item.lower() for item in self._canonical_values]\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"caseExact\"] = self.case_exact\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_case_exact/#scimpler.data.attrs.AttributeWithCaseExact.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/","title":"AttributeWithUniqueness","text":"<p>               Bases: <code>Attribute</code>, <code>ABC</code></p> <p>Includes uniqueness specification to the attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the attribute</p> <p> TYPE: <code>Union[str, AttrName]</code> </p> <code>uniqueness</code> <p>The uniqueness of the attribute</p> <p> TYPE: <code>Union[str, AttributeUniqueness]</code> DEFAULT: <code>'none'</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: Union[str, AttrName],\n    *,\n    uniqueness: Union[str, AttributeUniqueness] = \"none\",\n    **kwargs: Any,\n):\n    super().__init__(name=name, **kwargs)\n    self._uniqueness = AttributeUniqueness(uniqueness)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.uniqueness","title":"<code>uniqueness: AttributeUniqueness</code>  <code>property</code>","text":"<p>Specifies the uniqueness of the attribute.</p>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"uniqueness\"] = self.uniqueness.value\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/attribute_with_uniqueness/#scimpler.data.attrs.AttributeWithUniqueness.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/attrs/","title":"Attrs","text":"<p>Represents iterable collection of unbounded attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; attrs = Attrs([String(\"myString\"), Integer(\"myInteger\")])\n&gt;&gt;&gt; for attr in attrs:\n&gt;&gt;&gt;     print(attr)\n</code></pre> PARAMETER DESCRIPTION <code>attrs</code> <p>The iterable producing <code>Attribute</code> objects.</p> <p> TYPE: <code>Optional[Iterable[Attribute]]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, attrs: Optional[Iterable[Attribute]] = None):\n    \"\"\"\n    Args:\n        attrs: The iterable producing `Attribute` objects.\n    \"\"\"\n    self._attrs = {attr.name: attr for attr in (attrs or [])}\n</code></pre>"},{"location":"api_reference/scimpler_data/attrs/#scimpler.data.Attrs-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/attrs/#scimpler.data.Attrs.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones <code>Attrs</code> according to a provided attribute filter. All attributes, including sub-attributes of complex attributes, are subject of filtration.</p> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter, used to determine which attributes and sub-attributes should be included in the clone</p> <p> TYPE: <code>AttrFilter</code> </p> RETURNS DESCRIPTION <code>Attrs</code> <p>Cloned <code>Attrs</code> with inner attributes, optionally filtered by <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; \"Attrs\":\n    \"\"\"\n    Clones `Attrs` according to a provided attribute filter. All attributes, including\n    sub-attributes of complex attributes, are subject of filtration.\n\n    Args:\n        attr_filter: Attribute filter, used to determine which attributes and sub-attributes\n            should be included in the clone\n\n    Returns:\n        Cloned `Attrs` with inner attributes, optionally filtered by `attr_filter`.\n    \"\"\"\n    return Attrs(attr_filter(self._attrs.values()))\n</code></pre>"},{"location":"api_reference/scimpler_data/attrs/#scimpler.data.Attrs.get","title":"<code>get(attr_name)</code>","text":"<p>Returns an attribute by its name. Since attribute names are case-insensitive, it also applies here.</p> PARAMETER DESCRIPTION <code>attr_name</code> <p>Name of the attribute to be returned. Provided value must be valid attribute name. Providing <code>AttrName</code> or <code>AttrRep</code> instance ensures syntactically correct attribute name</p> <p> TYPE: <code>Union[str, AttrRep]</code> </p> RETURNS DESCRIPTION <code>Optional[Attribute]</code> <p>Attribute, if found, None otherwise.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided attribute name is not valid.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def get(self, attr_name: Union[str, AttrRep]) -&gt; Optional[Attribute]:\n    \"\"\"\n    Returns an attribute by its name. Since attribute names are case-insensitive, it also\n    applies here.\n\n    Args:\n        attr_name: Name of the attribute to be returned. Provided value must be valid\n            attribute name. Providing `AttrName` or `AttrRep`\n            instance ensures syntactically correct attribute name\n\n    Returns:\n        Attribute, if found, None otherwise.\n\n    Raises:\n        ValueError: If the provided attribute name is not valid.\n    \"\"\"\n    if isinstance(attr_name, AttrRep):\n        attr_name = attr_name.attr\n    return self._attrs.get(AttrName(attr_name))\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/","title":"Binary","text":"<p>               Bases: <code>AttributeWithCaseExact</code></p> <p>Represents binary attribute. Binary attributes are case-sensitive, since they are represented by base64-encoded strings.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>url_safe</code> <p>Flag that makes the attribute assuming values to be url-safe</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>omit_padding</code> <p>If set on <code>True</code> validated values can have the base64-encoding padding omitted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    url_safe: bool = False,\n    omit_padding: bool = True,\n    **kwargs: Any,\n):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        url_safe: Flag that makes the attribute assuming values to be url-safe\n        omit_padding: If set on `True` validated values can have the base64-encoding\n            padding omitted.\n        **kwargs: The same keyword arguments base classes receive.\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n    self._url_safe = url_safe\n    if self._url_safe:\n        self._decoder = base64.urlsafe_b64decode\n    else:\n        self._decoder = base64.b64decode\n    self._omit_padding = omit_padding\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"caseExact\"] = self.case_exact\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/binary/#scimpler.data.Binary.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/","title":"Boolean","text":"<p>               Bases: <code>Attribute</code></p> <p>Represents boolean attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Description of the attribute.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>issuer</code> <p>The attribute's issuer. It can be specified if attribute is issued by a service provider or provisioning client. For example, resource's <code>id</code> attribute must  be always issued by the provider, and must not be sent in POST request</p> <p> TYPE: <code>Union[str, AttributeIssuer]</code> DEFAULT: <code>NOT_SPECIFIED</code> </p> <code>required</code> <p>Specifies if attribute is required.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>multi_valued</code> <p>Specifies if attribute is multivalued.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>canonical_values</code> <p>Specifies canonical values for the attribute.</p> <p> TYPE: <code>Optional[Collection]</code> DEFAULT: <code>None</code> </p> <code>restrict_canonical_values</code> <p>Flag that indicates whether validation error should be returned if provided value is not one of canonical values. If set to <code>False</code>, the validation warning is returned instead. Has no effect if there are no canonical values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>mutability</code> <p>Specifies attribute's mutability.</p> <p> TYPE: <code>Union[str, AttributeMutability]</code> DEFAULT: <code>'readWrite'</code> </p> <code>returned</code> <p>Specifies attribute's <code>returned</code> characteristic.</p> <p> TYPE: <code>Union[str, AttributeReturn]</code> DEFAULT: <code>'default'</code> </p> <code>validators</code> <p>Additional validators, which are run, if the initial, built-in validation succeeds.</p> <p> TYPE: <code>Optional[list[_AttributeValidator]]</code> DEFAULT: <code>None</code> </p> <code>deserializer</code> <p>Routine that defines attribute's value deserialization.</p> <p> TYPE: <code>Optional[_AttributeProcessor]</code> DEFAULT: <code>None</code> </p> <code>serializer</code> <p>Routine that defines attribute's value serialization.</p> <p> TYPE: <code>Optional[_AttributeProcessor]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    description: str = \"\",\n    issuer: Union[str, AttributeIssuer] = AttributeIssuer.NOT_SPECIFIED,\n    required: bool = False,\n    multi_valued: bool = False,\n    canonical_values: Optional[Collection] = None,\n    restrict_canonical_values: bool = False,\n    mutability: Union[str, AttributeMutability] = \"readWrite\",\n    returned: Union[str, AttributeReturn] = \"default\",\n    validators: Optional[list[_AttributeValidator]] = None,\n    deserializer: Optional[_AttributeProcessor] = None,\n    serializer: Optional[_AttributeProcessor] = None,\n):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        description: Description of the attribute.\n        issuer: The attribute's issuer. It can be specified if attribute is issued by a\n            service provider or provisioning client. For example, resource's `id` attribute must\n             be always issued by the provider, and must not be sent in POST request\n        required: Specifies if attribute is required.\n        multi_valued: Specifies if attribute is multivalued.\n        canonical_values: Specifies canonical values for the attribute.\n        restrict_canonical_values: Flag that indicates whether validation error should be\n            returned if provided value is not one of canonical values. If set to `False`,\n            the validation warning is returned instead. Has no effect if there are no canonical\n            values.\n        mutability: Specifies attribute's mutability.\n        returned: Specifies attribute's `returned` characteristic.\n        validators: Additional validators, which are run, if the initial, built-in validation\n            succeeds.\n        deserializer: Routine that defines attribute's value deserialization.\n        serializer: Routine that defines attribute's value serialization.\n    \"\"\"\n    self._name = AttrName(name)\n    self._description = description\n    self._issuer = AttributeIssuer(issuer)\n    self._required = required\n    self._canonical_values = list(canonical_values or [])\n    self._validate_canonical_values = restrict_canonical_values\n    self._multi_valued = multi_valued\n    self._mutability = AttributeMutability(mutability)\n    self._returned = AttributeReturn(returned)\n    self._validators = validators or []\n    self._deserializer = deserializer\n    self._serializer = serializer\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute.\n    \"\"\"\n    output = {\n        \"name\": self._name,\n        \"type\": str(self.scim_type),\n        \"multiValued\": self._multi_valued,\n        \"description\": self.description,\n        \"required\": self.required,\n        \"mutability\": self.mutability.value,\n        \"returned\": self.returned.value,\n    }\n    if self.canonical_values:\n        output[\"canonicalValues\"] = self.canonical_values\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/boolean/#scimpler.data.Boolean.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/","title":"BoundedAttrRep","text":"<p>               Bases: <code>AttrRep</code></p> <p>Representation of a bounded attribute or sub-attribute (with schema association).</p> PARAMETER DESCRIPTION <code>schema</code> <p>The schema URI to which the attribute or sub-attribute belongs.</p> <p> TYPE: <code>str</code> </p> <code>attr</code> <p>The attribute name.</p> <p> TYPE: <code>str</code> </p> <code>sub_attr</code> <p>The sub-attribute name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided <code>schema</code> is not recognized in the system registry.</p> Source code in <code>src/scimpler/data/identifiers.py</code> <pre><code>def __init__(\n    self,\n    schema: str,\n    attr: str,\n    sub_attr: Optional[str] = None,\n):\n    \"\"\"\n    Args:\n        schema: The schema URI to which the attribute or sub-attribute belongs.\n        attr: The attribute name.\n        sub_attr: The sub-attribute name.\n\n    Raises:\n        ValueError: If the provided `schema` is not recognized in the system registry.\n    \"\"\"\n    super().__init__(attr, sub_attr)\n    schema = SchemaUri(schema)\n    is_extension = schemas.get(schema)\n    if is_extension is None:\n        raise ValueError(f\"unknown schema {schema!r}\")\n\n    self._str = f\"{schema}:{self._str}\"\n    self._schema = schema\n    self._extension = is_extension\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep.attr","title":"<code>attr: AttrName</code>  <code>property</code>","text":"<p>The attribute name.</p>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep.extension","title":"<code>extension: bool</code>  <code>property</code>","text":"<p>Flag indicating whether the represented attribute or sub-attribute belongs to a schema extension.</p>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep.is_sub_attr","title":"<code>is_sub_attr: bool</code>  <code>property</code>","text":"<p>Flag indicating whether <code>AttrRep</code> represents sub-attribute.</p>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep.schema","title":"<code>schema: SchemaUri</code>  <code>property</code>","text":"<p>The schema URI to which the attribute or sub-attribute belongs.</p>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep.sub_attr","title":"<code>sub_attr: AttrName</code>  <code>property</code>","text":"<p>The sub-attribute name. Raises:     AttributeError: If <code>AttrRep</code> has no sub-attribute name assigned, meaning it represents         top-level attribute.</p>"},{"location":"api_reference/scimpler_data/bounded_attr_rep/#scimpler.data.BoundedAttrRep-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/bounded_attrs/","title":"BoundedAttrs","text":"<p>Represents iterable collection of attributes bounded to a specific schema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>A SCIM schema attributes belong to.</p> <p> TYPE: <code>SchemaUri</code> </p> <code>attrs</code> <p>Attributes bound to the schema.</p> <p> TYPE: <code>Optional[Iterable[Attribute]]</code> DEFAULT: <code>None</code> </p> <code>common_attrs</code> <p>Names of attributes that belong to the schema, but not exclusively. For example, <code>id</code>, <code>meta</code>, and <code>externalId</code> are such attributes, defined in every resource schema. Used to determine core attributes: core attrs = all attrs - common attrs.</p> <p> TYPE: <code>Optional[Iterable[str]]</code> DEFAULT: <code>None</code> </p> <p>It is possible to iterate through the attributes stored in the instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bounded_attrs = BoundedAttrs(\n&gt;&gt;&gt;     schema=SchemaUri(\"my:resource:schema\"),\n&gt;&gt;&gt;     attrs=[\n&gt;&gt;&gt;         String(\"myString\"),\n&gt;&gt;&gt;         Complex(\"myComplex\", sub_attributes=[Integer(\"myInteger\")])\n&gt;&gt;&gt;     ],\n&gt;&gt;&gt;)\n&gt;&gt;&gt;\n&gt;&gt;&gt; for attr_rep, attr in bounded_attrs:\n&gt;&gt;&gt;     print(attr_rep, attr)\n</code></pre> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    schema: SchemaUri,\n    attrs: Optional[Iterable[Attribute]] = None,\n    common_attrs: Optional[Iterable[str]] = None,\n):\n    self._schema = schema\n    self._core_attrs: dict[BoundedAttrRep, Attribute] = {}\n    self._base_attrs: dict[BoundedAttrRep, Attribute] = {}\n    self._common_attrs = {AttrName(item) for item in (common_attrs or set())}\n    self._extensions: dict[SchemaUri, BoundedAttrs] = {}\n\n    self._attrs: dict[BoundedAttrRep, Attribute] = {}\n    self._bounded_complex_sub_attrs: dict[BoundedAttrRep, dict[BoundedAttrRep, Attribute]] = (\n        defaultdict(dict)\n    )\n\n    for attr in attrs or []:\n        attr_rep = BoundedAttrRep(\n            schema=self._schema,\n            attr=attr.name,\n        )\n        self._attrs[attr_rep] = attr\n        self._base_attrs[attr_rep] = attr\n        if attr.name not in self._common_attrs:\n            self._core_attrs[attr_rep] = attr\n\n        if isinstance(attr, Complex):\n            self._bounded_complex_sub_attrs[attr_rep] = {\n                BoundedAttrRep(\n                    schema=attr_rep.schema,\n                    attr=attr_rep.attr,\n                    sub_attr=sub_attr_name,\n                ): sub_attr\n                for sub_attr_name, sub_attr in attr.attrs\n            }\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.core_attrs","title":"<code>core_attrs: Iterator[tuple[BoundedAttrRep, Attribute]]</code>  <code>property</code>","text":"<p>Iterator that goes through the core attributes of the schema.</p>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.extensions","title":"<code>extensions: dict[SchemaUri, BoundedAttrs]</code>  <code>property</code>","text":"<p>Associated extensions.</p>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Returns bounded attribute representation, given only an attribute name. Searches through attributes defined in the schema, then in the extensions. First matching result is returned, so if a schema extension defines an attribute with the same name as base schema, it is not accessible.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. A sub-attribute can be specified as well, using <code>__</code> to separate the attribute name and the sub-attribute name, for example: name__formatted</p> <p> TYPE: <code>str</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bounded_attrs = BoundedAttrs(\n&gt;&gt;&gt;     schema=SchemaUri(\"my:resource:schema\"),\n&gt;&gt;&gt;     attrs=[\n&gt;&gt;&gt;         String(\"myString\"),\n&gt;&gt;&gt;         Complex(\"myComplex\", sub_attributes=[Integer(\"myInteger\")])\n&gt;&gt;&gt;     ],\n&gt;&gt;&gt;)\n&gt;&gt;&gt;\n&gt;&gt;&gt; bounded_attrs.myString\nBoundedAttrRep(my:resource_schema:myString)\n&gt;&gt;&gt; bounded_attrs.myComplex__myInteger\nBoundedAttrRep(my:resource_schema:myComplex.myInteger)\n</code></pre> RAISES DESCRIPTION <code>AttributeError</code> <p>If bounded attribute is not found</p> <code>ValueError</code> <p>If provided attribute name is not valid</p> RETURNS DESCRIPTION <code>BoundedAttrRep</code> <p>Bounded attribute representation for the given (sub-)attribute name</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __getattr__(self, name: str) -&gt; BoundedAttrRep:\n    \"\"\"\n    Returns bounded attribute representation, given only an attribute name.\n    Searches through attributes defined in the schema, then in the extensions.\n    First matching result is returned, so if a schema extension defines an attribute\n    with the same name as base schema, it is not accessible.\n\n    Args:\n        name: Name of the attribute. A sub-attribute can be specified as well, using `__`\n            to separate the attribute name and the sub-attribute name, for example:\n            name__formatted\n\n    Examples:\n        &gt;&gt;&gt; bounded_attrs = BoundedAttrs(\n        &gt;&gt;&gt;     schema=SchemaUri(\"my:resource:schema\"),\n        &gt;&gt;&gt;     attrs=[\n        &gt;&gt;&gt;         String(\"myString\"),\n        &gt;&gt;&gt;         Complex(\"myComplex\", sub_attributes=[Integer(\"myInteger\")])\n        &gt;&gt;&gt;     ],\n        &gt;&gt;&gt;)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; bounded_attrs.myString\n        BoundedAttrRep(my:resource_schema:myString)\n        &gt;&gt;&gt; bounded_attrs.myComplex__myInteger\n        BoundedAttrRep(my:resource_schema:myComplex.myInteger)\n\n\n    Raises:\n        AttributeError: If bounded attribute is not found\n        ValueError: If provided attribute name is not valid\n\n    Returns:\n        Bounded attribute representation for the given (sub-)attribute name\n    \"\"\"\n    parts = name.split(\"__\", 1)\n    n_parts = len(parts)\n    attr_name = parts[0].lower()\n    attr_rep = BoundedAttrRep(schema=self._schema, attr=attr_name)\n    if attr := self._attrs.get(attr_rep):\n        attr_rep = BoundedAttrRep(\n            schema=self._schema,\n            attr=attr.name,\n        )\n        if n_parts == 1:\n            return attr_rep\n\n        sub_attr_rep = BoundedAttrRep(\n            schema=attr_rep.schema,\n            attr=attr_rep.attr,\n            sub_attr=parts[1],\n        )\n        if sub_attr := self._bounded_complex_sub_attrs[attr_rep].get(sub_attr_rep):\n            return BoundedAttrRep(\n                schema=attr_rep.schema,\n                attr=attr_rep.attr,\n                sub_attr=sub_attr.name,\n            )\n\n    for attrs in self._extensions.values():\n        if attr_rep_extension := getattr(attrs, name, None):\n            return attr_rep_extension\n\n    raise AttributeError(\n        f\"attribute {name.replace('__', '.')!r} \"\n        f\"does not exist within {self._schema!r} and its extensions\"\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.clone","title":"<code>clone(attr_filter, ignore_filter=None)</code>","text":"<p>Clones <code>BoundedAttrs</code> according to a provided attribute filter. All attributes, including sub-attributes of complex attributes, are subject of filtration. Extensions are filtered as well.</p> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter, used to determine which attributes and sub-attributes should be included in the clone.</p> <p> TYPE: <code>AttrFilter</code> </p> <code>ignore_filter</code> <p>Names of the common or core attributes that should be included in the clone, regardless the filter.</p> <p> TYPE: <code>Optional[Iterable[str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>BoundedAttrs</code> <p>Cloned <code>BoundedAttrs</code> with inner attributes, optionally filtered by <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def clone(\n    self, attr_filter: AttrFilter, ignore_filter: Optional[Iterable[str]] = None\n) -&gt; \"BoundedAttrs\":\n    \"\"\"\n    Clones `BoundedAttrs` according to a provided attribute filter. All attributes, including\n    sub-attributes of complex attributes, are subject of filtration. Extensions are filtered\n    as well.\n\n    Args:\n        attr_filter: Attribute filter, used to determine which attributes and sub-attributes\n            should be included in the clone.\n        ignore_filter: Names of the common or core attributes that should be included\n            in the clone, regardless the filter.\n\n    Returns:\n        Cloned `BoundedAttrs` with inner attributes, optionally filtered by `attr_filter`.\n    \"\"\"\n    filtered_attrs = attr_filter(\n        attrs=(\n            attr\n            for attr_rep, attr in self._attrs.items()\n            if attr_rep.schema not in self._extensions\n        )\n    )\n    to_include = []\n    for attr_name in ignore_filter or []:\n        for attr in filtered_attrs:\n            if attr.name == attr_name:\n                break\n        else:\n            if (BoundedAttrRep(schema=self._schema, attr=attr_name) in self._base_attrs) and (\n                attr_to_include := self.get(attr_name)\n            ) is not None:\n                to_include.append(attr_to_include)\n\n    filtered_attrs = to_include + filtered_attrs\n    cloned = BoundedAttrs(\n        schema=self._schema,\n        attrs=filtered_attrs,\n        common_attrs=self._common_attrs,\n    )\n    for schema, attrs in self._extensions.items():\n        cloned.extend(\n            schema=schema,\n            attrs=attrs.clone(attr_filter),\n        )\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.extend","title":"<code>extend(schema, attrs)</code>","text":"<p>Extends bounded attributes with provided attributes, associated with a provided schema. Args:     schema: Extension schema URI.     attrs: Extension attributes.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def extend(self, schema: SchemaUri, attrs: \"BoundedAttrs\") -&gt; None:\n    \"\"\"\n    Extends bounded attributes with provided attributes, associated with a provided schema.\n    Args:\n        schema: Extension schema URI.\n        attrs: Extension attributes.\n    \"\"\"\n    self._extensions[schema] = attrs\n    for attr_rep, attr in attrs:\n        self._attrs[attr_rep] = attr\n    self._bounded_complex_sub_attrs.update(attrs._bounded_complex_sub_attrs)\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.get","title":"<code>get(attr_rep)</code>","text":"<p>Returns an attribute, given its name or (bounded) representation. If string is provided, it must be valid attribute name. If <code>AttrRep</code> is provided (unbounded attribute representation), then the core schema and extensions are checked, and first matching result is returned.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>Representation of the attribute to be returned</p> <p> TYPE: <code>Union[str, AttrRep]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If provided attribute name is not valid</p> <p>Returns: Attribute, if found, None otherwise.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def get(self, attr_rep: Union[str, AttrRep]) -&gt; Optional[Attribute]:\n    \"\"\"\n    Returns an attribute, given its name or (bounded) representation.\n    If string is provided, it must be valid attribute name. If `AttrRep` is provided (unbounded\n    attribute representation), then the core schema and extensions are checked,\n    and first matching result is returned.\n\n    Args:\n        attr_rep: Representation of the attribute to be returned\n\n    Raises:\n        ValueError: If provided attribute name is not valid\n\n    Returns: Attribute, if found, None otherwise.\n    \"\"\"\n    if isinstance(attr_rep, str):\n        attr_rep = AttrRepFactory.deserialize(attr_rep)\n\n    if isinstance(attr_rep, BoundedAttrRep):\n        top_level_rep = BoundedAttrRep(\n            schema=attr_rep.schema,\n            attr=attr_rep.attr,\n        )\n        attr = self._attrs.get(top_level_rep)\n        if attr is None or not attr_rep.is_sub_attr:\n            return attr\n        return self._bounded_complex_sub_attrs[top_level_rep].get(attr_rep)\n\n    top_level_rep = BoundedAttrRep(\n        schema=self._schema,\n        attr=attr_rep.attr,\n    )\n    if attr := self._attrs.get(top_level_rep):\n        if not attr_rep.is_sub_attr:\n            return attr\n\n        return self._bounded_complex_sub_attrs[top_level_rep].get(\n            BoundedAttrRep(\n                schema=self._schema,\n                attr=attr_rep.attr,\n                sub_attr=attr_rep.sub_attr,\n            )\n        )\n\n    for attrs in self._extensions.values():\n        if attr := attrs.get(attr_rep):\n            return attr\n\n    return None\n</code></pre>"},{"location":"api_reference/scimpler_data/bounded_attrs/#scimpler.data.BoundedAttrs.get_by_path","title":"<code>get_by_path(path)</code>","text":"<p>Returns an attribute, given a patch path. The syntax of the path must correspond with the actual attribute. For example, patch path deserialized from <code>name[formatted eq 'John Doe']</code> would yield no results, because name is not multivalued attribute (assuming User schema).</p> PARAMETER DESCRIPTION <code>path</code> <p>path deserialized from the value, which is usually sent in resource PATCH requests</p> <p> TYPE: <code>PatchPath</code> </p> <p>Returns: Attribute, if found, None otherwise.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def get_by_path(self, path: \"PatchPath\") -&gt; Optional[Attribute]:\n    \"\"\"\n    Returns an attribute, given a patch path. The syntax of the path must correspond with the\n    actual attribute. For example, patch path deserialized from `name[formatted eq 'John Doe']`\n    would yield no results, because _name_ is not multivalued attribute (assuming User schema).\n\n    Args:\n        path: path deserialized from the value, which is usually sent in resource PATCH requests\n\n    Returns: Attribute, if found, None otherwise.\n    \"\"\"\n    attr_rep = path.attr_rep\n    attr = self.get(attr_rep)\n    if attr is None or (path.has_filter and not attr.multi_valued):\n        return None\n\n    if path.sub_attr_name is None:\n        return attr\n\n    if isinstance(attr_rep, BoundedAttrRep):\n        return self.get(\n            BoundedAttrRep(\n                schema=attr_rep.schema,\n                attr=attr_rep.attr,\n                sub_attr=path.sub_attr_name,\n            )\n        )\n    return self.get(\n        AttrRep(\n            attr=attr_rep.attr,\n            sub_attr=path.sub_attr_name,\n        )\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/","title":"Complex","text":"<p>               Bases: <code>Attribute</code></p> <p>Represents complex attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>sub_attributes</code> <p>Complex sub-attributes. All attributes but <code>Complex</code> can be sub-attributes. If not specified, and the attribute is multivalued, the default sub-attributes are used, as specified in RFC-7643, section 2.4.</p> <p> TYPE: <code>Optional[Collection[Attribute]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>The same keyword arguments the base class receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    sub_attributes: Optional[Collection[Attribute]] = None,\n    **kwargs: Any,\n):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        sub_attributes: Complex sub-attributes. All attributes but `Complex`\n            can be sub-attributes. If not specified, and the attribute is multivalued,\n            the default sub-attributes are used, as specified in\n            [RFC-7643, section 2.4](https://www.rfc-editor.org/rfc/rfc7643#section-2.4).\n        **kwargs: The same keyword arguments the base class receive.\n    \"\"\"\n    for attr in sub_attributes or []:\n        if isinstance(attr, Complex):\n            raise TypeError(\"complex attributes can not contain complex sub-attributes\")\n\n    multi_valued = kwargs.get(\"multi_valued\", False)\n    validators = kwargs.pop(\"validators\", None)\n\n    default_sub_attrs = (\n        [\n            String(\"value\"),\n            String(\n                \"display\",\n                mutability=AttributeMutability.IMMUTABLE,\n            ),\n            String(\"type\"),\n            Boolean(\"primary\"),\n            UriReference(\"$ref\"),\n        ]\n        if multi_valued\n        else []\n    )\n    self._sub_attributes = Attrs(sub_attributes or default_sub_attrs)\n    validators = list(validators or [])\n    if multi_valued:\n        if self.attrs.get(\"primary\") and _validate_single_primary_value not in validators:\n            validators.append(_validate_single_primary_value)\n        if (\n            all([self.attrs.get(\"type\"), self.attrs.get(\"value\")])\n            and _validate_type_value_pairs not in validators\n        ):\n            validators.append(_validate_type_value_pairs)\n    super().__init__(name=name, validators=validators, **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.attrs","title":"<code>attrs: Attrs</code>  <code>property</code>","text":"<p>Complex sub-attributes.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the complex attribute. All sub-attributes that do not match a provided attribute filter are not included in the clone.</p> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter, used to determine which sub-attributes should be included in the clone</p> <p> TYPE: <code>AttrFilter</code> </p> RETURNS DESCRIPTION <code>Complex</code> <p>Cloned complex attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; \"Complex\":\n    \"\"\"\n    Clones the complex attribute. All sub-attributes that do not match a provided\n    attribute filter are not included in the clone.\n\n    Args:\n        attr_filter: Attribute filter, used to determine which sub-attributes\n            should be included in the clone\n\n    Returns:\n        Cloned complex attribute\n    \"\"\"\n    cloned = copy(self)\n    cloned._sub_attributes = self._sub_attributes.clone(attr_filter)\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the data according to the provided attribute filter. All non-matching keys in the item are dropped from the result. Both single-valued and multivalued complex attribute can be filtered.</p> PARAMETER DESCRIPTION <code>data</code> <p>Input data to be filtered</p> <p> TYPE: <code>Union[MutableMapping, Iterable[MutableMapping]]</code> </p> <code>attr_filter</code> <p>Attribute filter, used to determine which sub-attributes should be dropped from a result</p> <p> TYPE: <code>AttrFilter</code> </p> RETURNS DESCRIPTION <code>Union[ScimData, list[ScimData]]</code> <p>Filtered data</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def filter(\n    self,\n    data: Union[MutableMapping, Iterable[MutableMapping]],\n    attr_filter: AttrFilter,\n) -&gt; Union[ScimData, list[ScimData]]:\n    \"\"\"\n    Filters the data according to the provided attribute filter. All non-matching keys in\n    the item are dropped from the result. Both single-valued and multivalued complex attribute\n    can be filtered.\n\n    Args:\n        data: Input data to be filtered\n        attr_filter: Attribute filter, used to determine which sub-attributes should be\n            dropped from a result\n\n    Returns:\n        Filtered data\n    \"\"\"\n    if isinstance(data, MutableMapping):\n        return self._filter(ScimData(data), attr_filter)\n    return [self._filter(ScimData(item), attr_filter) for item in data]\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"subAttributes\"] = [sub_attr.to_dict() for _, sub_attr in self.attrs]\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/complex/#scimpler.data.Complex.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/","title":"DateTime","text":"<p>               Bases: <code>Attribute</code></p> <p>Represents dateTime attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        **kwargs: The same keyword arguments base classes receive.\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute.\n    \"\"\"\n    output = {\n        \"name\": self._name,\n        \"type\": str(self.scim_type),\n        \"multiValued\": self._multi_valued,\n        \"description\": self.description,\n        \"required\": self.required,\n        \"mutability\": self.mutability.value,\n        \"returned\": self.returned.value,\n    }\n    if self.canonical_values:\n        output[\"canonicalValues\"] = self.canonical_values\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/datetime/#scimpler.data.DateTime.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/","title":"Decimal","text":"<p>               Bases: <code>AttributeWithUniqueness</code></p> <p>Represents decimal attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        **kwargs: The same keyword arguments base classes receive.\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.uniqueness","title":"<code>uniqueness: AttributeUniqueness</code>  <code>property</code>","text":"<p>Specifies the uniqueness of the attribute.</p>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"uniqueness\"] = self.uniqueness.value\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/decimal/#scimpler.data.Decimal.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/","title":"ExternalReference","text":"<p>               Bases: <code>Reference</code></p> <p>Represents external reference. Can be used to represent references to the external resources (e.g. photos).</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive, except for <code>reference_types</code>, which is set to <code>\"external\"</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        **kwargs: The same keyword arguments base classes receive, except for `reference_types`,\n            which is set to `\"external\"`.\n    \"\"\"\n    super().__init__(name=name, reference_types=[\"external\"], **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.reference_types","title":"<code>reference_types: list[str]</code>  <code>property</code>","text":"<p>Reference types, supported by the attribute.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"referenceTypes\"] = self.reference_types\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/external_reference/#scimpler.data.ExternalReference.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/","title":"Filter","text":"<p>               Bases: <code>Generic[TOperator]</code></p> <p>Data filter supporting SCIM and custom operators.</p> PARAMETER DESCRIPTION <code>operator</code> <p>Underlying filter operator, used for data filtering.</p> <p> TYPE: <code>TOperator</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; username_filter = Filter.deserialize(\"userName eq 'Pagerous'\")\n&gt;&gt;&gt; username_filter({\"userName\": \"Pagerous\"})\nTrue\n&gt;&gt;&gt; username_filter({\"userName\": \"NotPagerous\"})\nFalse\n</code></pre> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>def __init__(self, operator: TOperator):\n    self._operator = operator\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.attr_reps","title":"<code>attr_reps: list[AttrRep]</code>  <code>property</code>","text":"<p>List of bounded and unbounded attribute representations included in the filter. Useful to determine if there is enough data to use filter, since no data means no match (except for <code>not pr</code> operator).</p>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.operator","title":"<code>operator: TOperator</code>  <code>property</code>","text":"<p>Underlying filter operator, used for data filtering.</p>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.__call__","title":"<code>__call__(data, schema_or_complex)</code>","text":"<p>Matches the data against the filter.</p> PARAMETER DESCRIPTION <code>data</code> <p>Data to be matched.</p> <p> TYPE: <code>MutableMapping[str, Any]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute, which describes the provided data.</p> <p> TYPE: <code>Union[BaseSchema, Complex]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the data matches the filter.</p> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>def __call__(\n    self,\n    data: MutableMapping[str, Any],\n    schema_or_complex: Union[BaseSchema, Complex],\n) -&gt; bool:\n    \"\"\"\n    Matches the data against the filter.\n\n    Args:\n        data: Data to be matched.\n        schema_or_complex: Schema or `Complex` attribute, which describes\n            the provided data.\n\n    Returns:\n        Flag indicating whether the data matches the filter.\n    \"\"\"\n    return self._operator.match(ScimData(data), schema_or_complex)\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.deserialize","title":"<code>deserialize(filter_exp)</code>  <code>classmethod</code>","text":"<p>Deserializes the filter expression.</p> PARAMETER DESCRIPTION <code>filter_exp</code> <p>filter expression to be deserialized.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If provided filter expression is invalid.</p> RETURNS DESCRIPTION <code>Filter</code> <p>Deserialized filter.</p> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>@classmethod\ndef deserialize(cls, filter_exp: str) -&gt; \"Filter\":\n    \"\"\"\n    Deserializes the filter expression.\n\n    Args:\n        filter_exp: filter expression to be deserialized.\n\n    Raises:\n        ValueError: If provided filter expression is invalid.\n\n    Returns:\n        Deserialized filter.\n    \"\"\"\n    try:\n        return cls._deserialize(filter_exp)\n    except Exception:\n        raise ValueError(\"invalid filter expression\")\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.serialize","title":"<code>serialize()</code>","text":"<p>Serializes <code>Filter</code> to string filter expression.</p> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>def serialize(self) -&gt; str:\n    \"\"\"\n    Serializes `Filter` to string filter expression.\n    \"\"\"\n    output = self._serialize(self._operator)\n    if output.startswith(\"(\") and output.endswith(\")\"):\n        output = output[1:-1]\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the filter to a dictionary.</p> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the filter to a dictionary.\n    \"\"\"\n    return self._to_dict(self._operator)\n</code></pre>"},{"location":"api_reference/scimpler_data/filter/#scimpler.data.Filter.validate","title":"<code>validate(filter_exp)</code>  <code>classmethod</code>","text":"<p>Validates the filter expression syntax, according to RFC-7644.</p> PARAMETER DESCRIPTION <code>filter_exp</code> <p>Filter expression to validate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/filter.py</code> <pre><code>@classmethod\ndef validate(cls, filter_exp: str) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the filter expression syntax, according to RFC-7644.\n\n    Args:\n        filter_exp: Filter expression to validate.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    filter_exp, placeholders = encode_strings(filter_exp)\n    issues = Filter._validate_complex_group_operators(filter_exp, placeholders)\n\n    if not issues.can_proceed():\n        for validated in placeholders.values():\n            if isinstance(validated, _ValidatedComplexOperator):\n                issues.merge(issues=validated.issues)\n        return issues\n\n    for validated in placeholders.values():\n        if isinstance(validated, _ValidatedComplexOperator):\n            filter_exp = filter_exp.replace(validated.expression, validated.placeholder, 1)\n\n    issues.merge(Filter._validate_operator(filter_exp, placeholders))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/","title":"Integer","text":"<p>               Bases: <code>AttributeWithUniqueness</code></p> <p>Represents integer attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        **kwargs: The same keyword arguments base classes receive.\n\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.uniqueness","title":"<code>uniqueness: AttributeUniqueness</code>  <code>property</code>","text":"<p>Specifies the uniqueness of the attribute.</p>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"uniqueness\"] = self.uniqueness.value\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/integer/#scimpler.data.Integer.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/patch_path/","title":"PatchPath","text":"<p>Target modification path, used in PATCH requests. Supports path syntax, as specified in RFC-7644.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>The representation of the attribute being targeted. Must not be a sub-attribute representation.</p> <p> TYPE: <code>AttrRep</code> </p> <code>sub_attr_name</code> <p>The optional sub-attribute being targeted.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>filter_</code> <p>Value selection filter, used for multi-valued attributes. The only supported operator is <code>ComplexAttributeOperator</code>. The attribute representation specified in the filter itself must be the same as provided <code>attr_rep</code>.</p> <p> TYPE: <code>Optional[Filter[ComplexAttributeOperator]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When <code>attr_rep</code> is a sub-attribute representation.</p> <code>ValueError</code> <p>When <code>filter_</code> does not consist of <code>ComplexAttributeOperator</code>.</p> <code>ValueError</code> <p>When attribute representation specified in the filter's operator differs from the <code>attr_rep</code>.</p> Source code in <code>src/scimpler/data/patch_path.py</code> <pre><code>def __init__(\n    self,\n    attr_rep: AttrRep,\n    sub_attr_name: Optional[str] = None,\n    filter_: Optional[Filter[ComplexAttributeOperator]] = None,\n):\n    \"\"\"\n    Args:\n        attr_rep: The representation of the attribute being targeted. Must not be\n            a sub-attribute representation.\n        sub_attr_name: The optional sub-attribute being targeted.\n        filter_: Value selection filter, used for multi-valued attributes. The only supported\n            operator is `ComplexAttributeOperator`. The attribute representation specified\n            in the filter itself must be the same as provided `attr_rep`.\n\n    Raises:\n        ValueError: When `attr_rep` is a sub-attribute representation.\n        ValueError: When `filter_` does not consist of `ComplexAttributeOperator`.\n        ValueError: When attribute representation specified in the filter's operator differs\n            from the `attr_rep`.\n    \"\"\"\n    if attr_rep.is_sub_attr:\n        raise ValueError(\"'attr_rep' must not be a sub attribute\")\n\n    if filter_ is not None:\n        if not isinstance(filter_.operator, ComplexAttributeOperator):\n            raise ValueError(\"'filter_' must consist of 'ComplexAttributeOperator'\")\n\n        if filter_.operator.attr_rep != attr_rep:\n            raise ValueError(\n                f\"provided filter is configured for {filter_.operator.attr_rep!r}, \"\n                f\"but {attr_rep!r} is required\"\n            )\n\n    self._attr_rep = attr_rep\n    if sub_attr_name is not None:\n        sub_attr_name = AttrName(sub_attr_name)\n    self._sub_attr_name = sub_attr_name\n    self._filter = filter_\n</code></pre>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of the attribute being targeted.</p>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.has_filter","title":"<code>has_filter: bool</code>  <code>property</code>","text":"<p>Flag indicating whether the path contains the value selection filter.</p>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.sub_attr_name","title":"<code>sub_attr_name: Optional[AttrName]</code>  <code>property</code>","text":"<p>The sub-attribute being targeted, if any.</p>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.__call__","title":"<code>__call__(value, schema)</code>","text":"<p>Returns the flag indicating whether the provided value matches value selection filter.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test against value selection filter.</p> <p> TYPE: <code>Any</code> </p> <code>schema</code> <p>Schema that describes the provided value.</p> <p> TYPE: <code>ResourceSchema</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When provided <code>schema</code> does not define the attribute targeted by the path.</p> <code>AttributeError</code> <p>When the path does not have value selection filter.</p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the provided value matches value selection filter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; path = PatchPath.deserialize(\"emails[type eq 'work']\")\n&gt;&gt;&gt; path({\"type\": \"work\", \"display\": \"user@example.com\"}, UserSchema())\n&gt;&gt;&gt; True\n&gt;&gt;&gt; path({\"type\": \"home\", \"display\": \"user@example.com\"}, UserSchema())\n&gt;&gt;&gt; False\n</code></pre> <pre><code>&gt;&gt;&gt; path = PatchPath.deserialize(\"simpleAttr[value ge 42]\")\n&gt;&gt;&gt; path(42, ...)  # assuming '...' is schema that contains 'simpleAttr'\n&gt;&gt;&gt; True\n&gt;&gt;&gt; path(41, ...)  # assuming '...' is schema that contains 'simpleAttr'\n&gt;&gt;&gt; False\n</code></pre> Source code in <code>src/scimpler/data/patch_path.py</code> <pre><code>def __call__(self, value: Any, schema: ResourceSchema) -&gt; bool:\n    \"\"\"\n    Returns the flag indicating whether the provided value matches value selection filter.\n\n    Args:\n        value: The value to test against value selection filter.\n        schema: Schema that describes the provided value.\n\n    Raises:\n        ValueError: When provided `schema` does not define the attribute targeted by the path.\n        AttributeError: When the path does not have value selection filter.\n\n    Returns:\n        Flag indicating whether the provided value matches value selection filter.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; path = PatchPath.deserialize(\"emails[type eq 'work']\")\n        &gt;&gt;&gt; path({\"type\": \"work\", \"display\": \"user@example.com\"}, UserSchema())\n        &gt;&gt;&gt; True\n        &gt;&gt;&gt; path({\"type\": \"home\", \"display\": \"user@example.com\"}, UserSchema())\n        &gt;&gt;&gt; False\n\n        &gt;&gt;&gt; path = PatchPath.deserialize(\"simpleAttr[value ge 42]\")\n        &gt;&gt;&gt; path(42, ...)  # assuming '...' is schema that contains 'simpleAttr'\n        &gt;&gt;&gt; True\n        &gt;&gt;&gt; path(41, ...)  # assuming '...' is schema that contains 'simpleAttr'\n        &gt;&gt;&gt; False\n    \"\"\"\n    attr = schema.attrs.get(self.attr_rep)\n    if attr is None:\n        raise ValueError(f\"path does not target any attribute for {schema!r} schema\")\n\n    if self._filter is None:\n        raise AttributeError(\"path has no value selection filter\")\n\n    if isinstance(value, MutableMapping):\n        value = ScimData(value)\n\n    value = [value]\n    if isinstance(attr, Complex):\n        data = ScimData()\n        data.set(self._attr_rep, value)\n        return self._filter(data, schema)\n\n    data = ScimData({\"value\": value})\n    value_attr = copy(attr)\n    value_attr._name = AttrName(\"value\")\n    return self._filter.operator.sub_operator.match(\n        value=data,\n        schema_or_complex=Complex(\n            name=self._attr_rep.attr,\n            sub_attributes=[value_attr],\n        ),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.deserialize","title":"<code>deserialize(path_exp)</code>  <code>classmethod</code>","text":"<p>Deserializes the provided path expression into a <code>PatchPath</code>.</p> PARAMETER DESCRIPTION <code>path_exp</code> <p>Path expression to deserialize.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>When <code>path_exp</code> is not a valid path expression.</p> RETURNS DESCRIPTION <code>PatchPath</code> <p>Deserialized <code>PatchPath</code>.</p> Source code in <code>src/scimpler/data/patch_path.py</code> <pre><code>@classmethod\ndef deserialize(cls, path_exp: str) -&gt; \"PatchPath\":\n    \"\"\"\n    Deserializes the provided path expression into a `PatchPath`.\n\n    Args:\n        path_exp: Path expression to deserialize.\n\n    Raises:\n        ValueError: When `path_exp` is not a valid path expression.\n\n    Returns:\n        Deserialized `PatchPath`.\n    \"\"\"\n    try:\n        return cls._deserialize(path_exp)\n    except Exception:\n        raise ValueError(\"invalid path expression\")\n</code></pre>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.serialize","title":"<code>serialize()</code>","text":"<p>Serializes <code>PatchPath</code> to string expression.</p> Source code in <code>src/scimpler/data/patch_path.py</code> <pre><code>def serialize(self) -&gt; str:\n    \"\"\"\n    Serializes `PatchPath` to string expression.\n    \"\"\"\n    if self._filter:\n        serialized = self._filter.serialize()\n        if self.sub_attr_name:\n            serialized += f\".{self.sub_attr_name}\"\n        return serialized\n\n    if isinstance(self._attr_rep, BoundedAttrRep):\n        return str(\n            BoundedAttrRep(\n                schema=self._attr_rep.schema,\n                attr=self._attr_rep.attr,\n                sub_attr=self._sub_attr_name,\n            )\n        )\n    return str(\n        AttrRep(\n            attr=self._attr_rep.attr,\n            sub_attr=self._sub_attr_name,\n        )\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/patch_path/#scimpler.data.PatchPath.validate","title":"<code>validate(path_exp)</code>  <code>classmethod</code>","text":"<p>Validates the provided path expression, according to RFC-7644.</p> PARAMETER DESCRIPTION <code>path_exp</code> <p>Path expression to validate.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/patch_path.py</code> <pre><code>@classmethod\ndef validate(cls, path_exp: str) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided path expression, according to RFC-7644.\n\n    Args:\n        path_exp: Path expression to validate.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    path_exp, placeholders = encode_strings(path_exp)\n    if (\n        path_exp.count(\"[\") &gt; 1\n        or path_exp.count(\"]\") &gt; 1\n        or (\"[\" in path_exp and \"]\" not in path_exp)\n        or (\"]\" in path_exp and \"[\" not in path_exp)\n        or (\"[\" in path_exp and \"]\" in path_exp and path_exp.index(\"[\") &gt; path_exp.index(\"]\"))\n    ):\n        issues = ValidationIssues()\n        issues.add_error(issue=ValidationError.bad_value_syntax(), proceed=False)\n        return issues\n\n    elif \"[\" in path_exp and \"]\" in path_exp:\n        issues = cls._validate_complex_multivalued_path(path_exp, placeholders)\n    else:\n        issues = ValidationIssues()\n        path_exp = decode_placeholders(path_exp, placeholders)\n        issues.merge(AttrRepFactory.validate(path_exp))\n\n    for _, errors in issues.errors:\n        for error in errors:\n            error.scim_error = ScimErrorType.INVALID_PATH\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/","title":"ResourceSchema","text":"<p>               Bases: <code>BaseResourceSchema</code></p> <p>Base class for all user-defined resources. Attributes: <code>schemas</code>, <code>meta</code>, <code>id</code>, and <code>externalId</code> are already defined in the schema.</p> <p>To define the schema, besides <code>base_attrs</code>, one must specify <code>schema</code>, <code>name</code> and <code>endpoint</code> class attributes. Optional class attributes are <code>plural_name</code>, and <code>description</code>.</p> <p>If <code>plural_name</code> is not specified, it is defaulted to <code>name</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyResourceSchema(ResourceSchema):\n&gt;&gt;&gt;     schema = \"urn:my:resource\"\n&gt;&gt;&gt;     name = \"Resource\"\n&gt;&gt;&gt;     plural_name = \"Resources\"\n&gt;&gt;&gt;     endpoint = \"/Resources\"\n&gt;&gt;&gt;     description = \"The best resource.\"\n&gt;&gt;&gt;     base_attrs = [...]\n</code></pre> <p>The built-in validation is extended. Apart from constraints checked by the parent classes, <code>ResourceSchema</code>:</p> <ul> <li>validates the consistency od <code>meta.resourceType</code> with the configured   <code>ResourceSchema.name</code>,</li> <li>validates if <code>schemas</code> contains schema URIs for all attributes in data.</li> </ul> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter used to filter attributes defined in class-level <code>base_attrs</code> attribute. Useful for creating different schemas, e.g. with only \"readWrite\" attributes, so serialization and deserialization also filter the data.</p> <p> TYPE: <code>Optional[AttrFilter]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    \"\"\"\n    Args:\n        attr_filter: Attribute filter used to filter attributes defined in class-level\n            `base_attrs` attribute. Useful for creating different schemas, e.g. with\n            only \"readWrite\" attributes, so serialization and deserialization also\n            filter the data.\n    \"\"\"\n    register_resource_schema(self)\n    self.plural_name = getattr(self, \"plural_name\", self.name)\n    self.endpoint = self.endpoint or f\"/{self.plural_name}\"\n    self._common_attrs = [\"id\", \"externalId\", \"meta\"]\n    super().__init__(attr_filter=attr_filter, common_attrs=self._common_attrs)\n    self._schema_extensions: dict[str, dict] = {}\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.extensions","title":"<code>extensions: dict[SchemaUri, bool]</code>  <code>property</code>","text":"<p>Extensions added to the schema. Map containing schema extension URIs and flags indicating whether they are required extensions.</p>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>Schema URIs by which the schema is identified. Includes schema extension URIs.</p>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.extend","title":"<code>extend(extension, required=False)</code>","text":"<p>Extends the base schema with the provided schema <code>extension</code>. Extension attributes become part of the schema and are available in <code>ResourceSchema.attrs</code>.</p> PARAMETER DESCRIPTION <code>extension</code> <p>Schema extension which extends the base schema.</p> <p> TYPE: <code>SchemaExtension</code> </p> <code>required</code> <p>Flag indicating whether the extension is required. If the extension is required, all required fields from the extension become required in base schema during presence checks. If the extension is not required and some of its attributes are required, they are not considered required in the base schema.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def extend(self, extension: \"SchemaExtension\", required: bool = False) -&gt; None:\n    \"\"\"\n    Extends the base schema with the provided schema `extension`. Extension attributes\n    become part of the schema and are available in `ResourceSchema.attrs`.\n\n    Args:\n        extension: Schema extension which extends the base schema.\n        required: Flag indicating whether the extension is required. If the extension\n            is required, all required fields from the extension become required in base\n            schema during presence checks. If the extension is not required and some of\n            its attributes are required, they are not considered required in the base schema.\n    \"\"\"\n    if extension.schema in self.schemas:\n        raise ValueError(f\"schema {extension.schema!r} already in {self.name!r} resource\")\n    if extension.name.lower() in self._schema_extensions:\n        raise RuntimeError(f\"extension {extension.name!r} already in resource\")\n    self._schema_extensions[extension.name.lower()] = {\n        \"extension\": extension,\n        \"required\": required,\n    }\n    for attr_rep, attr in extension.attrs:\n        if (\n            self.attrs.get(BoundedAttrRep(schema=self.schema, attr=attr_rep.attr)) is not None\n            or attr_rep.attr in self._common_attrs\n        ):\n            warnings.warn(\n                message=(\n                    f\"Resource extension {extension.name!r} defines {attr_rep.attr!r} \"\n                    f\"attribute, which is also present in base {self.name!r} schema.\"\n                ),\n                category=ScimpleUserWarning,\n            )\n    self._attrs.extend(\n        schema=cast(SchemaUri, extension.schema),\n        attrs=extension.attrs,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>. The exact content of <code>schemas</code> depends on the rest of the data. If the data contains attributes from the extensions, the extension URIs appear in the attached <code>schemas</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    The exact content of `schemas` depends on the rest of the data. If the data contains\n    attributes from the extensions, the extension URIs appear in the attached `schemas`.\n    \"\"\"\n    super().include_schema_data(data)\n    scim_data = ScimData(data)\n    for extension, extension_attrs in self.attrs.extensions.items():\n        for attr_rep, _ in extension_attrs:\n            if attr_rep in scim_data:\n                data[\"schemas\"].append(str(extension))\n                break\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_data/resource_schema/#scimpler.data.ResourceSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/schema_extension/","title":"SchemaExtension","text":"<p>Base class for all user-defined schema extensions.</p> <p>To define the schema extension, besides <code>base_attrs</code>, one must specify <code>schema</code> and <code>name</code> class attributes. Optionally, <code>description</code> can be provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyResourceSchemaExtension(SchemaExtension):\n&gt;&gt;&gt;     schema = \"urn:my:resource:extension\"\n&gt;&gt;&gt;     name = \"ResourceExtension\"\n&gt;&gt;&gt;     description = \"The best resource extension.\"\n&gt;&gt;&gt;     base_attrs = [...]\n</code></pre> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    self.schema = SchemaUri(self.schema)\n    register_schema(self.schema, True)\n    self._attrs = BoundedAttrs(\n        schema=self.schema,\n        attrs=(attr_filter(self.base_attrs) if attr_filter else self.base_attrs),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_data/schema_extension/#scimpler.data.SchemaExtension-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/schema_extension/#scimpler.data.SchemaExtension.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the extension.</p>"},{"location":"api_reference/scimpler_data/schema_uri/","title":"SchemaUri","text":"<p>               Bases: <code>str</code></p> <p>Represents schema URI.</p> <p>Schema URIs are case-insensitive.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the provided value is not valid schema URI.</p>"},{"location":"api_reference/scimpler_data/scim_data/","title":"ScimData","text":"<p>               Bases: <code>MutableMapping</code></p> <p>Mapping that implements reading and updating data which is in line with SCIM requirements. Enables convenient interaction, where keys are just attribute representations, and abstracts all inner complexities.</p> <p>According to SCIM requirements, complex attributes can not contain nested complex attributes (it is general rule, but there are exceptions). It would mean the 2-level nesting should be enough (or 3, for data from extensions), but <code>ScimData</code> has no such limitation. Every nesting level has no awareness of its parent key.</p> PARAMETER DESCRIPTION <code>d</code> <p>Optional data to initialize <code>ScimData</code> with. Can be any mapping that has keys of type of <code>str</code>, <code>AttrRep</code>, or <code>BoundedAttrRep</code>. Every key with other type is ignored.</p> <p> TYPE: <code>Optional[Union[Mapping[str, Any], Mapping[AttrRep, Any], ScimData]]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ScimData({\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}).to_dict()\n{\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}\n</code></pre> <pre><code>&gt;&gt;&gt; ScimData(\n&gt;&gt;&gt;     {\n&gt;&gt;&gt;         AttrRep(attr=\"myAttr\"): \"value\",\n&gt;&gt;&gt;         AttrRep(attr=\"myOtherAttr\", sub_attr=\"mySubAttr\"): 42\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; ).to_dict()\n{\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}\n</code></pre> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user = UserSchema()\n&gt;&gt;&gt; ScimData(\n&gt;&gt;&gt;     {user.attrs.name__formatted: \"John Doe\", user.attrs.externalId: \"42\"}\n&gt;&gt;&gt; ).to_dict()\n{\"name\": {\"formatted\": \"John Doe\"}, \"externalId\": \"42\"}\n</code></pre> Source code in <code>src/scimpler/data/scim_data.py</code> <pre><code>def __init__(\n    self, d: Optional[Union[Mapping[str, Any], Mapping[AttrRep, Any], \"ScimData\"]] = None\n):\n    \"\"\"\n    Args:\n        d: Optional data to initialize `ScimData` with. Can be any mapping that has keys of\n            type of `str`, `AttrRep`, or `BoundedAttrRep`. Every key with other type is\n            ignored.\n\n    Examples:\n        &gt;&gt;&gt; ScimData({\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}).to_dict()\n        {\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}\n\n        &gt;&gt;&gt; ScimData(\n        &gt;&gt;&gt;     {\n        &gt;&gt;&gt;         AttrRep(attr=\"myAttr\"): \"value\",\n        &gt;&gt;&gt;         AttrRep(attr=\"myOtherAttr\", sub_attr=\"mySubAttr\"): 42\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; ).to_dict()\n        {\"myAttr\": \"value\", \"myOtherAttr\": {\"mySubAttr\": 42}}\n\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user = UserSchema()\n        &gt;&gt;&gt; ScimData(\n        &gt;&gt;&gt;     {user.attrs.name__formatted: \"John Doe\", user.attrs.externalId: \"42\"}\n        &gt;&gt;&gt; ).to_dict()\n        {\"name\": {\"formatted\": \"John Doe\"}, \"externalId\": \"42\"}\n    \"\"\"\n    self._data: dict[str, Any] = {}\n    self._lower_case_to_original: dict[str, str] = {}\n\n    if isinstance(d, ScimData):\n        self._data = d._data\n        self._lower_case_to_original = d._lower_case_to_original\n    elif isinstance(d, Mapping):\n        for key, value in d.items():\n            if not isinstance(key, (str, AttrRep)):\n                continue\n            self.set(key, value)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_data/#scimpler.data.ScimData-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/scim_data/#scimpler.data.ScimData.get","title":"<code>get(key, default=Missing)</code>","text":"<p>Returns the value for the specified <code>key</code>. If not found, the specified <code>default</code> is returned (<code>Missing</code> object by default).</p> <p>The type of <code>key</code> determines which entry is actually accessed: - if <code>str</code> is provided, the key is parsed to one of supported key types and used as follows, - if <code>SchemaUri</code> representing schema extension is provided, the whole subsection that     belongs to it is returned, - if <code>SchemaUri</code> representing base schema is provided, a <code>ValueError</code> exception is raised, - if <code>AttrRep</code> is provided, the retrieved value belongs to top-level attribute, or nested     one, kept under <code>AttrRep.sub_attr</code>, if <code>key</code> represents a sub-attribute, - if <code>BoundedAttrRep</code> is provided, the value is retrieved in the same way as for <code>AttrRep</code>     for attributes that belong to base schemas. For attributes from extensions,     the value is retrieved from schema URI key namespace.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> is <code>SchemaUri</code> reprensenting base schema.</p> <code>KeyError</code> <p>If trying to set sub-attribute value to existing parent that is not single-valued complex attribute value.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for which the value should be retrieved.</p> <p> TYPE: <code>Union[str, AttrRep, _SchemaKey, _AttrKey]</code> </p> <code>default</code> <p>The default value, if value for the <code>key</code> is not found.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>Missing</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = ScimData(\n&gt;&gt;&gt;     {\n&gt;&gt;&gt;         \"userName\": \"Pagerous\",\n&gt;&gt;&gt;         \"name\": {\"formatted\": \"AP\"},\n&gt;&gt;&gt;         \"emails\": [\n&gt;&gt;&gt;             {\"type\": \"work\", \"value\": \"...\"}, {\"type\": \"home\", \"value\": \"...\"}\n&gt;&gt;&gt;         ],\n&gt;&gt;&gt;         \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n&gt;&gt;&gt;             \"employeeNumber\": \"42\",\n&gt;&gt;&gt;             \"manager\": {\n&gt;&gt;&gt;                 \"displayName\": \"John Doe\"\n&gt;&gt;&gt;             }\n&gt;&gt;&gt;         }\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; )\n&gt;&gt;&gt; data.get(\"userName\")\n\"Pagerous\"\n&gt;&gt;&gt; data.get(\"name\")\n\"{\"formatted\": \"AP\"}\"\n&gt;&gt;&gt; data.get(\"name.formatted\")\n\"AP\"\n&gt;&gt;&gt; data.get(\"urn:ietf:params:scim:schemas:core:2.0:User:name.formatted\")\n\"AP\"\n&gt;&gt;&gt; data.get(\"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\")\n{\n    \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        \"employeeNumber\": \"42\"\n        \"manager\": {\n            \"displayName\": \"John Doe\"\n        }\n    }\n}\n&gt;&gt;&gt; data.get(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n&gt;&gt;&gt;     \":employeeNumber\"\n&gt;&gt;&gt; )\n\"42\"\n&gt;&gt;&gt; data.get(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n&gt;&gt;&gt;     \":manager.displayName\"\n&gt;&gt;&gt; )\n\"John Doe\"\n&gt;&gt;&gt; data.get(\"emails.type\")\n[\"work\", \"home\"]\n&gt;&gt;&gt; data.get(\"unknown\")\nMissing\n</code></pre> Source code in <code>src/scimpler/data/scim_data.py</code> <pre><code>def get(self, key: Union[str, AttrRep, _SchemaKey, _AttrKey], default: Any = Missing) -&gt; Any:\n    \"\"\"\n    Returns the value for the specified `key`. If not found, the specified `default`\n    is returned (`Missing` object by default).\n\n    The type of `key` determines which entry is actually accessed:\n    - if `str` is provided, the key is parsed to one of supported key types and used as follows,\n    - if `SchemaUri` representing schema extension is provided, the whole subsection that\n        belongs to it is returned,\n    - if `SchemaUri` representing base schema is provided, a `ValueError` exception is raised,\n    - if `AttrRep` is provided, the retrieved value belongs to top-level attribute, or nested\n        one, kept under `AttrRep.sub_attr`, if `key` represents a sub-attribute,\n    - if `BoundedAttrRep` is provided, the value is retrieved in the same way as for `AttrRep`\n        for attributes that belong to base schemas. For attributes from extensions,\n        the value is retrieved from schema URI key namespace.\n\n    Raises:\n        ValueError: If `key` is `SchemaUri` reprensenting base schema.\n        KeyError: If trying to set sub-attribute value to existing parent that is\n            not single-valued complex attribute value.\n\n    Args:\n        key: The key for which the value should be retrieved.\n        default: The default value, if value for the `key` is not found.\n\n    Examples:\n        &gt;&gt;&gt; data = ScimData(\n        &gt;&gt;&gt;     {\n        &gt;&gt;&gt;         \"userName\": \"Pagerous\",\n        &gt;&gt;&gt;         \"name\": {\"formatted\": \"AP\"},\n        &gt;&gt;&gt;         \"emails\": [\n        &gt;&gt;&gt;             {\"type\": \"work\", \"value\": \"...\"}, {\"type\": \"home\", \"value\": \"...\"}\n        &gt;&gt;&gt;         ],\n        &gt;&gt;&gt;         \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        &gt;&gt;&gt;             \"employeeNumber\": \"42\",\n        &gt;&gt;&gt;             \"manager\": {\n        &gt;&gt;&gt;                 \"displayName\": \"John Doe\"\n        &gt;&gt;&gt;             }\n        &gt;&gt;&gt;         }\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; data.get(\"userName\")\n        \"Pagerous\"\n        &gt;&gt;&gt; data.get(\"name\")\n        \"{\"formatted\": \"AP\"}\"\n        &gt;&gt;&gt; data.get(\"name.formatted\")\n        \"AP\"\n        &gt;&gt;&gt; data.get(\"urn:ietf:params:scim:schemas:core:2.0:User:name.formatted\")\n        \"AP\"\n        &gt;&gt;&gt; data.get(\"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\")\n        {\n            \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n                \"employeeNumber\": \"42\"\n                \"manager\": {\n                    \"displayName\": \"John Doe\"\n                }\n            }\n        }\n        &gt;&gt;&gt; data.get(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n        &gt;&gt;&gt;     \":employeeNumber\"\n        &gt;&gt;&gt; )\n        \"42\"\n        &gt;&gt;&gt; data.get(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n        &gt;&gt;&gt;     \":manager.displayName\"\n        &gt;&gt;&gt; )\n        \"John Doe\"\n        &gt;&gt;&gt; data.get(\"emails.type\")\n        [\"work\", \"home\"]\n        &gt;&gt;&gt; data.get(\"unknown\")\n        Missing\n    \"\"\"\n    if not isinstance(key, (_SchemaKey, _AttrKey)):\n        key = self._normalize(key)\n    if isinstance(key, _SchemaKey):\n        return self._get_extension_schema_uri(key, default)\n    if isinstance(key, _BoundedAttrKey) and key.extension:\n        return self._get_extension_attr(key, default)\n    return self._get_base_attr(key, default)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_data/#scimpler.data.ScimData.pop","title":"<code>pop(key, default=Missing)</code>","text":"<p>Pops the <code>key</code> from the data. Works similarly to <code>get</code> with the difference that after returning the value, it is not available in the data any longer.</p> Source code in <code>src/scimpler/data/scim_data.py</code> <pre><code>def pop(self, key: Union[str, AttrRep, _SchemaKey, _AttrKey], default: Any = Missing) -&gt; Any:\n    \"\"\"\n    Pops the `key` from the data. Works similarly to `get` with the difference that after\n    returning the value, it is not available in the data any longer.\n    \"\"\"\n\n    if not isinstance(key, (_SchemaKey, _AttrKey)):\n        key = self._normalize(key)\n    if isinstance(key, _SchemaKey):\n        return self._pop_extension_schema_uri(key, default)\n    elif isinstance(key, _BoundedAttrKey) and key.extension:\n        return self._pop_extension_attr(key, default)\n    return self._pop_base_attr(key, default)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_data/#scimpler.data.ScimData.set","title":"<code>set(key, value)</code>","text":"<p>Sets the entry in the mapping. Equivalent to <code>data[key] = value</code>. The way how the value is actually set depends on the type of <code>key</code>:</p> <ul> <li>if <code>str</code> is provided, the key is parsed to one of supported key types and used as follows,</li> <li>if <code>SchemaUri</code> representing schema extension is provided, the <code>value</code> is set directly     under the key,</li> <li>if <code>SchemaUri</code> representing base schema is provided, a <code>ValueError</code> exception is raised,</li> <li>if <code>AttrRep</code> is provided, the <code>value</code> is set directly under the key, if <code>key</code> represents     top-level attribute, or it is nested under <code>AttrRep.sub_attr</code>, if it represents     a sub-attribute,</li> <li>if <code>BoundedAttrRep</code> is provided, the <code>value</code> is set in the same way as for <code>AttrRep</code>     for attributes that belong to base schemas. For attributes from extensions,     the value is additionally nested in schema URI key namespace.</li> </ul> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>key</code> is <code>SchemaUri</code> reprensenting base schema.</p> <code>KeyError</code> <p>If trying to set sub-attribute value to existing parent that is not single-valued complex attribute value.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for which the <code>value</code> should be set.</p> <p> TYPE: <code>Union[str, AttrRep, _SchemaKey, _AttrKey]</code> </p> <code>value</code> <p>The value to be set.</p> <p> TYPE: <code>Any</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = ScimData()\n&gt;&gt;&gt; data.set(\"userName\", \"johndoe\")\n&gt;&gt;&gt; data.to_dict()\n{\"userName\": \"johndoe\"}\n</code></pre> <pre><code>&gt;&gt;&gt; data = ScimData()\n&gt;&gt;&gt; data.set(\"name.formatted\", \"John Doe\")\n&gt;&gt;&gt; data.to_dict()\n{\"name\": {\"formatted\": \"John Doe\"}}\n</code></pre> <pre><code>&gt;&gt;&gt; data = ScimData()\n&gt;&gt;&gt; data.set(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:core:2.0:User:name.formatted\", \"John Doe\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; data.to_dict()\n{\"name\": {\"formatted\": \"John Doe\"}}\n</code></pre> <pre><code>&gt;&gt;&gt; data = ScimData()\n&gt;&gt;&gt; data.set(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\n&gt;&gt;&gt;     {\n&gt;&gt;&gt;         \"employeeNumber\": \"42\",\n&gt;&gt;&gt;         \"manager\": {\"displayName\": \"John Doe\"}\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; )\n&gt;&gt;&gt; data.to_dict()\n{\n    \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        \"employeeNumber\": \"42\"\n        \"manager\": {\n            \"displayName\": \"John Doe\"\n        }\n    }\n}\n</code></pre> <pre><code>&gt;&gt;&gt; data = ScimData()\n&gt;&gt;&gt; data.set(\n&gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n&gt;&gt;&gt;     \":manager.value\",\n&gt;&gt;&gt;     \"10\",\n&gt;&gt;&gt; )\n&gt;&gt;&gt; data.to_dict()\n{\n    \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n        \"manager\": {\n            \"value\": \"10\"\n        }\n    }\n}\n</code></pre> Source code in <code>src/scimpler/data/scim_data.py</code> <pre><code>def set(\n    self,\n    key: Union[str, AttrRep, _SchemaKey, _AttrKey],\n    value: Any,\n) -&gt; None:\n    \"\"\"\n    Sets the entry in the mapping. Equivalent to `data[key] = value`. The way how the\n    value is actually set depends on the type of `key`:\n\n    - if `str` is provided, the key is parsed to one of supported key types and used as follows,\n    - if `SchemaUri` representing schema extension is provided, the `value` is set directly\n        under the key,\n    - if `SchemaUri` representing base schema is provided, a `ValueError` exception is raised,\n    - if `AttrRep` is provided, the `value` is set directly under the key, if `key` represents\n        top-level attribute, or it is nested under `AttrRep.sub_attr`, if it represents\n        a sub-attribute,\n    - if `BoundedAttrRep` is provided, the `value` is set in the same way as for `AttrRep`\n        for attributes that belong to base schemas. For attributes from extensions,\n        the value is additionally nested in schema URI key namespace.\n\n\n    Raises:\n        ValueError: If `key` is `SchemaUri` reprensenting base schema.\n        KeyError: If trying to set sub-attribute value to existing parent that is\n            not single-valued complex attribute value.\n\n    Args:\n        key: The key for which the `value` should be set.\n        value: The value to be set.\n\n    Examples:\n        &gt;&gt;&gt; data = ScimData()\n        &gt;&gt;&gt; data.set(\"userName\", \"johndoe\")\n        &gt;&gt;&gt; data.to_dict()\n        {\"userName\": \"johndoe\"}\n\n        &gt;&gt;&gt; data = ScimData()\n        &gt;&gt;&gt; data.set(\"name.formatted\", \"John Doe\")\n        &gt;&gt;&gt; data.to_dict()\n        {\"name\": {\"formatted\": \"John Doe\"}}\n\n        &gt;&gt;&gt; data = ScimData()\n        &gt;&gt;&gt; data.set(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:core:2.0:User:name.formatted\", \"John Doe\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; data.to_dict()\n        {\"name\": {\"formatted\": \"John Doe\"}}\n\n        &gt;&gt;&gt; data = ScimData()\n        &gt;&gt;&gt; data.set(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\n        &gt;&gt;&gt;     {\n        &gt;&gt;&gt;         \"employeeNumber\": \"42\",\n        &gt;&gt;&gt;         \"manager\": {\"displayName\": \"John Doe\"}\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; data.to_dict()\n        {\n            \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n                \"employeeNumber\": \"42\"\n                \"manager\": {\n                    \"displayName\": \"John Doe\"\n                }\n            }\n        }\n\n        &gt;&gt;&gt; data = ScimData()\n        &gt;&gt;&gt; data.set(\n        &gt;&gt;&gt;     \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\"\n        &gt;&gt;&gt;     \":manager.value\",\n        &gt;&gt;&gt;     \"10\",\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; data.to_dict()\n        {\n            \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\": {\n                \"manager\": {\n                    \"value\": \"10\"\n                }\n            }\n        }\n    \"\"\"\n    if isinstance(value, Mapping):\n        value = ScimData(value)\n    elif not isinstance(value, str) and isinstance(value, Iterable):\n        value = [ScimData(item) if isinstance(item, Mapping) else item for item in value]\n\n    if not isinstance(key, (_SchemaKey, _AttrKey)):\n        key = self._normalize(key)\n    if isinstance(key, _SchemaKey):\n        self._set_extension_schema_uri(key, value)\n        return\n    if isinstance(key, _BoundedAttrKey) and key.extension:\n        self._set_extension_attr(key, value)\n        return\n    self._set_base_attr(key, value)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_data/#scimpler.data.ScimData.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the <code>ScimData</code> to ordinary dictionary.</p> Source code in <code>src/scimpler/data/scim_data.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Converts the `ScimData` to ordinary dictionary.\n    \"\"\"\n    output: dict[str, Any] = {}\n    for key, value in self._data.items():\n        if isinstance(value, ScimData):\n            output[str(key)] = value.to_dict()\n        elif isinstance(value, list):\n            value_output = []\n            for item in value:\n                if isinstance(item, ScimData):\n                    value_output.append(item.to_dict())\n                else:\n                    value_output.append(item)\n            output[str(key)] = value_output\n        else:\n            output[str(key)] = value\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/","title":"ScimReference","text":"<p>               Bases: <code>Reference</code></p> <p>Represents SCIM reference.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>reference_types</code> <p>Specifies types of SCIM references accepted by the attribute.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, *, reference_types: Iterable[str], **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        reference_types: Specifies types of SCIM references accepted by the attribute.\n        **kwargs: The same keyword arguments base classes receive.\n    \"\"\"\n    super().__init__(name=name, reference_types=reference_types, **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.reference_types","title":"<code>reference_types: list[str]</code>  <code>property</code>","text":"<p>Reference types, supported by the attribute.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"referenceTypes\"] = self.reference_types\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/scim_reference/#scimpler.data.ScimReference.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/sorter/","title":"Sorter","text":"<p>Sorter implementing sorting logic, as specified in RFC-7644.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>The representation of the attribute by which the data should be sorted.</p> <p> TYPE: <code>Union[str, AttrRep]</code> </p> <code>asc</code> <p>If set to <code>True</code>, it enables ascending sorting. Descending otherwise.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/scimpler/data/sorter.py</code> <pre><code>def __init__(self, attr_rep: Union[str, AttrRep], asc: bool = True):\n    \"\"\"\n    Args:\n        attr_rep: The representation of the attribute by which the data should be sorted.\n        asc: If set to `True`, it enables ascending sorting. Descending otherwise.\n    \"\"\"\n    self._attr_rep = (\n        attr_rep if isinstance(attr_rep, AttrRep) else AttrRepFactory.deserialize(attr_rep)\n    )\n    self._asc = asc\n    self._default_value = AlwaysLastKey()\n</code></pre>"},{"location":"api_reference/scimpler_data/sorter/#scimpler.data.Sorter-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/sorter/#scimpler.data.Sorter.asc","title":"<code>asc: bool</code>  <code>property</code>","text":"<p>If <code>True</code>, ascending sorting is enabled. Descending otherwise.</p>"},{"location":"api_reference/scimpler_data/sorter/#scimpler.data.Sorter.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of the attribute by which the data should be sorted.</p>"},{"location":"api_reference/scimpler_data/sorter/#scimpler.data.Sorter-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/sorter/#scimpler.data.Sorter.__call__","title":"<code>__call__(data, schema)</code>","text":"<p>Sorts the provided data according to the sorter configuration and the provided schemas. It is able to perform sorting of data items that belong to the same schema, or to different schemas (e.g. <code>UserSchema</code> and <code>GroupSchema</code>).</p> <p>Sorting is performed in line with value types semantics. For \"string\" attributes, case-sensitivity and PRECIS profile is respected.</p> <p>If the data item misses the attribute the data is sorted by, it is ordered last (if ascending sorting).</p> <p>A multi-valued complex attribute is sorted by the value of \"primary\" item, if it defines <code>value</code> and <code>primary</code> attribtues. If <code>primary</code> is not defined, or it is not contained in the data, the first <code>value</code> is used for sorting.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to sort.</p> <p> TYPE: <code>Iterable[MutableMapping]</code> </p> <code>schema</code> <p>Schema or schemas that describe the data. If single schema is passed, it is assumed all data described by the same schema. If passed multiple schemas, for every data item must be provided corresponding schema.</p> <p> TYPE: <code>Union[BaseResourceSchema, Sequence[BaseResourceSchema]]</code> </p> RETURNS DESCRIPTION <code>list[ScimData]</code> <p>Sorted data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt; from scimpler.data.identifiers import AttrRep\n&gt;&gt;&gt;\n&gt;&gt;&gt; sorter = Sorter(attr_rep=AttrRep(\"userName\"), asc=False)\n&gt;&gt;&gt; sorter(\n&gt;&gt;&gt;     [{\"userName\": \"a_user\"}, {\"userName\": \"b_user\"}], UserSchema()\n&gt;&gt;&gt; )\n&gt;&gt;&gt; [{\"userName\": \"b_user\"}, {\"userName\": \"a_user\"}]\n</code></pre> <pre><code>&gt;&gt;&gt; from scimpler.schemas import GroupSchema, UserSchema\n&gt;&gt;&gt; from scimpler.data.identifiers import AttrRep\n&gt;&gt;&gt;\n&gt;&gt;&gt; group, user = GroupSchema(), UserSchema()\n&gt;&gt;&gt; sorter = Sorter(attr_rep=AttrRep(\"externalId\"), asc=True)\n&gt;&gt;&gt; sorter(\n&gt;&gt;&gt;     [{\"externalId\": \"2\"}, {\"externalId\": \"1\"}, {\"externalId\": \"3\"}],\n&gt;&gt;&gt;     [user, group, user],\n&gt;&gt;&gt; )\n&gt;&gt;&gt; [{\"externalId\": \"1\"}, {\"externalId\": \"2\"}, {\"externalId\": \"3\"}]\n</code></pre> Source code in <code>src/scimpler/data/sorter.py</code> <pre><code>def __call__(\n    self,\n    data: Iterable[MutableMapping],\n    schema: Union[BaseResourceSchema, Sequence[BaseResourceSchema]],\n) -&gt; list[ScimData]:\n    \"\"\"\n    Sorts the provided data according to the sorter configuration and the provided schemas.\n    It is able to perform sorting of data items that belong to the same schema, or to different\n    schemas (e.g. `UserSchema` and `GroupSchema`).\n\n    Sorting is performed in line with value types semantics. For \"string\" attributes,\n    case-sensitivity and PRECIS profile is respected.\n\n    If the data item misses the attribute the data is sorted by, it is ordered last\n    (if ascending sorting).\n\n    A multi-valued complex attribute is sorted by the value of \"primary\" item, if it defines\n    `value` and `primary` attribtues. If `primary` is not defined, or it is not contained in\n    the data, the first `value` is used for sorting.\n\n    Args:\n        data: The data to sort.\n        schema: Schema or schemas that describe the data. If single schema is passed, it is\n            assumed all data described by the same schema. If passed multiple schemas,\n            for every data item must be provided corresponding schema.\n\n    Returns:\n        Sorted data.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt; from scimpler.data.identifiers import AttrRep\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; sorter = Sorter(attr_rep=AttrRep(\"userName\"), asc=False)\n        &gt;&gt;&gt; sorter(\n        &gt;&gt;&gt;     [{\"userName\": \"a_user\"}, {\"userName\": \"b_user\"}], UserSchema()\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; [{\"userName\": \"b_user\"}, {\"userName\": \"a_user\"}]\n\n        &gt;&gt;&gt; from scimpler.schemas import GroupSchema, UserSchema\n        &gt;&gt;&gt; from scimpler.data.identifiers import AttrRep\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; group, user = GroupSchema(), UserSchema()\n        &gt;&gt;&gt; sorter = Sorter(attr_rep=AttrRep(\"externalId\"), asc=True)\n        &gt;&gt;&gt; sorter(\n        &gt;&gt;&gt;     [{\"externalId\": \"2\"}, {\"externalId\": \"1\"}, {\"externalId\": \"3\"}],\n        &gt;&gt;&gt;     [user, group, user],\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; [{\"externalId\": \"1\"}, {\"externalId\": \"2\"}, {\"externalId\": \"3\"}]\n\n    \"\"\"\n    normalized = [ScimData(item) for item in data]\n    if not normalized:\n        return normalized\n    return self._sort(normalized, schema)\n</code></pre>"},{"location":"api_reference/scimpler_data/string/","title":"String","text":"<p>               Bases: <code>AttributeWithCaseExact</code>, <code>AttributeWithUniqueness</code></p> <p>Represents string attribute.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>precis</code> <p>PRECIS profile that should be applied for the string attribute, when comparing values. By default, OpaqueString profile is used</p> <p> TYPE: <code>Profile</code> DEFAULT: <code>get_profile('OpaqueString')</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    precis: precis_i18n.profile.Profile = get_profile(\"OpaqueString\"),\n    **kwargs: Any,\n):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        precis: PRECIS profile that should be applied for the string attribute, when\n            comparing values. By default, **OpaqueString** profile is used\n        **kwargs: The same keyword arguments base classes receive.\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n    self._precis = precis\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.precis","title":"<code>precis: precis_i18n.profile.Profile</code>  <code>property</code>","text":"<p>Returns PRECIS profile of the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.uniqueness","title":"<code>uniqueness: AttributeUniqueness</code>  <code>property</code>","text":"<p>Specifies the uniqueness of the attribute.</p>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"caseExact\"] = self.case_exact\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/string/#scimpler.data.String.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/","title":"UriReference","text":"<p>               Bases: <code>Reference</code></p> <p>Represents URI reference.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the attribute. Must be valid attribute name.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>The same keyword arguments base classes receive, except for <code>reference_types</code>, which is set to <code>\"uri\"</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any):\n    \"\"\"\n    Args:\n        name: Name of the attribute. Must be valid attribute name.\n        **kwargs: The same keyword arguments base classes receive, except for `reference_types`,\n            which is set to `\"uri\"`.\n    \"\"\"\n    super().__init__(name=name, reference_types=[\"uri\"], **kwargs)\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.canonical_values","title":"<code>canonical_values: list</code>  <code>property</code>","text":"<p>Specifies canonical values for the attribute.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.case_exact","title":"<code>case_exact: bool</code>  <code>property</code>","text":"<p>Specifies the sensitivity of the attribute.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.custom_validators","title":"<code>custom_validators: list[_AttributeValidator]</code>  <code>property</code>","text":"<p>List of custom validators of the attribute, ran if built-in validation succeeds.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.description","title":"<code>description: str</code>  <code>property</code>","text":"<p>Description of the attribute.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.has_custom_processing","title":"<code>has_custom_processing: bool</code>  <code>property</code>","text":"<p>Indicates whether the attribute has custom deserializer or serializer specified (global deserializer and serializer that are set on class level are not considered).</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.issuer","title":"<code>issuer: AttributeIssuer</code>  <code>property</code>","text":"<p>Attribute's issuer.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.multi_valued","title":"<code>multi_valued: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is multivalued.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.mutability","title":"<code>mutability: AttributeMutability</code>  <code>property</code>","text":"<p>Specifies attribute's mutability.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.name","title":"<code>name: AttrName</code>  <code>property</code>","text":"<p>Name of the attribute.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.reference_types","title":"<code>reference_types: list[str]</code>  <code>property</code>","text":"<p>Reference types, supported by the attribute.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.required","title":"<code>required: bool</code>  <code>property</code>","text":"<p>Specifies if attribute is required.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.returned","title":"<code>returned: AttributeReturn</code>  <code>property</code>","text":"<p>Specifies attribute's <code>returned</code> characteristic.</p>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.deserialize","title":"<code>deserialize(value)</code>","text":"<p>Deserializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def deserialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Deserializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._deserializer is not None:\n        return self._deserializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._deserialize(item) for item in value]\n    return self._deserialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.serialize","title":"<code>serialize(value)</code>","text":"<p>Serializes the provided value according to attribute's specification and returns it.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def serialize(self, value: Any) -&gt; Any:\n    \"\"\"\n    Serializes the provided value according to attribute's specification and returns it.\n    \"\"\"\n    if self._serializer is not None:\n        return self._serializer(value)\n\n    if self.multi_valued and isinstance(value, list):\n        return [self._serialize(item) for item in value]\n    return self._serialize(value)\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.set_deserializer","title":"<code>set_deserializer(deserializer)</code>  <code>classmethod</code>","text":"<p>Sets global deserializer for all attributes of the specific type. Can be overridden by a routine passed as <code>deserializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_deserializer(cls, deserializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global deserializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `deserializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_deserializer = staticmethod(deserializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.set_serializer","title":"<code>set_serializer(serializer)</code>  <code>classmethod</code>","text":"<p>Sets global serializer for all attributes of the specific type. Can be overridden by a routine passed as <code>serializer</code> parameter in initializer.</p> <p>Has no effect if an instance of <code>Attribute</code> has serializer or deserializer defined.</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>@classmethod\ndef set_serializer(cls, serializer: Callable[[Any], Any]):\n    \"\"\"\n    Sets global serializer for all attributes of the specific type.\n    Can be overridden by a routine passed as `serializer` parameter in initializer.\n\n    Has no effect if an instance of `Attribute` has serializer or deserializer defined.\n    \"\"\"\n    cls._global_serializer = staticmethod(serializer)\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the attribute to a dictionary. The contents meet the requirements of the schema definition.</p> RETURNS DESCRIPTION <code>dict</code> <p>Representation of the attribute</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute to a dictionary. The contents meet the requirements\n    of the schema definition.\n\n    Returns:\n        Representation of the attribute\n    \"\"\"\n    output = super().to_dict()\n    output[\"referenceTypes\"] = self.reference_types\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_data/uri_reference/#scimpler.data.UriReference.validate","title":"<code>validate(value)</code>","text":"<p>Validates the provided value according to attribute's specification. It validates the type and canonicality (if specified). If no validation issues, custom validators (passed as <code>validators</code> constructor parameter) are run.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues</p> Source code in <code>src/scimpler/data/attrs.py</code> <pre><code>def validate(self, value: Any) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided value according to attribute's specification.\n    It validates the type and canonicality (if specified). If no validation issues,\n    custom validators (passed as `validators` constructor parameter) are run.\n\n    Returns:\n        Validation issues\n    \"\"\"\n    issues = ValidationIssues()\n    if value in [None, Missing]:\n        return issues\n\n    issues.merge(self._validate_type(value))\n    if not issues.can_proceed():\n        return issues\n\n    if self._multi_valued:\n        for i, item in enumerate(value):\n            if item is Invalid:\n                continue\n            issues_ = self._validate(item)\n            issues.merge(issues=issues_, location=[i])\n            if not issues_.can_proceed():\n                value[i] = Invalid\n    else:\n        issues.merge(self._validate(value))\n    for validator in self._validators:\n        if not issues.can_proceed():\n            break\n        issues.merge(validator(value))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/and/","title":"And","text":"<p>               Bases: <code>LogicalOperator</code></p> <p>Represents <code>and</code> SCIM operator. Matches if all sub-operators match.</p> PARAMETER DESCRIPTION <code>*sub_operators</code> <p>Sub-operators which are evaluated separately.</p> <p> TYPE: <code>Operator</code> DEFAULT: <code>()</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, *sub_operators: Operator):\n    \"\"\"\n    Args:\n        *sub_operators: Sub-operators which are evaluated separately.\n    \"\"\"\n    self._sub_operators = list(sub_operators)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/and/#scimpler.data.operator.And.sub_operators","title":"<code>sub_operators: list[Operator]</code>  <code>property</code>","text":"<p>Sub-operators contained inside the operator.</p>"},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/","title":"BinaryAttributeOperator","text":"<p>               Bases: <code>AttributeOperator</code>, <code>ABC</code></p> <p>Base class for all binary operators. Every subclass which is not an abstract must specify <code>op</code>, <code>supported_scim_types</code>, and <code>supported_types</code> class attributes.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/binary_attribute_operator/#scimpler.data.operator.BinaryAttributeOperator.operator","title":"<code>operator(attr_value, op_value)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\n@abc.abstractmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/","title":"ComplexAttributeOperator","text":"<p>               Bases: <code>Operator</code>, <code>Generic[TLogicalOrAttributeOperator]</code></p> <p>Represents complex attribute grouping operator. Can be used for single-valued and multi-valued complex attributes.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of a complex attribute which value should be matched.</p> <p> TYPE: <code>AttrRep</code> </p> <code>sub_operator</code> <p>A sub-operator used to test complex attribute's sub-attribute values.</p> <p> TYPE: <code>TLogicalOrAttributeOperator</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(\n    self,\n    attr_rep: AttrRep,\n    sub_operator: TLogicalOrAttributeOperator,\n):\n    self._attr_rep = attr_rep\n    self._sub_operator = sub_operator\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/#scimpler.data.operator.ComplexAttributeOperator-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/#scimpler.data.operator.ComplexAttributeOperator.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of the complex attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/#scimpler.data.operator.ComplexAttributeOperator.sub_operator","title":"<code>sub_operator: TLogicalOrAttributeOperator</code>  <code>property</code>","text":"<p>The sub-operator used to test complex attribute's sub-attribute values.</p>"},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/#scimpler.data.operator.ComplexAttributeOperator-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/complex_attribute_operator/#scimpler.data.operator.ComplexAttributeOperator.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self._attr_rep)\n    if attr is None or not value or not isinstance(attr, Complex):\n        return False\n\n    attr_value = value.get(self._attr_rep)\n    if (\n        attr.multi_valued\n        and not isinstance(attr_value, list)\n        or not attr.multi_valued\n        and isinstance(attr_value, list)\n    ):\n        return False\n\n    normalized = self._normalize(attr, attr_value)\n    for item in normalized:\n        match = self._sub_operator.match(item, attr)\n        if match:\n            return True\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/contains/","title":"Contains","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>co</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/contains/#scimpler.data.operator.Contains.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.contains(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/ends_with/","title":"EndsWith","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>ew</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/ends_with/#scimpler.data.operator.EndsWith.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return attr_value.endswith(op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/equal/","title":"Equal","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>eq</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/equal/#scimpler.data.operator.Equal.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.eq(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than/","title":"GreaterThan","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>gt</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than/#scimpler.data.operator.GreaterThan.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.gt(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/","title":"GreaterThanOrEqual","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>ge</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/greater_than_or_equal/#scimpler.data.operator.GreaterThanOrEqual.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.ge(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than/","title":"LesserThan","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>lt</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than/#scimpler.data.operator.LesserThan.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.lt(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/","title":"LesserThanOrEqual","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>le</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/lesser_than_or_equal/#scimpler.data.operator.LesserThanOrEqual.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.le(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/not/","title":"Not","text":"<p>               Bases: <code>LogicalOperator</code></p> <p>Represents <code>not</code> SCIM operator. Matches if a sub-operator does not match.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, sub_operator: Operator):\n    super().__init__(sub_operator)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/not/#scimpler.data.operator.Not-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/not/#scimpler.data.operator.Not.sub_operators","title":"<code>sub_operators: list[Operator]</code>  <code>property</code>","text":"<p>Sub-operators contained inside the operator.</p>"},{"location":"api_reference/scimpler_data_operator/not_equal/","title":"NotEqual","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>ne</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/not_equal/#scimpler.data.operator.NotEqual.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return operator.ne(attr_value, op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/or/","title":"Or","text":"<p>               Bases: <code>LogicalOperator</code></p> <p>Represents <code>or</code> SCIM operator. Matches if any of sub-operators match.</p> PARAMETER DESCRIPTION <code>*sub_operators</code> <p>Sub-operators which are evaluated separately.</p> <p> TYPE: <code>Operator</code> DEFAULT: <code>()</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, *sub_operators: Operator):\n    \"\"\"\n    Args:\n        *sub_operators: Sub-operators which are evaluated separately.\n    \"\"\"\n    self._sub_operators = list(sub_operators)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/or/#scimpler.data.operator.Or.sub_operators","title":"<code>sub_operators: list[Operator]</code>  <code>property</code>","text":"<p>Sub-operators contained inside the operator.</p>"},{"location":"api_reference/scimpler_data_operator/present/","title":"Present","text":"<p>               Bases: <code>UnaryAttributeOperator</code></p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>The representation of an attribute which value should be matched.</p> <p> TYPE: <code>AttrRep</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep):\n    \"\"\"\n    Args:\n        attr_rep: The representation of an attribute which value should be matched.\n    \"\"\"\n    self._attr_rep = attr_rep\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/present/#scimpler.data.operator.Present-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/present/#scimpler.data.operator.Present.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/present/#scimpler.data.operator.Present-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/present/#scimpler.data.operator.Present.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    if attr.scim_type not in self.supported_scim_types:\n        return False\n\n    if not value:\n        return False\n\n    attr_value = value.get(self.attr_rep)\n\n    if attr.multi_valued:\n        if isinstance(attr_value, list):\n            match = any(\n                [self.operator(item) for item in attr_value if self.is_type_supported(item)]\n            )\n        else:\n            match = False\n    else:\n        match = self.operator(attr_value)\n\n    return match\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/present/#scimpler.data.operator.Present.operator","title":"<code>operator(value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    if isinstance(value, Mapping):\n        return any([Present.operator(val) for val in value.values()])\n    if isinstance(value, str):\n        return value != \"\"\n    return value not in [None, Missing]\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/starts_with/","title":"StartsWith","text":"<p>               Bases: <code>BinaryAttributeOperator</code></p> <p>Represents <code>sw</code> SCIM operator.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>A representation of an attribute which value should be compared with the operator's value.</p> <p> TYPE: <code>AttrRep</code> </p> <code>value</code> <p>The operator's value (right operand), compared to the attribute's value (left operand).</p> <p> TYPE: <code>Any</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep, value: Any):\n    \"\"\"\n    Args:\n        attr_rep: A representation of an attribute which value should be\n            compared with the operator's value.\n        value: The operator's value (right operand), compared to the attribute's value\n            (left operand).\n    \"\"\"\n    super().__init__(attr_rep=attr_rep)\n    if not self.is_type_supported(value):\n        raise TypeError(\n            f\"value type {type(value).__name__!r} is not supported by {self.op!r} operator\"\n        )\n    self._value = value\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith.value","title":"<code>value: Any</code>  <code>property</code>","text":"<p>The operator's value (right operand), compared to the attribute's value (left operand).</p>"},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    attr_value = None if not value else value.get(self.attr_rep)\n\n    if attr_value in [None, Missing, Invalid]:\n        return False\n\n    values = self._get_values(attr_value, attr)\n\n    if values is None:\n        return False\n\n    for attr_value, op_value in values:\n        try:\n            if self.operator(attr_value, op_value):\n                return True\n        except (AttributeError, TypeError):\n            pass\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/starts_with/#scimpler.data.operator.StartsWith.operator","title":"<code>operator(attr_value, op_value)</code>  <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\ndef operator(attr_value: Any, op_value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n    return attr_value.startswith(op_value)\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/","title":"UnaryAttributeOperator","text":"<p>               Bases: <code>AttributeOperator</code>, <code>ABC</code></p> <p>Base class for all unary operators. Every subclass which is not an abstract must specify <code>op</code>, <code>supported_scim_types</code>, and <code>supported_types</code> class attributes.</p> PARAMETER DESCRIPTION <code>attr_rep</code> <p>The representation of an attribute which value should be matched.</p> <p> TYPE: <code>AttrRep</code> </p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def __init__(self, attr_rep: AttrRep):\n    \"\"\"\n    Args:\n        attr_rep: The representation of an attribute which value should be matched.\n    \"\"\"\n    self._attr_rep = attr_rep\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/#scimpler.data.operator.UnaryAttributeOperator-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/#scimpler.data.operator.UnaryAttributeOperator.attr_rep","title":"<code>attr_rep: AttrRep</code>  <code>property</code>","text":"<p>The representation of an attribute which value should be matched.</p>"},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/#scimpler.data.operator.UnaryAttributeOperator-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/#scimpler.data.operator.UnaryAttributeOperator.match","title":"<code>match(value, schema_or_complex)</code>","text":"<p>Tests a given <code>value</code> against the operator and returns <code>True</code> if it matches, <code>False</code> otherwise. If the <code>value</code> belongs to multi-valued attribute, the whole <code>value</code> matches if one of its items matches.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to test.</p> <p> TYPE: <code>Optional[ScimData]</code> </p> <code>schema_or_complex</code> <p>Schema or <code>Complex</code> attribute that describes the value.</p> <p> TYPE: <code>TSchemaOrComplex</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Flag indicating whether the value matches the operator.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>def match(\n    self,\n    value: Optional[ScimData],\n    schema_or_complex: TSchemaOrComplex,\n) -&gt; bool:\n    \"\"\"\n    Tests a given `value` against the operator and returns `True`\n    if it matches, `False` otherwise. If the `value` belongs to multi-valued\n    attribute, the whole `value` matches if one of its items matches.\n\n    Args:\n        value: The value to test.\n        schema_or_complex: Schema or `Complex` attribute that describes the value.\n\n    Returns:\n        Flag indicating whether the value matches the operator.\n    \"\"\"\n    attr = schema_or_complex.attrs.get(self.attr_rep)\n    if attr is None:\n        return False\n\n    if attr.scim_type not in self.supported_scim_types:\n        return False\n\n    if not value:\n        return False\n\n    attr_value = value.get(self.attr_rep)\n\n    if attr.multi_valued:\n        if isinstance(attr_value, list):\n            match = any(\n                [self.operator(item) for item in attr_value if self.is_type_supported(item)]\n            )\n        else:\n            match = False\n    else:\n        match = self.operator(attr_value)\n\n    return match\n</code></pre>"},{"location":"api_reference/scimpler_data_operator/unary_attribute_operator/#scimpler.data.operator.UnaryAttributeOperator.operator","title":"<code>operator(value)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Implements operator's logic for matching the provided value.</p> Source code in <code>src/scimpler/data/operator.py</code> <pre><code>@staticmethod\n@abc.abstractmethod\ndef operator(value: Any) -&gt; bool:\n    \"\"\"\n    Implements operator's logic for matching the provided value.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_error/","title":"ValidationError","text":"<p>Represents a validation error. Uniquely identified by the error code.</p> <p>Pre-formatted messages stored in <code>message_by_code</code> can be modified, as long as embedded string parameters stay the same.</p> PARAMETER DESCRIPTION <code>code</code> <p>The error code. Can be one of built-in error_codes (see <code>message_by_code</code> attribute) or custom. If custom, it must be greater than 1000.</p> <p> TYPE: <code>int</code> </p> <code>scim_error</code> <p>SCIM error corresponding to the validation error.</p> <p> TYPE: <code>Union[str, ScimErrorType]</code> </p> <code>message</code> <p>Error message. Can replace built-in message or be specified for custom validation error.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**context</code> <p>Parameters passed to pre-formatted messages.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/error.py</code> <pre><code>def __init__(\n    self,\n    code: int,\n    scim_error: Union[str, ScimErrorType],\n    message: Optional[str] = None,\n    **context: Any,\n):\n    \"\"\"\n    Args:\n        code: The error code. Can be one of built-in error_codes (see `message_by_code`\n            attribute) or custom. If custom, it must be greater than 1000.\n        scim_error: SCIM error corresponding to the validation error.\n        message: Error message. Can replace built-in message or be specified for custom\n            validation error.\n        **context: Parameters passed to pre-formatted messages.\n    \"\"\"\n    if code not in self.message_by_code and code &lt;= 1000:\n        raise ValueError(\"error code for custom validation error must be greater than 1000\")\n    self.code = code\n    if message is None:\n        message = \"\" if code &gt; 1000 else self.message_by_code[code].format(**context)\n    self.message = message\n    self.context = context\n    self.scim_error = ScimErrorType(scim_error)\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_error/#pre-defined-error-codes","title":"Pre-defined error codes","text":"Error code  Description 1 Value has correct type, but bad syntax (e.g. does not match regular expression). 2 Value has bad type and can not be validated further. 3 Value has bad encoding, e.g. for binary attributes, base64 encoding is required. 4 Value has correct type and syntax, but bad semantics. 5 Value is expected, but is missing. 6 Value is provided when it should not be. 7 Value is returned when it should not be. 8 Value must be equal to specific value, but it is not. 9 Value must be one of specific values. 10 Value contains duplicates. 11 Value can not be provided if other value is provided. 12 The <code>schemas</code> attribute is missing base schema. 13 The <code>schemas</code> attribute is missing one of the extensions which attributes are present in the data. 14 The <code>schemas</code> attribute contains unknown schema URI. 15 The <code>primary</code> sub-attribute set to <code>True</code> appears more than once in multi-valued complex attribute. 16 The value of scim reference attribute is unknown. 17 The provided attribute name is invalid. 18 Bad value of error <code>status</code>. 19 Bad value of returned status code. 20 Bad number of resources returned from query endpoint. 21 The returned resource does not match the filter. 22 Resources are not sorted, according to the sorter. 25 Unknown bulk operation resource. 26 Number of bulk operations exceeded the configured maximum. 27 Number of errors in returned bulk operations exceeded provided maximum. 28 The <code>PATCH</code> operation path indicates non-existing attribute. 29 The attribute specified in <code>PATCH</code> operation can not be modified. 30 The attribute specified in <code>PATCH</code> operation can not be removed. 31 The provided value is not supported. 100 At least one of the round brackets in the filter expression is not opened / closed. 101 At least one of the complex attribute group brackets in the filter expression is not opened / closed. 102 Complex attribute group operator used for sub-attribute. 103 The operator in the filter expression misses an operand. 104 Unknown operator in the filter expression. 105 No inner expression in the round brackets. 106 Unknown expression, generic filter error if validation fails from other reasons. 107 Complex attribute group operator contains inner complex attribute group. 108 Complex attribute group operator contains no inner expression. 109 Not recognized operand for the operator. 110 Operand's value not compatible with the specific operator."},{"location":"api_reference/scimpler_error/validation_issues/","title":"ValidationIssues","text":"<p>Keeps track of validation errors and warnings.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._errors: dict[tuple, list[ValidationError]] = defaultdict(list)\n    self._warnings: dict[tuple, list[ValidationWarning]] = defaultdict(list)\n    self._stop_proceeding: dict[tuple, set[int]] = defaultdict(set)\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.errors","title":"<code>errors: Iterator[tuple[tuple[str, ...], list[ValidationError]]]</code>  <code>property</code>","text":"<p>Validation errors by locations where they were added.</p>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.warnings","title":"<code>warnings: Iterator[tuple[tuple[str, ...], list[ValidationWarning]]]</code>  <code>property</code>","text":"<p>Validation warnings by locations where they were added.</p>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.add_error","title":"<code>add_error(issue, proceed, location=None)</code>","text":"<p>Adds a validation error under specified <code>location</code>, if specified, in the top-level. The <code>proceed</code> flag is an indicator whether the specified <code>location</code> could continue to be validated against different conditions (<code>True</code>), or further validation should be terminated (<code>False</code>).</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def add_error(\n    self,\n    issue: ValidationError,\n    proceed: bool,\n    location: Optional[Sequence[Union[str, int]]] = None,\n) -&gt; None:\n    \"\"\"\n    Adds a validation error under specified `location`, if specified, in the top-level. The\n    `proceed` flag is an indicator whether the specified `location` could continue to be\n    validated against different conditions (`True`), or further validation should be terminated\n    (`False`).\n    \"\"\"\n    location = tuple(location or tuple())\n    self._errors[location].append(issue)\n    if not proceed:\n        self._stop_proceeding[location].add(issue.code)\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.add_warning","title":"<code>add_warning(issue, location=None)</code>","text":"<p>Adds a validation warning under specified <code>location</code>, if specified, in the top-level.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def add_warning(\n    self,\n    issue: ValidationWarning,\n    location: Optional[Sequence[Union[str, int]]] = None,\n) -&gt; None:\n    \"\"\"\n    Adds a validation warning under specified `location`, if specified, in the top-level.\n    \"\"\"\n    location = tuple(location or tuple())\n    self._warnings[location].append(issue)\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.can_proceed","title":"<code>can_proceed(*locations)</code>","text":"<p>Returns flag indicating whether validation could proceed given <code>locations</code>. If all the provided <code>locations</code> have no errors, or these errors have not been added with <code>proceed=True</code>, then <code>True</code> is returned.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def can_proceed(self, *locations: Sequence[Union[str, int]]) -&gt; bool:\n    \"\"\"\n    Returns flag indicating whether validation could proceed given `locations`. If all\n    the provided `locations` have no errors, or these errors have not been added with\n    `proceed=True`, then `True` is returned.\n    \"\"\"\n    if not locations:\n        locations = (tuple(),)\n    for location in locations:\n        location = tuple(location)\n        for i in range(len(location) + 1):\n            if location[:i] in self._stop_proceeding:\n                return False\n    return True\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.get","title":"<code>get(error_codes=None, warning_codes=None, location=None)</code>","text":"<p>Retrieves validation issues for the specified <code>location</code>, or all of them if not specified. The returned issues can be filtered by <code>error_codes</code> and <code>warning_codes</code>.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def get(\n    self,\n    error_codes: Optional[Collection[int]] = None,\n    warning_codes: Optional[Collection[int]] = None,\n    location: Optional[Sequence[Union[str, int]]] = None,\n) -&gt; \"ValidationIssues\":\n    \"\"\"\n    Retrieves validation issues for the specified `location`, or all of them if not specified.\n    The returned issues can be filtered by `error_codes` and `warning_codes`.\n    \"\"\"\n    location = tuple(location or tuple())\n    copy = ValidationIssues()\n    copy._errors = self._get_errors(error_codes, location)\n    copy._warnings = self._get_warnings(warning_codes, location)\n    copy._stop_proceeding = self._get_stop_proceeding(error_codes, location)\n    return copy\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.has_errors","title":"<code>has_errors(*locations)</code>","text":"<p>Returns flag indicating whether any errors have been added under specified <code>locations</code>. If at least one of the <code>locations</code> have errors (regardless of type), <code>True</code> is returned.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def has_errors(self, *locations: Sequence[Union[str, int]]) -&gt; bool:\n    \"\"\"\n    Returns flag indicating whether any errors have been added under specified `locations`. If\n    at least one of the `locations` have errors (regardless of type), `True` is returned.\n    \"\"\"\n    if not locations:\n        locations = (tuple(),)\n\n    for location in locations:\n        for issue_location in self._errors:\n            if issue_location[: len(location)] == location:\n                return True\n\n    return False\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.merge","title":"<code>merge(issues, location=None)</code>","text":"<p>Merges provided validation <code>issues</code> under specified <code>location</code>, if specified, in the top-level otherwise.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def merge(\n    self,\n    issues: \"ValidationIssues\",\n    location: Optional[Sequence[Union[str, int]]] = None,\n) -&gt; None:\n    \"\"\"\n    Merges provided validation `issues` under specified `location`, if specified, in the\n    top-level otherwise.\n    \"\"\"\n    location = tuple(location or tuple())\n    for other_location, errors in issues._errors.items():\n        new_location = location + other_location\n        self._errors[new_location].extend(errors)\n        self._stop_proceeding[new_location].update(\n            issues._stop_proceeding.get(other_location, {})\n        )\n    for other_location, warnings in issues._warnings.items():\n        new_location = location + other_location\n        self._warnings[new_location].extend(warnings)\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.pop","title":"<code>pop(error_codes=None, warning_codes=None, location=None)</code>","text":"<p>Pops validation issues from the specified <code>location</code>, or all of them if not specified. Additionally, <code>error_codes</code> or <code>warning_codes</code> should be specified, otherwise nothing is popped.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def pop(\n    self,\n    error_codes: Optional[Collection[int]] = None,\n    warning_codes: Optional[Collection[int]] = None,\n    location: Optional[Sequence[Union[str, int]]] = None,\n) -&gt; \"ValidationIssues\":\n    \"\"\"\n    Pops validation issues from the specified `location`, or all of them if not specified.\n    Additionally, `error_codes` or `warning_codes` should be specified, otherwise nothing\n    is popped.\n    \"\"\"\n    location = tuple(location or tuple())\n    popped = self.get(\n        error_codes=error_codes or [],\n        warning_codes=warning_codes or [],\n        location=location,\n    )\n    for location_, errors in popped.errors:\n        self._remove_errors(errors=errors, location=(*location, *location_))\n    for location_, warnings in popped.warnings:\n        self._remove_warnings(warnings=warnings, location=(*location, *location_))\n    return popped\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_issues/#scimpler.error.ValidationIssues.to_dict","title":"<code>to_dict(message=False, context=False)</code>","text":"<p>Converts <code>ValidationIssues</code> to a dictionary.</p> Source code in <code>src/scimpler/error.py</code> <pre><code>def to_dict(self, message: bool = False, context: bool = False) -&gt; dict:\n    \"\"\"\n    Converts `ValidationIssues` to a dictionary.\n    \"\"\"\n    output: dict = {}\n    self._set_dict(\"_errors\", self._errors, output, message=message, context=context)\n    self._set_dict(\"_warnings\", self._warnings, output, message=message, context=context)\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_error/validation_warning/","title":"ValidationWarning","text":"<p>Represents a validation warning. Uniquely identified by the error code.</p> <p>Pre-formatted messages stored in <code>message_by_code</code> can be modified, as long as embedded string parameters stay the same.</p> PARAMETER DESCRIPTION <code>code</code> <p>The warning code. Can be one of built-in error_codes (see <code>message_by_code</code> attribute) or custom. If custom, it must be greater than 1000.</p> <p> TYPE: <code>int</code> </p> <code>message</code> <p>Warning message. Can replace built-in message or be specified for custom validation warning.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**context</code> <p>Parameters passed to pre-formatted messages.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/scimpler/error.py</code> <pre><code>def __init__(self, code: int, message: Optional[str] = None, **context: Any):\n    \"\"\"\n    Args:\n        code: The warning code. Can be one of built-in error_codes (see `message_by_code`\n            attribute) or custom. If custom, it must be greater than 1000.\n        message: Warning message. Can replace built-in message or be specified for custom\n            validation warning.\n        **context: Parameters passed to pre-formatted messages.\n    \"\"\"\n    if code not in self.message_by_code and code &lt;= 1000:\n        raise ValueError(\"error code for custom validation warning must be greater than 1000\")\n    self.code = code\n    if message is None:\n        message = \"\" if code &gt; 1000 else self.message_by_code[code].format(**context)\n    self.message = message\n    self.context = context\n</code></pre>"},{"location":"api_reference/scimpler_ext/marshmallow/","title":"marshmallow","text":"<p>Integration with <code>marshmallow</code>.</p>"},{"location":"api_reference/scimpler_ext/marshmallow/#scimpler.ext.marshmallow.ResponseContextProvider","title":"<code>ResponseContextProvider</code>","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api_reference/scimpler_ext/marshmallow/#scimpler.ext.marshmallow.ResponseContextProvider.__call__","title":"<code>__call__()</code>","text":"<p>Returns <code>ResponseContext</code>.</p> Source code in <code>src/scimpler/ext/marshmallow.py</code> <pre><code>def __call__(self) -&gt; ResponseContext:\n    \"\"\"Returns `ResponseContext`.\"\"\"\n</code></pre>"},{"location":"api_reference/scimpler_ext/marshmallow/#scimpler.ext.marshmallow.create_request_schema","title":"<code>create_request_schema(validator)</code>","text":"<p>Creates <code>marshmallow</code> schema for the request from the provided <code>validator</code>.</p> <p>The fields of the resulting schema have no SCIM-specific properties and attributes. Instead, the scimpler schema is hidden inside, so all validations and most of (de)serialization is the done exactly same.</p> PARAMETER DESCRIPTION <code>validator</code> <p>The validator to create the schema from.</p> <p> TYPE: <code>Validator</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt; from scimpler.validator import ResourcesPost\n&gt;&gt;&gt;\n&gt;&gt;&gt; v = ResourcesPost(resource_schema=UserSchema())\n&gt;&gt;&gt; schema_cls = create_request_schema(v)\n&gt;&gt;&gt; schema = schema_cls()\n&gt;&gt;&gt; schema\n&lt;UserSchema(many=False)&gt;\n&gt;&gt;&gt; schema.load({...})\n</code></pre> Source code in <code>src/scimpler/ext/marshmallow.py</code> <pre><code>def create_request_schema(validator: Validator) -&gt; type[marshmallow.Schema]:\n    \"\"\"\n    Creates `marshmallow` schema for the request from the provided `validator`.\n\n    The fields of the resulting schema have no SCIM-specific properties and attributes. Instead,\n    the scimpler schema is hidden inside, so all validations and most of (de)serialization is\n    the done exactly same.\n\n    Args:\n       validator: The validator to create the schema from.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt; from scimpler.validator import ResourcesPost\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; v = ResourcesPost(resource_schema=UserSchema())\n        &gt;&gt;&gt; schema_cls = create_request_schema(v)\n        &gt;&gt;&gt; schema = schema_cls()\n        &gt;&gt;&gt; schema\n        &lt;UserSchema(many=False)&gt;\n        &gt;&gt;&gt; schema.load({...})\n    \"\"\"\n    _ensure_initialized()\n    return _create_schema(\n        scimpler_schema=validator.request_schema,\n        processors=Processors(validator=validator.validate_request),\n        context_provider=None,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_ext/marshmallow/#scimpler.ext.marshmallow.create_response_schema","title":"<code>create_response_schema(validator, context_provider=None)</code>","text":"<p>Creates <code>marshmallow</code> schema for the response from the provided <code>validator</code>.</p> <p>The fields of the resulting schema have no SCIM-specific properties and attributes. Instead, the scimpler schema is hidden inside, so all validations and most of (de)serialization is the done exactly same.</p> PARAMETER DESCRIPTION <code>validator</code> <p>The validator to create the schema from.</p> <p> TYPE: <code>Validator</code> </p> <code>context_provider</code> <p>Callable that returns <code>ResponseContext</code>, so parameters required for response validation (like status_code, attribute value presence config, etc.).</p> <p> TYPE: <code>Optional[ResponseContextProvider]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.data import AttrValuePresenceConfig\n&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt; from scimpler.validator import ResourcesQuery\n&gt;&gt;&gt;\n&gt;&gt;&gt; def get_presence_config_from_request() -&gt; AttrValuePresenceConfig:\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; v = ResourcesQuery(resource_schema=UserSchema())\n&gt;&gt;&gt; schema_cls = create_response_schema(\n&gt;&gt;&gt;     v,\n&gt;&gt;&gt;     context_provider=lambda: ResponseContext(\n&gt;&gt;&gt;         status_code=200,\n&gt;&gt;&gt;         presence_config=get_presence_config_from_request(),\n&gt;&gt;&gt;     )\n&gt;&gt;&gt; )\n&gt;&gt;&gt; schema = schema_cls()\n&gt;&gt;&gt; schema\n&lt;UserSchema(many=False)&gt;\n&gt;&gt;&gt; schema.dump({...})\n</code></pre> Source code in <code>src/scimpler/ext/marshmallow.py</code> <pre><code>def create_response_schema(\n    validator: Validator,\n    context_provider: Optional[ResponseContextProvider] = None,\n) -&gt; type[marshmallow.Schema]:\n    \"\"\"\n    Creates `marshmallow` schema for the response from the provided `validator`.\n\n    The fields of the resulting schema have no SCIM-specific properties and attributes. Instead,\n    the scimpler schema is hidden inside, so all validations and most of (de)serialization is\n    the done exactly same.\n\n    Args:\n       validator: The validator to create the schema from.\n       context_provider: Callable that returns `ResponseContext`, so parameters required\n          for response validation (like status_code, attribute value presence config, etc.).\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.data import AttrValuePresenceConfig\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt; from scimpler.validator import ResourcesQuery\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def get_presence_config_from_request() -&gt; AttrValuePresenceConfig:\n        &gt;&gt;&gt;     ...\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; v = ResourcesQuery(resource_schema=UserSchema())\n        &gt;&gt;&gt; schema_cls = create_response_schema(\n        &gt;&gt;&gt;     v,\n        &gt;&gt;&gt;     context_provider=lambda: ResponseContext(\n        &gt;&gt;&gt;         status_code=200,\n        &gt;&gt;&gt;         presence_config=get_presence_config_from_request(),\n        &gt;&gt;&gt;     )\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; schema = schema_cls()\n        &gt;&gt;&gt; schema\n        &lt;UserSchema(many=False)&gt;\n        &gt;&gt;&gt; schema.dump({...})\n    \"\"\"\n    _ensure_initialized()\n    return _create_schema(\n        scimpler_schema=validator.response_schema,\n        processors=Processors(validator=validator.validate_response),\n        context_provider=context_provider,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_ext/marshmallow/#scimpler.ext.marshmallow.initialize","title":"<code>initialize(fields_by_attrs=None)</code>","text":"<p>Initializes the <code>marshmallow</code> extension. Used to specify mapping of scimpler attributes to marshmallow fields, used during data (de)serialization.</p> <p>Default mapping is as follows:</p> <pre><code>scimpler.data.Boolean           ---&gt; marshmallow.fields.Boolean\nscimpler.data.Integer           ---&gt; marshmallow.fields.Integer\nscimpler.data.Decimal           ---&gt; marshmallow.fields.Float\nscimpler.data.DateTime          ---&gt; marshmallow.fields.DateTime\nscimpler.data.Binary            ---&gt; marshmallow.fields.String\nscimpler.data.ExternalReference ---&gt; marshmallow.fields.String\nscimpler.data.UriReference      ---&gt; marshmallow.fields.String\nscimpler.data.ScimReference     ---&gt; marshmallow.fields.String\nscimpler.data.String            ---&gt; marshmallow.fields.String\n</code></pre> <p><code>scimpler.data.Complex</code> is always converted to <code>marshmallow.fields.Nested</code>.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>When attempt to initialize the extension second time.</p> Source code in <code>src/scimpler/ext/marshmallow.py</code> <pre><code>def initialize(\n    fields_by_attrs: Optional[dict[type[attrs.Attribute], type[marshmallow.fields.Field]]] = None,\n):\n    \"\"\"\n    Initializes the `marshmallow` extension. Used to specify mapping of scimpler attributes to\n    marshmallow fields, used during data (de)serialization.\n\n    Default mapping is as follows:\n\n        scimpler.data.Boolean           ---&gt; marshmallow.fields.Boolean\n        scimpler.data.Integer           ---&gt; marshmallow.fields.Integer\n        scimpler.data.Decimal           ---&gt; marshmallow.fields.Float\n        scimpler.data.DateTime          ---&gt; marshmallow.fields.DateTime\n        scimpler.data.Binary            ---&gt; marshmallow.fields.String\n        scimpler.data.ExternalReference ---&gt; marshmallow.fields.String\n        scimpler.data.UriReference      ---&gt; marshmallow.fields.String\n        scimpler.data.ScimReference     ---&gt; marshmallow.fields.String\n        scimpler.data.String            ---&gt; marshmallow.fields.String\n\n    `scimpler.data.Complex` is always converted to `marshmallow.fields.Nested`.\n\n    Raises:\n        RuntimeError: When attempt to initialize the extension second time.\n    \"\"\"\n    global _marshmallow_field_by_attr_type, _initialized\n    if _auto_initialized:\n        raise RuntimeError(\n            \"marshmallow extension has been automatically initialized with default field mapping; \"\n            \"call scimpler.ext.marshmallow.initialize() before first call to extension\"\n        )\n    if _initialized:\n        raise RuntimeError(\"marshmallow extension has been already initialized\")\n\n    if fields_by_attrs is not None:\n        _marshmallow_field_by_attr_type.update(fields_by_attrs)\n    _initialized = True\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_get/","title":"ResourceObjectGet","text":"<p>               Bases: <code>GenericQueryStringHandler</code></p> <p>Handles query-string parameters sent with HTTP GET operations performed against resource object endpoints.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(None)\n    self._schema = SearchRequestSchema(\n        attr_filter=AttrFilter(attr_reps={\"attributes\", \"excludedAttributes\"}, include=True)\n    )\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_get/#scimpler.query_string.ResourceObjectGet-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resource_object_get/#scimpler.query_string.ResourceObjectGet.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_get/#scimpler.query_string.ResourceObjectGet.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_get/#scimpler.query_string.ResourceObjectGet.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.set(\n        \"schemas\",\n        [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\n    )\n    return self.schema.validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_patch/","title":"ResourceObjectPatch","text":"<p>               Bases: <code>GenericQueryStringHandler</code></p> <p>Handles query-string parameters sent with HTTP PUT operations performed against resource object endpoints.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(None)\n    self._schema = SearchRequestSchema(\n        attr_filter=AttrFilter(attr_reps={\"attributes\", \"excludedAttributes\"}, include=True)\n    )\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_patch/#scimpler.query_string.ResourceObjectPatch-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resource_object_patch/#scimpler.query_string.ResourceObjectPatch.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_patch/#scimpler.query_string.ResourceObjectPatch.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_patch/#scimpler.query_string.ResourceObjectPatch.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.set(\n        \"schemas\",\n        [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\n    )\n    return self.schema.validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_put/","title":"ResourceObjectPut","text":"<p>               Bases: <code>GenericQueryStringHandler</code></p> <p>Handles query-string parameters sent with HTTP PUT operations performed against resource object endpoints.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(None)\n    self._schema = SearchRequestSchema(\n        attr_filter=AttrFilter(attr_reps={\"attributes\", \"excludedAttributes\"}, include=True)\n    )\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_put/#scimpler.query_string.ResourceObjectPut-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resource_object_put/#scimpler.query_string.ResourceObjectPut.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_put/#scimpler.query_string.ResourceObjectPut.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_object_put/#scimpler.query_string.ResourceObjectPut.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.set(\n        \"schemas\",\n        [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\n    )\n    return self.schema.validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_types_get/","title":"ResourceTypesGet","text":"<p>               Bases: <code>_ServiceProviderConfigGet</code></p> <p>Handles query-string parameters sent with HTTP GET operations performed against /ResourceTypes endpoint.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self, config: Optional[scimpler.config.ServiceProviderConfig] = None) -&gt; None:\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n    \"\"\"\n    super().__init__(config)\n    self._schema = SearchRequestSchema(attr_filter=AttrFilter(filter_=lambda _: False))\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet.schema","title":"<code>schema: SearchRequestSchema</code>  <code>property</code>","text":"<p>Inner <code>SearchRequestSchema</code> used for query-string validation, serialization, and deserialization.</p>"},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resource_types_get/#scimpler.query_string.ResourceTypesGet.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>. Additionally, it checks if <code>filter</code> is not provided.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`. Additionally, it checks if\n    `filter` is not provided.\n    \"\"\"\n    issues = ValidationIssues()\n    query_params = query_params or {}\n    if \"filter\" in query_params:\n        issues.add_error(\n            issue=ValidationError.not_supported(),\n            proceed=False,\n            location=[\"filter\"],\n        )\n        return issues\n    return super().validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_get/","title":"ResourcesGet","text":"<p>               Bases: <code>QueryStringHandler</code></p> <p>Handles query-string parameters sent with HTTP GET operations performed against resource type endpoints.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self, config: Optional[scimpler.config.ServiceProviderConfig] = None):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n    \"\"\"\n    super().__init__(config)\n    self._schema = SearchRequestSchema.from_config(self.config)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_get/#scimpler.query_string.ResourcesGet-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resources_get/#scimpler.query_string.ResourcesGet.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_get/#scimpler.query_string.ResourcesGet.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_get/#scimpler.query_string.ResourcesGet.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.set(\n        \"schemas\",\n        [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\n    )\n    return self.schema.validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_post/","title":"ResourcesPost","text":"<p>               Bases: <code>GenericQueryStringHandler</code></p> <p>Handles query-string parameters sent with HTTP POST operations performed against resource type endpoints.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(None)\n    self._schema = SearchRequestSchema(\n        attr_filter=AttrFilter(attr_reps={\"attributes\", \"excludedAttributes\"}, include=True)\n    )\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_post/#scimpler.query_string.ResourcesPost-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/resources_post/#scimpler.query_string.ResourcesPost.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_post/#scimpler.query_string.ResourcesPost.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/resources_post/#scimpler.query_string.ResourcesPost.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>.</p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.set(\n        \"schemas\",\n        [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\n    )\n    return self.schema.validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_query_string/schemas_get/","title":"SchemasGet","text":"<p>               Bases: <code>_ServiceProviderConfigGet</code></p> <p>Handles query-string parameters sent with HTTP GET operations performed against /Schemas endpoint.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def __init__(self, config: Optional[scimpler.config.ServiceProviderConfig] = None) -&gt; None:\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n    \"\"\"\n    super().__init__(config)\n    self._schema = SearchRequestSchema(attr_filter=AttrFilter(filter_=lambda _: False))\n</code></pre>"},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet.schema","title":"<code>schema: SearchRequestSchema</code>  <code>property</code>","text":"<p>Inner <code>SearchRequestSchema</code> used for query-string validation, serialization, and deserialization.</p>"},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet.deserialize","title":"<code>deserialize(query_params=None)</code>","text":"<p>Deserializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def deserialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Deserializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    self._unify_attributes(query_params)\n    query_params.update(self.schema.deserialize(query_params))\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet.serialize","title":"<code>serialize(query_params=None)</code>","text":"<p>Serializes <code>query_params</code> using <code>SearchRequestSchema</code>, which contains attributes suitable for the specific HTTP operation. Unknown parameters are preserved.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def serialize(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ScimData:\n    \"\"\"\n    Serializes `query_params` using `SearchRequestSchema`, which contains attributes suitable\n    for the specific HTTP operation. Unknown parameters are preserved.\n    \"\"\"\n    query_params = ScimData(query_params or {})\n    serialized = self.schema.serialize(query_params)\n    if attributes := query_params.get(\"attributes\"):\n        serialized[\"attributes\"] = \",\".join(str(attr_rep) for attr_rep in attributes)\n    if excluded_attributes := query_params.get(\"excludedAttributes\"):\n        serialized[\"excludedAttributes\"] = \",\".join(\n            str(attr_rep) for attr_rep in excluded_attributes\n        )\n    query_params.update(serialized)\n    return query_params\n</code></pre>"},{"location":"api_reference/scimpler_query_string/schemas_get/#scimpler.query_string.SchemasGet.validate","title":"<code>validate(query_params=None)</code>","text":"<p>Validates <code>query_params</code> using <code>SearchRequestSchema</code>. Additionally, it checks if <code>filter</code> is not provided.</p> Source code in <code>src/scimpler/query_string.py</code> <pre><code>def validate(self, query_params: Optional[MutableMapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates `query_params` using `SearchRequestSchema`. Additionally, it checks if\n    `filter` is not provided.\n    \"\"\"\n    issues = ValidationIssues()\n    query_params = query_params or {}\n    if \"filter\" in query_params:\n        issues.add_error(\n            issue=ValidationError.not_supported(),\n            proceed=False,\n            location=[\"filter\"],\n        )\n        return issues\n    return super().validate(query_params)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/","title":"BulkRequestSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>BulkRequest schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:BulkRequest</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li><code>method</code> is provided,</li> <li><code>bulkId</code> is provided for <code>POST</code> method,</li> <li><code>path</code> is provided,</li> <li><code>path</code> is valid, depending on the method type,</li> <li><code>path</code> specifies one of supported resources,</li> <li><code>data</code> is provided for <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> methods.</li> </ul> <p>During (de)serialization, if method type is <code>GET</code> or <code>DELETE</code>, the <code>data</code> if provided, is dropped. For all other methods, the <code>data</code> is (de)serialized together with rest of the fields.</p> PARAMETER DESCRIPTION <code>sub_schemas</code> <p>Schemas supported by the bulk request, per resource type endpoint and method type.</p> <p> TYPE: <code>Mapping[str, Mapping[str, Optional[BaseSchema]]]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema, PatchOpSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user, group = UserSchema(), GroupSchema()\n&gt;&gt;&gt; user_patch = PatchOpSchema(user)\n&gt;&gt;&gt; group_patch = PatchOpSchema(group)\n&gt;&gt;&gt; BulkRequestSchema(\n&gt;&gt;&gt;     {\n&gt;&gt;&gt;         \"GET\": {\n&gt;&gt;&gt;             user.endpoint: user,\n&gt;&gt;&gt;             group.endpoint: group,\n&gt;&gt;&gt;         },\n&gt;&gt;&gt;         \"PATCH\": {\n&gt;&gt;&gt;             user.endpoint: user_patch,\n&gt;&gt;&gt;             group.endpoint: group_patch,\n&gt;&gt;&gt;         }\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>src/scimpler/schemas/bulk_ops.py</code> <pre><code>def __init__(\n    self,\n    sub_schemas: Mapping[str, Mapping[str, Optional[BaseSchema]]],\n):\n    \"\"\"\n    Args:\n        sub_schemas: Schemas supported by the bulk request, per resource type endpoint\n            and method type.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema, PatchOpSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user, group = UserSchema(), GroupSchema()\n        &gt;&gt;&gt; user_patch = PatchOpSchema(user)\n        &gt;&gt;&gt; group_patch = PatchOpSchema(group)\n        &gt;&gt;&gt; BulkRequestSchema(\n        &gt;&gt;&gt;     {\n        &gt;&gt;&gt;         \"GET\": {\n        &gt;&gt;&gt;             user.endpoint: user,\n        &gt;&gt;&gt;             group.endpoint: group,\n        &gt;&gt;&gt;         },\n        &gt;&gt;&gt;         \"PATCH\": {\n        &gt;&gt;&gt;             user.endpoint: user_patch,\n        &gt;&gt;&gt;             group.endpoint: group_patch,\n        &gt;&gt;&gt;         }\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; )\n    \"\"\"\n    super().__init__()\n    self._sub_schemas = sub_schemas\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.get_schema","title":"<code>get_schema(operation)</code>","text":"<p>Returns one of the sub-schemas, depending on the provided <code>operation</code> data. Returns <code>None</code> if an operation's method is not supported, or path indicates unsupported resource type.</p> Source code in <code>src/scimpler/schemas/bulk_ops.py</code> <pre><code>def get_schema(self, operation: Mapping) -&gt; Optional[BaseSchema]:\n    \"\"\"\n    Returns one of the sub-schemas, depending on the provided `operation` data. Returns\n    `None` if an operation's method is not supported, or path indicates unsupported resource\n    type.\n    \"\"\"\n    method = operation.get(\"method\", \"\").upper()\n    if method not in self._sub_schemas:\n        return None\n    path = operation.get(\"path\", \"\")\n    if \"/\" not in path:\n        return None\n    if method != \"POST\":\n        path = f\"/{path.split('/', 2)[1]}\"\n    return self._sub_schemas[method].get(path)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_request_schema/#scimpler.schemas.BulkRequestSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/","title":"BulkResponseSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>BulkResponse schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:BulkResponse</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li><code>method</code> is provided,</li> <li><code>bulkId</code> is provided for <code>POST</code> method,</li> <li><code>status</code> is provided,</li> <li><code>location</code> is provided for successful operations,</li> <li><code>location</code> specifies one of supported resources,</li> <li><code>response</code> is provided for unsuccessful operations.</li> </ul> PARAMETER DESCRIPTION <code>sub_schemas</code> <p>Schemas supported by the bulk response, per resource type endpoint and method type.</p> <p> TYPE: <code>Mapping[str, Mapping[str, Optional[BaseSchema]]]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user, group = UserSchema(), GroupSchema()\n&gt;&gt;&gt; BulkResponseSchema(\n&gt;&gt;&gt;     {\n&gt;&gt;&gt;         \"GET\": {\n&gt;&gt;&gt;             user.endpoint: user,\n&gt;&gt;&gt;             group.endpoint: group,\n&gt;&gt;&gt;         },\n&gt;&gt;&gt;         \"PATCH\": {\n&gt;&gt;&gt;             user.endpoint: user,\n&gt;&gt;&gt;             group.endpoint: group,\n&gt;&gt;&gt;         }\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>src/scimpler/schemas/bulk_ops.py</code> <pre><code>def __init__(\n    self,\n    sub_schemas: Mapping[str, Mapping[str, Optional[BaseSchema]]],\n    error_schema: ErrorSchema,\n):\n    \"\"\"\n    Args:\n        sub_schemas: Schemas supported by the bulk response, per resource type endpoint\n            and method type.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user, group = UserSchema(), GroupSchema()\n        &gt;&gt;&gt; BulkResponseSchema(\n        &gt;&gt;&gt;     {\n        &gt;&gt;&gt;         \"GET\": {\n        &gt;&gt;&gt;             user.endpoint: user,\n        &gt;&gt;&gt;             group.endpoint: group,\n        &gt;&gt;&gt;         },\n        &gt;&gt;&gt;         \"PATCH\": {\n        &gt;&gt;&gt;             user.endpoint: user,\n        &gt;&gt;&gt;             group.endpoint: group,\n        &gt;&gt;&gt;         }\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; )\n    \"\"\"\n    super().__init__()\n    self._sub_schemas = sub_schemas\n    self._error_schema = error_schema\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.get_schema","title":"<code>get_schema(operation)</code>","text":"<p>Returns one of the sub-schemas, depending on the provided <code>operation</code> data. Returns <code>None</code> if <code>status</code> is not present in the <code>operation</code>, or if an operation's method is not supported, or location indicates unsupported resource type.</p> Source code in <code>src/scimpler/schemas/bulk_ops.py</code> <pre><code>def get_schema(self, operation: Mapping) -&gt; Optional[BaseSchema]:\n    \"\"\"\n    Returns one of the sub-schemas, depending on the provided `operation` data. Returns\n    `None` if `status` is not present in the `operation`, or if an operation's method\n    is not supported, or location indicates unsupported resource type.\n    \"\"\"\n    operation = ScimData(operation)\n    status = operation.get(\"status\")\n    if status in [None, Missing]:\n        return None\n    if int(status) &gt;= 300:\n        return self._error_schema\n    location = operation.get(\"location\", \"\")\n    for endpoint, schema in self._sub_schemas.get(\n        operation.get(\"method\", \"\").upper(), {}\n    ).items():\n        if endpoint in location:\n            return schema\n    return None\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/bulk_response_schema/#scimpler.schemas.BulkResponseSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/enterprise_user_schema_extension/","title":"EnterpriseUserSchemaExtension","text":"<p>               Bases: <code>SchemaExtension</code></p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    self.schema = SchemaUri(self.schema)\n    register_schema(self.schema, True)\n    self._attrs = BoundedAttrs(\n        schema=self.schema,\n        attrs=(attr_filter(self.base_attrs) if attr_filter else self.base_attrs),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_schemas/enterprise_user_schema_extension/#scimpler.schemas.EnterpriseUserSchemaExtension-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/enterprise_user_schema_extension/#scimpler.schemas.EnterpriseUserSchemaExtension.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the extension.</p>"},{"location":"api_reference/scimpler_schemas/error_schema/","title":"ErrorSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>Error schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:Error</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li><code>status</code> represents numerical value in range 300-599,</li> <li><code>scimType</code> is one of pre-defined scim error types.</li> </ul> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(\n    self,\n    attr_filter: Optional[AttrFilter] = None,\n    common_attrs: Optional[Iterable[str]] = None,\n):\n    attrs = self._get_attrs()\n    filtered_attrs = attr_filter(attrs) if attr_filter else attrs\n    for attr in filtered_attrs:\n        if attr.name == \"schemas\":\n            break\n    else:\n        filtered_attrs.insert(0, BaseSchema.base_attrs[0])\n\n    self._attrs = BoundedAttrs(\n        schema=cast(SchemaUri, self.schema),\n        attrs=filtered_attrs,\n        common_attrs=list(common_attrs or []) + [\"schemas\"],\n    )\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/error_schema/#scimpler.schemas.ErrorSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/","title":"GroupSchema","text":"<p>               Bases: <code>ResourceSchema</code></p> <p>Group schema, identified by <code>urn:ietf:params:scim:schemas:core:2.0:Group</code> URI.</p> <p>Provides data validation and additional check if <code>members.type</code> is either <code>\"User\"</code> or <code>\"Group\"</code>.</p> <p>Default endpoint is <code>/Groups</code>.</p> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter used to filter attributes defined in class-level <code>base_attrs</code> attribute. Useful for creating different schemas, e.g. with only \"readWrite\" attributes, so serialization and deserialization also filter the data.</p> <p> TYPE: <code>Optional[AttrFilter]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    \"\"\"\n    Args:\n        attr_filter: Attribute filter used to filter attributes defined in class-level\n            `base_attrs` attribute. Useful for creating different schemas, e.g. with\n            only \"readWrite\" attributes, so serialization and deserialization also\n            filter the data.\n    \"\"\"\n    register_resource_schema(self)\n    self.plural_name = getattr(self, \"plural_name\", self.name)\n    self.endpoint = self.endpoint or f\"/{self.plural_name}\"\n    self._common_attrs = [\"id\", \"externalId\", \"meta\"]\n    super().__init__(attr_filter=attr_filter, common_attrs=self._common_attrs)\n    self._schema_extensions: dict[str, dict] = {}\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.extensions","title":"<code>extensions: dict[SchemaUri, bool]</code>  <code>property</code>","text":"<p>Extensions added to the schema. Map containing schema extension URIs and flags indicating whether they are required extensions.</p>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>Schema URIs by which the schema is identified. Includes schema extension URIs.</p>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.extend","title":"<code>extend(extension, required=False)</code>","text":"<p>Extends the base schema with the provided schema <code>extension</code>. Extension attributes become part of the schema and are available in <code>ResourceSchema.attrs</code>.</p> PARAMETER DESCRIPTION <code>extension</code> <p>Schema extension which extends the base schema.</p> <p> TYPE: <code>SchemaExtension</code> </p> <code>required</code> <p>Flag indicating whether the extension is required. If the extension is required, all required fields from the extension become required in base schema during presence checks. If the extension is not required and some of its attributes are required, they are not considered required in the base schema.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def extend(self, extension: \"SchemaExtension\", required: bool = False) -&gt; None:\n    \"\"\"\n    Extends the base schema with the provided schema `extension`. Extension attributes\n    become part of the schema and are available in `ResourceSchema.attrs`.\n\n    Args:\n        extension: Schema extension which extends the base schema.\n        required: Flag indicating whether the extension is required. If the extension\n            is required, all required fields from the extension become required in base\n            schema during presence checks. If the extension is not required and some of\n            its attributes are required, they are not considered required in the base schema.\n    \"\"\"\n    if extension.schema in self.schemas:\n        raise ValueError(f\"schema {extension.schema!r} already in {self.name!r} resource\")\n    if extension.name.lower() in self._schema_extensions:\n        raise RuntimeError(f\"extension {extension.name!r} already in resource\")\n    self._schema_extensions[extension.name.lower()] = {\n        \"extension\": extension,\n        \"required\": required,\n    }\n    for attr_rep, attr in extension.attrs:\n        if (\n            self.attrs.get(BoundedAttrRep(schema=self.schema, attr=attr_rep.attr)) is not None\n            or attr_rep.attr in self._common_attrs\n        ):\n            warnings.warn(\n                message=(\n                    f\"Resource extension {extension.name!r} defines {attr_rep.attr!r} \"\n                    f\"attribute, which is also present in base {self.name!r} schema.\"\n                ),\n                category=ScimpleUserWarning,\n            )\n    self._attrs.extend(\n        schema=cast(SchemaUri, extension.schema),\n        attrs=extension.attrs,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>. The exact content of <code>schemas</code> depends on the rest of the data. If the data contains attributes from the extensions, the extension URIs appear in the attached <code>schemas</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    The exact content of `schemas` depends on the rest of the data. If the data contains\n    attributes from the extensions, the extension URIs appear in the attached `schemas`.\n    \"\"\"\n    super().include_schema_data(data)\n    scim_data = ScimData(data)\n    for extension, extension_attrs in self.attrs.extensions.items():\n        for attr_rep, _ in extension_attrs:\n            if attr_rep in scim_data:\n                data[\"schemas\"].append(str(extension))\n                break\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/group_schema/#scimpler.schemas.GroupSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/","title":"ListResponseSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>ListResponse schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:ListResponse</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li><code>itemsPerPage</code> is consistent with number of <code>Resources</code>,</li> <li><code>Resources</code> contains known resources,</li> <li><code>Resources</code> contains valid resources that correspond to the known schemas.</li> </ul> PARAMETER DESCRIPTION <code>resource_schemas</code> <p>Resource schemas supported by the list response.</p> <p> TYPE: <code>Iterable[BaseResourceSchema]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; list_response = ListResponseSchema([UserSchema(), GroupSchema()])\n</code></pre> Source code in <code>src/scimpler/schemas/list_response.py</code> <pre><code>def __init__(self, resource_schemas: Iterable[BaseResourceSchema]):\n    \"\"\"\n    Args:\n        resource_schemas: Resource schemas supported by the list response.\n\n    Examples:\n         &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n         &gt;&gt;&gt;\n         &gt;&gt;&gt; list_response = ListResponseSchema([UserSchema(), GroupSchema()])\n    \"\"\"\n    super().__init__()\n    self._contained_schemas = list(resource_schemas)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.supported_schemas","title":"<code>supported_schemas: list[BaseResourceSchema]</code>  <code>property</code>","text":"<p>Resource schemas supported by the list response.</p>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.get_schema","title":"<code>get_schema(resource)</code>","text":"<p>Returns a schema for the provided <code>resource</code>. Returns <code>None</code> if the schema in <code>resource</code> is not supported by the list response.</p> PARAMETER DESCRIPTION <code>resource</code> <p>Resource data to get the schema for.</p> <p> TYPE: <code>Mapping</code> </p> Source code in <code>src/scimpler/schemas/list_response.py</code> <pre><code>def get_schema(self, resource: Mapping) -&gt; Optional[BaseResourceSchema]:\n    \"\"\"\n    Returns a schema for the provided `resource`. Returns `None` if the schema\n    in `resource` is not supported by the list response.\n\n    Args:\n        resource: Resource data to get the schema for.\n    \"\"\"\n    resource = ScimData(resource)\n    schemas_value = resource.get(\"schemas\")\n    if isinstance(schemas_value, list) and len(schemas_value) &gt; 0:\n        schemas_value = {SchemaUri(item) for item in schemas_value if isinstance(item, str)}\n        for schema in self._contained_schemas:\n            if schema.schema in schemas_value:\n                return schema\n    return None\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.get_schemas","title":"<code>get_schemas(resources)</code>","text":"<p>Returns schemas for corresponding items in the provided <code>resources</code>. Returns <code>None</code> for the particular item if its schema is not supported by the list response.</p> PARAMETER DESCRIPTION <code>resources</code> <p>Resources data to get the schemas for.</p> <p> TYPE: <code>list[Any]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user = UserSchema()\n&gt;&gt;&gt; list_response = ListResponseSchema([user])\n&gt;&gt;&gt; list_response.get_schemas(\n&gt;&gt;&gt;     [\n&gt;&gt;&gt;         {\n&gt;&gt;&gt;             \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"]\n&gt;&gt;&gt;             \"id\": \"1\",\n&gt;&gt;&gt;             \"userName\": \"Pagerous\",\n&gt;&gt;&gt;         },\n&gt;&gt;&gt;         {\n&gt;&gt;&gt;             \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"]\n&gt;&gt;&gt;             \"id\": \"2\",\n&gt;&gt;&gt;             \"name\": \"GitHub Users\",\n&gt;&gt;&gt;         }\n&gt;&gt;&gt;     ]\n&gt;&gt;&gt; )\n[&lt;scimpler.schemas.user.UserSchema at 0x7f1f6c193090&gt;, None]\n</code></pre> Source code in <code>src/scimpler/schemas/list_response.py</code> <pre><code>def get_schemas(self, resources: list[Any]) -&gt; list[Optional[BaseResourceSchema]]:\n    \"\"\"\n    Returns schemas for corresponding items in the provided `resources`. Returns `None`\n    for the particular item if its schema is not supported by the list response.\n\n    Args:\n        resources: Resources data to get the schemas for.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user = UserSchema()\n        &gt;&gt;&gt; list_response = ListResponseSchema([user])\n        &gt;&gt;&gt; list_response.get_schemas(\n        &gt;&gt;&gt;     [\n        &gt;&gt;&gt;         {\n        &gt;&gt;&gt;             \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"]\n        &gt;&gt;&gt;             \"id\": \"1\",\n        &gt;&gt;&gt;             \"userName\": \"Pagerous\",\n        &gt;&gt;&gt;         },\n        &gt;&gt;&gt;         {\n        &gt;&gt;&gt;             \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"]\n        &gt;&gt;&gt;             \"id\": \"2\",\n        &gt;&gt;&gt;             \"name\": \"GitHub Users\",\n        &gt;&gt;&gt;         }\n        &gt;&gt;&gt;     ]\n        &gt;&gt;&gt; )\n        [&lt;scimpler.schemas.user.UserSchema at 0x7f1f6c193090&gt;, None]\n    \"\"\"\n    resource_schemas: list[Optional[BaseResourceSchema]] = []\n    n_schemas = len(self._contained_schemas)\n    for resource in resources:\n        if isinstance(resource, Mapping):\n            resource = ScimData(resource)\n        if not isinstance(resource, ScimData):\n            resource_schemas.append(None)\n        elif n_schemas == 1:\n            resource_schemas.append(self._contained_schemas[0])\n        else:\n            resource_schemas.append(self.get_schema(resource))\n    return resource_schemas\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/list_response_schema/#scimpler.schemas.ListResponseSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/","title":"PatchOpSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>PatchOp schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:PatchOp</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li><code>Operations.op</code> is one of <code>add</code>, <code>remove</code>, and <code>replace</code>,</li> <li><code>Operations.path</code> is provided in <code>remove</code> operation,</li> <li><code>Operations.value</code> is provided in every <code>add</code> and <code>replace</code> operations,</li> <li><code>Operations.path</code> targets existing attribute,</li> <li><code>Operations.path</code> does not target <code>readOnly</code> attribute,</li> <li><code>Operations.path</code> deos not target required attribute in <code>remove</code> operation,</li> <li>All required data is supplied for complex attribute in <code>add</code> and <code>remove</code> operation,</li> <li><code>Operations.data</code> is correct, according to the schema and its attributes.</li> </ul> <p>Other checks for immutability, like if <code>immutable</code> attributes is not changed, are not performed (it requires to know previous state).</p> PARAMETER DESCRIPTION <code>resource_schema</code> <p>Resource schema supported by the patch operation.</p> <p> TYPE: <code>ResourceSchema</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; patch_op = PatchOpSchema(UserSchema())\n</code></pre> Source code in <code>src/scimpler/schemas/patch_op.py</code> <pre><code>def __init__(self, resource_schema: ResourceSchema):\n    \"\"\"\n    Args:\n        resource_schema: Resource schema supported by the patch operation.\n\n    Examples:\n         &gt;&gt;&gt; from scimpler.schemas import UserSchema\n         &gt;&gt;&gt;\n         &gt;&gt;&gt; patch_op = PatchOpSchema(UserSchema())\n    \"\"\"\n    super().__init__()\n    self._resource_schema = resource_schema\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.get_value_schema","title":"<code>get_value_schema(path, value=None)</code>","text":"<p>Returns the supported schema or one of its attributes, depending on the provided <code>path</code> and <code>value</code>. If <code>path</code> is <code>None</code> or <code>Missing</code>, whole supported schema is returned.</p> <p>If <code>path</code> is string value, it is deserialized and processed like <code>PatchPath</code>. For valid <code>PatchPath</code>, the attribute targeted by it is returned. The only exception is when the <code>path</code> has value selection filter with no sub-attribute specified, and provided value is not a list of values (like for multi-valued attribute), but single entry. Then the returned attribute is the copy of original attribute with <code>multi_valued</code> property set to <code>False</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>When <code>path</code> targets attribute that does not exist in the supported schema.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; user = UserSchema()\n&gt;&gt;&gt; patch_op = PatchOpSchema(user)\n&gt;&gt;&gt; patch_op.get_value_schema(None)\n&lt;scimpler.schemas.user.UserSchema at 0x7f1f6c193090&gt;\n&gt;&gt;&gt; patch_op.get_value_schema(\"userName\")\nString(userName)\n&gt;&gt;&gt; patch_op.get_value_schema(\n&gt;&gt;&gt;     \"emails[type eq 'work']\",\n&gt;&gt;&gt;     [{\"type\": \"work\", \"value\": \"work@example.com\"}]\n&gt;&gt;&gt; )\nComplex(emails)\n&gt;&gt;&gt; patch_op.get_value_schema(\n&gt;&gt;&gt;     \"emails[type eq 'work']\",\n&gt;&gt;&gt;     [{\"type\": \"work\", \"value\": \"work@example.com\"}]\n&gt;&gt;&gt; ).multi_valued\nTrue\n&gt;&gt;&gt; patch_op.get_value_schema(\n&gt;&gt;&gt;     \"emails[type eq 'work']\",\n&gt;&gt;&gt;     {\"type\": \"work\", \"value\": \"work@example.com\"}\n&gt;&gt;&gt; )\nComplex(emails)\n&gt;&gt;&gt; patch_op.get_value_schema(\n&gt;&gt;&gt;     \"emails[type eq 'work']\",\n&gt;&gt;&gt;     {\"type\": \"work\", \"value\": \"work@example.com\"}\n&gt;&gt;&gt; ).multi_valued\nFalse\n</code></pre> Source code in <code>src/scimpler/schemas/patch_op.py</code> <pre><code>def get_value_schema(\n    self,\n    path: Union[str, PatchPath, None, MissingType],\n    value: Any = None,\n) -&gt; Union[BaseSchema, Attribute]:\n    \"\"\"\n    Returns the supported schema or one of its attributes, depending on the provided `path`\n    and `value`. If `path` is `None` or `Missing`, whole supported schema is returned.\n\n    If `path` is string value, it is deserialized and processed like `PatchPath`. For\n    valid `PatchPath`, the attribute targeted by it is returned. The only exception is when\n    the `path` has value selection filter with no sub-attribute specified, and provided value\n    is not a list of values (like for multi-valued attribute), but single entry. Then the\n    returned attribute is the copy of original attribute with `multi_valued` property set\n    to `False`.\n\n    Raises:\n        ValueError: When `path` targets attribute that does not exist in the supported schema.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; user = UserSchema()\n        &gt;&gt;&gt; patch_op = PatchOpSchema(user)\n        &gt;&gt;&gt; patch_op.get_value_schema(None)\n        &lt;scimpler.schemas.user.UserSchema at 0x7f1f6c193090&gt;\n        &gt;&gt;&gt; patch_op.get_value_schema(\"userName\")\n        String(userName)\n        &gt;&gt;&gt; patch_op.get_value_schema(\n        &gt;&gt;&gt;     \"emails[type eq 'work']\",\n        &gt;&gt;&gt;     [{\"type\": \"work\", \"value\": \"work@example.com\"}]\n        &gt;&gt;&gt; )\n        Complex(emails)\n        &gt;&gt;&gt; patch_op.get_value_schema(\n        &gt;&gt;&gt;     \"emails[type eq 'work']\",\n        &gt;&gt;&gt;     [{\"type\": \"work\", \"value\": \"work@example.com\"}]\n        &gt;&gt;&gt; ).multi_valued\n        True\n        &gt;&gt;&gt; patch_op.get_value_schema(\n        &gt;&gt;&gt;     \"emails[type eq 'work']\",\n        &gt;&gt;&gt;     {\"type\": \"work\", \"value\": \"work@example.com\"}\n        &gt;&gt;&gt; )\n        Complex(emails)\n        &gt;&gt;&gt; patch_op.get_value_schema(\n        &gt;&gt;&gt;     \"emails[type eq 'work']\",\n        &gt;&gt;&gt;     {\"type\": \"work\", \"value\": \"work@example.com\"}\n        &gt;&gt;&gt; ).multi_valued\n        False\n    \"\"\"\n    if not isinstance(path, (str, PatchPath)):\n        return self._resource_schema\n\n    if isinstance(path, str):\n        path_normalized = PatchPath.deserialize(path)\n    else:\n        path_normalized = path\n\n    attr = self._resource_schema.attrs.get_by_path(path_normalized)\n    if attr is None:\n        raise ValueError(f\"target indicated by path {path!r} does not exist\")\n\n    if (\n        value\n        and path_normalized.has_filter\n        and not path_normalized.sub_attr_name\n        and not isinstance(value, list)\n    ):\n        attr = cast(Attribute, copy(attr))\n        attr._multi_valued = False\n        return attr\n    return attr\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/patch_op_schema/#scimpler.schemas.PatchOpSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/","title":"ResourceTypeSchema","text":"<p>               Bases: <code>BaseResourceSchema</code></p> <p>ResourceType schema, identified by <code>urn:ietf:params:scim:schemas:core:2.0:ResourceType</code> URI.</p> <p>The default endpoint is <code>/ResourceTypes</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, **kwargs):\n    super().__init__(**kwargs)\n    self.endpoint = self.endpoint or f\"/{self.name}\"\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.get_repr","title":"<code>get_repr(schema)</code>","text":"<p>Returns the representation of the provided resource <code>schema</code>, compatible with the content returned through <code>/ResourceTypes</code> endpoint.</p> Source code in <code>src/scimpler/schemas/resource_type.py</code> <pre><code>def get_repr(self, schema: ResourceSchema) -&gt; dict[str, Any]:\n    \"\"\"\n    Returns the representation of the provided resource `schema`, compatible with the\n    content returned through `/ResourceTypes` endpoint.\n    \"\"\"\n    return {\n        \"schemas\": self.schemas,\n        \"id\": schema.name,\n        \"name\": schema.name,\n        \"endpoint\": schema.endpoint,\n        \"description\": schema.description,\n        \"schema\": schema.schema,\n        \"schemaExtensions\": [\n            {\n                \"schema\": schema,\n                \"required\": required,\n            }\n            for schema, required in schema.extensions.items()\n        ],\n        \"meta\": {\n            \"location\": f\"{self.endpoint}/{schema.name}\",\n            \"resourceType\": self.name,\n        },\n    }\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    \"\"\"\n    super().include_schema_data(data)\n    if \"meta\" in data:\n        data[\"meta\"][\"resourceType\"] = self.name\n    else:\n        data[\"meta\"] = {\"resourceType\": self.name}\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/resource_type_schema/#scimpler.schemas.ResourceTypeSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/","title":"SchemaDefinitionSchema","text":"<p>               Bases: <code>BaseResourceSchema</code></p> <p>\"Schema\" schema, identified by <code>urn:ietf:params:scim:schemas:core:2.0:Schema</code> URI.</p> <p>Provides data validation and additionally checks if <code>attributes.caseExact</code> is provided when <code>attributes.type</code> is <code>string</code>.</p> <p>The default endpoint is <code>/Schemas</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, **kwargs):\n    super().__init__(**kwargs)\n    self.endpoint = self.endpoint or f\"/{self.name}\"\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.get_repr","title":"<code>get_repr(schema, version=None)</code>","text":"<p>Returns the representation of the provided resource <code>schema</code>, compatible with the content returned through <code>/Schemas</code> endpoint.</p> Source code in <code>src/scimpler/schemas/schema.py</code> <pre><code>def get_repr(\n    self,\n    schema: Union[ResourceSchema, SchemaExtension],\n    version: Optional[str] = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Returns the representation of the provided resource `schema`, compatible with the\n    content returned through `/Schemas` endpoint.\n    \"\"\"\n    attrs = cast(\n        Iterator[tuple[BoundedAttrRep, Attribute]],\n        schema.attrs if isinstance(schema, SchemaExtension) else schema.attrs.core_attrs,\n    )\n    output: dict[str, Any] = {\n        \"id\": schema.schema,\n        \"schemas\": self.schemas,\n        \"name\": schema.name,\n        \"description\": schema.description,\n        \"attributes\": [attr.to_dict() for _, attr in attrs],\n        \"meta\": {\n            \"resourceType\": \"Schema\",\n            \"location\": f\"{self.endpoint}/{schema.schema}\",\n        },\n    }\n    if version:\n        output[\"meta\"][\"version\"] = version\n    return output\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    \"\"\"\n    super().include_schema_data(data)\n    if \"meta\" in data:\n        data[\"meta\"][\"resourceType\"] = self.name\n    else:\n        data[\"meta\"] = {\"resourceType\": self.name}\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/schema_definition_schema/#scimpler.schemas.SchemaDefinitionSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/","title":"SearchRequestSchema","text":"<p>               Bases: <code>BaseSchema</code></p> <p>SearchRequest schema, identified by <code>urn:ietf:params:scim:api:messages:2.0:SearchRequest</code> URI.</p> <p>Provides data validation and additionally checks if <code>attributes</code> and <code>excludedAttributes</code> are not passed together.</p> <p>During deserialization:</p> <ul> <li><code>attributes</code> or <code>excludedAttributes</code> are deserialized to <code>AttrRep</code> instances,</li> <li><code>startIndex</code> is set to 1 if value is lower than 1,</li> <li><code>count</code> is set to 0 if value is lower than 0.</li> </ul> <p>During serialization:</p> <ul> <li><code>attributes</code> or <code>excludedAttributes</code> are serialized from <code>AttrRep</code> to string values,</li> <li><code>startIndex</code> is set to 1 if value is lower than 1,</li> <li><code>count</code> is set to 0 if value is lower than 0.</li> </ul> Source code in <code>src/scimpler/schemas/search_request.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    super().__init__(attr_filter=attr_filter)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.from_config","title":"<code>from_config(config=None)</code>  <code>classmethod</code>","text":"<p>Creates <code>SearchRequestSchema</code> from the <code>config</code>. If <code>config</code> is not provided, the registered configuration is used.</p> Source code in <code>src/scimpler/schemas/search_request.py</code> <pre><code>@classmethod\ndef from_config(\n    cls, config: Optional[scimpler.config.ServiceProviderConfig] = None\n) -&gt; \"SearchRequestSchema\":\n    \"\"\"\n    Creates `SearchRequestSchema` from the `config`. If `config` is not provided, the\n    registered configuration is used.\n    \"\"\"\n    exclude = set()\n    config = config or scimpler.config.service_provider_config\n    if not config.filter.supported:\n        exclude.add(AttrName(\"filter\"))\n    if not config.sort.supported:\n        exclude.add(AttrName(\"sortBy\"))\n        exclude.add(AttrName(\"sortOrder\"))\n    return cls(attr_filter=AttrFilter(attr_reps=exclude, include=False))\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes the <code>schemas</code> attribute value in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes the `schemas` attribute value in the provided `data`.\n    \"\"\"\n    data[\"schemas\"] = [self.schema]\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/search_request_schema/#scimpler.schemas.SearchRequestSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/","title":"ServiceProviderConfigSchema","text":"<p>               Bases: <code>BaseResourceSchema</code></p> <p>ServiceProviderConfig schema, identified by <code>urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig</code> URI.</p> <p>The default endpoint is <code>/ServiceProviderConfig</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, **kwargs):\n    super().__init__(**kwargs)\n    self.endpoint = self.endpoint or f\"/{self.name}\"\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>All schema URIs by which the schema is identified.</p>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    \"\"\"\n    super().include_schema_data(data)\n    if \"meta\" in data:\n        data[\"meta\"][\"resourceType\"] = self.name\n    else:\n        data[\"meta\"] = {\"resourceType\": self.name}\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/service_provider_config_schema/#scimpler.schemas.ServiceProviderConfigSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/","title":"UserSchema","text":"<p>               Bases: <code>ResourceSchema</code></p> <p>User schema, identified by <code>urn:ietf:params:scim:schemas:core:2.0:User</code> URI.</p> <p>Provides data validation and checks if:</p> <ul> <li>the <code>preferredLanguage</code> syntax is correct,</li> <li>the <code>locale</code> syntax is correct,</li> <li>the <code>emails.value</code> syntax is correct,</li> <li>the <code>phoneNumbers.value</code> syntax is correct,</li> <li>the <code>country</code> syntax is correct.</li> </ul> <p>During (de)serialization, <code>ims.value</code> is processed in a way that blank characters are removed.</p> PARAMETER DESCRIPTION <code>attr_filter</code> <p>Attribute filter used to filter attributes defined in class-level <code>base_attrs</code> attribute. Useful for creating different schemas, e.g. with only \"readWrite\" attributes, so serialization and deserialization also filter the data.</p> <p> TYPE: <code>Optional[AttrFilter]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def __init__(self, attr_filter: Optional[AttrFilter] = None):\n    \"\"\"\n    Args:\n        attr_filter: Attribute filter used to filter attributes defined in class-level\n            `base_attrs` attribute. Useful for creating different schemas, e.g. with\n            only \"readWrite\" attributes, so serialization and deserialization also\n            filter the data.\n    \"\"\"\n    register_resource_schema(self)\n    self.plural_name = getattr(self, \"plural_name\", self.name)\n    self.endpoint = self.endpoint or f\"/{self.plural_name}\"\n    self._common_attrs = [\"id\", \"externalId\", \"meta\"]\n    super().__init__(attr_filter=attr_filter, common_attrs=self._common_attrs)\n    self._schema_extensions: dict[str, dict] = {}\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.attrs","title":"<code>attrs: BoundedAttrs</code>  <code>property</code>","text":"<p>Attributes that belong to the schema.</p>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.extensions","title":"<code>extensions: dict[SchemaUri, bool]</code>  <code>property</code>","text":"<p>Extensions added to the schema. Map containing schema extension URIs and flags indicating whether they are required extensions.</p>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.schemas","title":"<code>schemas: list[SchemaUri]</code>  <code>property</code>","text":"<p>Schema URIs by which the schema is identified. Includes schema extension URIs.</p>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.clone","title":"<code>clone(attr_filter)</code>","text":"<p>Clones the schema with attributes filtered with the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def clone(self, attr_filter: AttrFilter) -&gt; Self:\n    \"\"\"\n    Clones the schema with attributes filtered with the provided `attr_filter`.\n    \"\"\"\n    cloned = copy(self)\n    cloned._attrs = self._attrs.clone(attr_filter, ignore_filter=[\"schemas\"])\n    return cloned\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.deserialize","title":"<code>deserialize(data)</code>","text":"<p>Deserializes the provided data according to the schema attributes and their deserialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def deserialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Deserializes the provided data according to the schema attributes and their deserialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    deserialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            deserialized.set(attr_rep, attr.deserialize(value))\n    return self._deserialize(deserialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.extend","title":"<code>extend(extension, required=False)</code>","text":"<p>Extends the base schema with the provided schema <code>extension</code>. Extension attributes become part of the schema and are available in <code>ResourceSchema.attrs</code>.</p> PARAMETER DESCRIPTION <code>extension</code> <p>Schema extension which extends the base schema.</p> <p> TYPE: <code>SchemaExtension</code> </p> <code>required</code> <p>Flag indicating whether the extension is required. If the extension is required, all required fields from the extension become required in base schema during presence checks. If the extension is not required and some of its attributes are required, they are not considered required in the base schema.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def extend(self, extension: \"SchemaExtension\", required: bool = False) -&gt; None:\n    \"\"\"\n    Extends the base schema with the provided schema `extension`. Extension attributes\n    become part of the schema and are available in `ResourceSchema.attrs`.\n\n    Args:\n        extension: Schema extension which extends the base schema.\n        required: Flag indicating whether the extension is required. If the extension\n            is required, all required fields from the extension become required in base\n            schema during presence checks. If the extension is not required and some of\n            its attributes are required, they are not considered required in the base schema.\n    \"\"\"\n    if extension.schema in self.schemas:\n        raise ValueError(f\"schema {extension.schema!r} already in {self.name!r} resource\")\n    if extension.name.lower() in self._schema_extensions:\n        raise RuntimeError(f\"extension {extension.name!r} already in resource\")\n    self._schema_extensions[extension.name.lower()] = {\n        \"extension\": extension,\n        \"required\": required,\n    }\n    for attr_rep, attr in extension.attrs:\n        if (\n            self.attrs.get(BoundedAttrRep(schema=self.schema, attr=attr_rep.attr)) is not None\n            or attr_rep.attr in self._common_attrs\n        ):\n            warnings.warn(\n                message=(\n                    f\"Resource extension {extension.name!r} defines {attr_rep.attr!r} \"\n                    f\"attribute, which is also present in base {self.name!r} schema.\"\n                ),\n                category=ScimpleUserWarning,\n            )\n    self._attrs.extend(\n        schema=cast(SchemaUri, extension.schema),\n        attrs=extension.attrs,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.filter","title":"<code>filter(data, attr_filter)</code>","text":"<p>Filters the provided data according to the provided <code>attr_filter</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def filter(self, data: Mapping[str, Any], attr_filter: AttrFilter) -&gt; ScimData:\n    \"\"\"\n    Filters the provided data according to the provided `attr_filter`.\n    \"\"\"\n    data = ScimData(data)\n    filtered = ScimData()\n    for attr_rep, attr in attr_filter(self.attrs):\n        value = data.get(attr_rep)\n        if value is Missing:\n            continue\n        if isinstance(attr, Complex):\n            value = attr.filter(value, AttrFilter())\n        filtered.set(attr_rep, value)\n    return filtered\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.include_schema_data","title":"<code>include_schema_data(data)</code>","text":"<p>Includes <code>schemas</code> and <code>meta.resourceType</code> attribute values in the provided <code>data</code>. The exact content of <code>schemas</code> depends on the rest of the data. If the data contains attributes from the extensions, the extension URIs appear in the attached <code>schemas</code>.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def include_schema_data(self, data: MutableMapping) -&gt; None:\n    \"\"\"\n    Includes `schemas` and `meta.resourceType` attribute values in the provided `data`.\n    The exact content of `schemas` depends on the rest of the data. If the data contains\n    attributes from the extensions, the extension URIs appear in the attached `schemas`.\n    \"\"\"\n    super().include_schema_data(data)\n    scim_data = ScimData(data)\n    for extension, extension_attrs in self.attrs.extensions.items():\n        for attr_rep, _ in extension_attrs:\n            if attr_rep in scim_data:\n                data[\"schemas\"].append(str(extension))\n                break\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.serialize","title":"<code>serialize(data)</code>","text":"<p>Serializes the provided data according to the schema attributes and their serialization logic. Unknown attributes are not included in the result.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def serialize(self, data: Mapping[str, Any]) -&gt; ScimData:\n    \"\"\"\n    Serializes the provided data according to the schema attributes and their serialization\n    logic. Unknown attributes are not included in the result.\n    \"\"\"\n    data = ScimData(data)\n    serialized = ScimData()\n    for attr_rep, attr in self.attrs:\n        value = data.get(attr_rep)\n        if value is not Missing:\n            serialized.set(attr_rep, attr.serialize(value))\n    return self._serialize(serialized)\n</code></pre>"},{"location":"api_reference/scimpler_schemas/user_schema/#scimpler.schemas.UserSchema.validate","title":"<code>validate(data, presence_config=None, **kwargs)</code>","text":"<p>Validates the provided data according to the schema attributes configuration.</p> <p>In addition, it validates <code>schemas</code> attribute:</p> <ul> <li>if there are no duplicates,</li> <li>if base schema is included,</li> <li>if all provided schemas are known.</li> </ul> <p>Optionally, one can pass <code>AttrValuePresenceConfig</code>, so attribute requiredness, returnability, and issuer is checked, depending on the data flow direction.</p> <p>Extended built-in validation logic is supplied with <code>_validate</code> method, implemented in subclasses.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to be validated.</p> <p> TYPE: <code>Mapping[str, Any]</code> </p> <code>presence_config</code> <p>Presence config that enables additional validation of correctness of values presence.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional parameters passed to <code>_validate</code> method.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/data/schemas.py</code> <pre><code>def validate(\n    self,\n    data: Mapping[str, Any],\n    presence_config: Optional[AttrValuePresenceConfig] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the provided data according to the schema attributes configuration.\n\n    In addition, it validates `schemas` attribute:\n\n    - if there are no duplicates,\n    - if base schema is included,\n    - if all provided schemas are known.\n\n    Optionally, one can pass `AttrValuePresenceConfig`, so attribute requiredness,\n    returnability, and issuer is checked, depending on the data flow direction.\n\n    Extended built-in validation logic is supplied with `_validate` method, implemented\n    in subclasses.\n\n    Args:\n        data: The data to be validated.\n        presence_config: Presence config that enables additional validation of correctness\n            of values presence.\n        **kwargs: Additional parameters passed to `_validate` method.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    data = ScimData(data)\n    issues.merge(self._validate_data(data, presence_config))\n\n    if data.get(\"schemas\"):\n        issues.merge(\n            self._validate_schemas_field(data),\n            location=[\"schemas\"],\n        )\n    issues.merge(self._validate(data, **kwargs))\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/bulk_operations/","title":"BulkOperations","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP POST operations performed against bulk endpoint.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schemas</code> <p>Resource schemas associated with the validator.</p> <p> TYPE: <code>Sequence[ResourceSchema]</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If <code>bulk</code> operation is not supported in the service provider configuration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = BulkOperations(resource_schemas=[UserSchema(), GroupSchema()])\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schemas: Sequence[ResourceSchema],\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schemas: Resource schemas associated with the validator.\n\n    Raises:\n        RuntimeError: If `bulk` operation is not supported in the service provider\n            configuration.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; validator = BulkOperations(resource_schemas=[UserSchema(), GroupSchema()])\n    \"\"\"\n    super().__init__(config)\n    if not self.config.bulk.supported:\n        raise RuntimeError(\"bulk operations are not configured\")\n    self._validators: dict[str, dict[str, Validator]] = {\n        \"GET\": {},\n        \"POST\": {},\n        \"PUT\": {},\n        \"PATCH\": {},\n        \"DELETE\": {},\n    }\n    response_schemas: dict[str, dict[str, Optional[BaseSchema]]] = {\n        \"GET\": {},\n        \"POST\": {},\n        \"PUT\": {},\n        \"PATCH\": {},\n        \"DELETE\": {},\n    }\n    request_schemas: dict[str, dict[str, Optional[BaseSchema]]] = {\n        \"GET\": {},\n        \"POST\": {},\n        \"PUT\": {},\n        \"PATCH\": {},\n        \"DELETE\": {},\n    }\n    for resource_schema in resource_schemas:\n        get = ResourceObjectGet(self.config, resource_schema=resource_schema)\n        self._validators[\"GET\"][resource_schema.endpoint] = get\n        response_schemas[\"GET\"][resource_schema.endpoint] = get.response_schema\n        request_schemas[\"GET\"][resource_schema.endpoint] = None\n\n        post = ResourcesPost(self.config, resource_schema=resource_schema)\n        self._validators[\"POST\"][resource_schema.endpoint] = post\n        response_schemas[\"POST\"][resource_schema.endpoint] = post.response_schema\n        request_schemas[\"POST\"][resource_schema.endpoint] = post.request_schema\n\n        put = ResourceObjectPut(self.config, resource_schema=resource_schema)\n        self._validators[\"PUT\"][resource_schema.endpoint] = put\n        response_schemas[\"PUT\"][resource_schema.endpoint] = put.response_schema\n        request_schemas[\"PUT\"][resource_schema.endpoint] = put.request_schema\n\n        patch = ResourceObjectPatch(self.config, resource_schema=resource_schema)\n        self._validators[\"PATCH\"][resource_schema.endpoint] = patch\n        response_schemas[\"PATCH\"][resource_schema.endpoint] = patch.response_schema\n        request_schemas[\"PATCH\"][resource_schema.endpoint] = patch.request_schema\n\n        delete = ResourceObjectDelete(self.config)\n        self._validators[\"DELETE\"][resource_schema.endpoint] = delete\n        response_schemas[\"DELETE\"][resource_schema.endpoint] = None\n        request_schemas[\"DELETE\"][resource_schema.endpoint] = None\n\n    self._error_validator = Error()\n    self._request_schema = BulkRequestSchema(sub_schemas=request_schemas)\n    self._response_schema = BulkResponseSchema(\n        sub_schemas=response_schemas,\n        error_schema=self._error_validator.response_schema,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations.request_schema","title":"<code>request_schema: BulkRequestSchema</code>  <code>property</code>","text":"<p>Schema designed for request (de)serialization. Schemas for <code>data</code> attribute values are the same as request schemas in validators, corresponding to the bulk operations.</p>"},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations.response_schema","title":"<code>response_schema: BulkResponseSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Schemas for <code>response</code> attribute values are the same as response schemas in validators, corresponding to the bulk operations.</p>"},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations.validate_request","title":"<code>validate_request(body=None)</code>","text":"<p>Validates the HTTP POST requests performed against bulk endpoint.</p> <p>Except for body validation done by the inner <code>BulkRequestSchema</code>, the validator checks if:</p> <ul> <li>number of <code>Operations</code> does not exceed configured maximum number of operations,</li> <li>correct data for operations is provided,</li> </ul> PARAMETER DESCRIPTION <code>body</code> <p>Request body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_request(self, body: Optional[Mapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP POST** requests performed against bulk endpoint.\n\n    Except for body validation done by the inner `BulkRequestSchema`, the validator checks if:\n\n    - number of `Operations` does not exceed configured maximum number of operations,\n    - correct data for operations is provided,\n\n    Args:\n        body: Request body.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    body_location = (\"body\",)\n    normalized = ScimData(body or {})\n    issues.merge(\n        self._request_schema.validate(normalized, AttrValuePresenceConfig(\"REQUEST\")),\n        location=body_location,\n    )\n    if not normalized.get(self._request_schema.attrs.operations):\n        return issues\n\n    if (\n        isinstance(self.config.bulk.max_operations, int)\n        and len(normalized.get(self._request_schema.attrs.operations))\n        &gt; self.config.bulk.max_operations\n    ):\n        issues.add_error(\n            issue=ValidationError.too_many_bulk_operations(self.config.bulk.max_operations),\n            proceed=True,\n            location=body_location + self._response_schema.attrs.operations.location,\n        )\n\n    data_rep = self._request_schema.attrs.operations__data\n    paths = normalized.get(self._request_schema.attrs.operations__path)\n    data = normalized.get(self._request_schema.attrs.operations__data)\n    methods = normalized.get(self._request_schema.attrs.operations__method)\n    for i, (path, data_item, method) in enumerate(zip(paths, data, methods)):\n        if not all([path, data_item, method]) or method == \"DELETE\":\n            continue\n        if method == \"POST\":\n            resource_type_endpoint = path\n        else:\n            resource_type_endpoint = f\"/{path.split('/', 2)[1]}\"\n        validator = cast(Validator, self._validators[method].get(resource_type_endpoint))\n        issues_ = validator.validate_request(body=data_item)\n        data_item_location = body_location + (data_rep.attr, i, data_rep.sub_attr)\n        issues.merge(issues_.get(location=[\"body\"]), location=data_item_location)\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/bulk_operations/#scimpler.validator.BulkOperations.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP POST responses returned from bulk endpoint.</p> <p>Except for body validation done by the inner <code>BulkResponseSchema</code>, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li>correct error responses are returned for statuses greater or equal to 300,</li> <li>correct responses are returned for successful completions,</li> <li>if <code>meta.location</code> matches <code>Operations.location</code> for every operation,</li> <li>if <code>meta.version</code> matches <code>Operations.version</code> for every operation,</li> <li>if number of unsuccessful completions did not exceed <code>fail_on_errors</code> parameter.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Not used.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>fail_on_errors</code> <p>An integer specifying the number of errors that the service provider should accept before the operation is terminated.</p> <p> TYPE: <code>Optional[int]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP POST** responses returned from bulk endpoint.\n\n    Except for body validation done by the inner `BulkResponseSchema`, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - correct error responses are returned for statuses greater or equal to 300,\n    - correct responses are returned for successful completions,\n    - if `meta.location` matches `Operations.location` for every operation,\n    - if `meta.version` matches `Operations.version` for every operation,\n    - if number of unsuccessful completions did not exceed `fail_on_errors` parameter.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Not used.\n\n    Keyword Args:\n        fail_on_errors (Optional[int]): An integer specifying the number of errors that the\n            service provider should accept before the operation is terminated.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    normalized = ScimData(body or {})\n    body_location = (\"body\",)\n    issues.merge(\n        self._response_schema.validate(normalized, AttrValuePresenceConfig(\"RESPONSE\")),\n        location=body_location,\n    )\n    issues.merge(\n        issues=_validate_status_code(200, status_code),\n        location=[\"status\"],\n    )\n    operations = normalized.get(\"Operations\")\n    if operations is Invalid:\n        return issues\n\n    operations_location = body_location + self._response_schema.attrs.operations.location\n    for i, operation in enumerate(operations):\n        issues.merge(\n            issues=self._validate_response_operation(operation, (*operations_location, i)),\n        )\n    n_errors = 0\n    for operation in operations:\n        status = operation.get(\"status\")\n        if not status:\n            if self._error_validator.response_schema.schemas == operation.get(\n                \"response.schemas\"\n            ):\n                n_errors += 1\n            continue\n\n        if int(status) &gt;= 300:\n            n_errors += 1\n    fail_on_errors = kwargs.get(\"fail_on_errors\")\n    if fail_on_errors is not None and n_errors &gt; fail_on_errors:\n        issues.add_error(\n            issue=ValidationError.too_many_errors_in_bulk(fail_on_errors),\n            proceed=True,\n            location=operations_location,\n        )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/error/","title":"Error","text":"<p>               Bases: <code>Validator</code></p> <p>Error validator, designed to validate any SCIM errors.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(self):\n    super().__init__(None)\n    self._schema = ErrorSchema()\n</code></pre>"},{"location":"api_reference/scimpler_validator/error/#scimpler.validator.Error-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/error/#scimpler.validator.Error.response_schema","title":"<code>response_schema: ErrorSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization.</p>"},{"location":"api_reference/scimpler_validator/error/#scimpler.validator.Error-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/error/#scimpler.validator.Error.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the error response.</p> <p>Except for error body validation done by the inner schema, the validator checks if:</p> <ul> <li><code>status</code> in body matches the provided <code>status_code</code>,</li> <li>value of <code>status_code</code> is in range: 300 &lt;= status_code &lt; 600.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned error body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Returned response headers.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Not used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the error response.\n\n    Except for error body validation done by the inner schema, the validator checks if:\n\n    - `status` in body matches the provided `status_code`,\n    - value of `status_code` is in range: 300 &lt;= status_code &lt; 600.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned error body.\n        headers: Returned response headers.\n        **kwargs: Not used.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    body_location = (\"body\",)\n    issues = ValidationIssues()\n    normalized = ScimData(body or {})\n    issues.merge(\n        self.response_schema.validate(normalized, AttrValuePresenceConfig(\"RESPONSE\")),\n        location=body_location,\n    )\n    status_attr_rep = self.response_schema.attrs.status\n    status_location = body_location + status_attr_rep.location\n    if (status_in_body := normalized.get(status_attr_rep)) and str(\n        status_code\n    ) != status_in_body:\n        issues.add_error(\n            issue=ValidationError.must_be_equal_to(\"response status code\"),\n            location=status_location,\n            proceed=True,\n        )\n        issues.add_error(\n            issue=ValidationError.must_be_equal_to(\"'status' attribute\"),\n            location=[\"status\"],\n            proceed=True,\n        )\n    if not 300 &lt;= status_code &lt; 600:\n        issues.add_error(\n            issue=ValidationError.bad_value_content(),\n            location=[\"status\"],\n            proceed=True,\n        )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_delete/","title":"ResourceObjectDelete","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP DELETE operations performed against resource object endpoints.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(self, config: Optional[scimpler.config.ServiceProviderConfig] = None):\n    self.config = config or scimpler.config.service_provider_config\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_delete/#scimpler.validator.ResourceObjectDelete-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resource_object_delete/#scimpler.validator.ResourceObjectDelete.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP DELETE responses returned from resource object endpoints.</p> <p>It only validates if provided <code>status_code</code> equals 204.</p> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Not used.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Not Used.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Not used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP DELETE** responses returned from **resource object** endpoints.\n\n    It only validates if provided `status_code` equals 204.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Not used.\n        headers: Not Used.\n        **kwargs: Not used.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    if status_code != 204:\n        issues.add_error(\n            issue=ValidationError.bad_status_code(204),\n            proceed=True,\n            location=[\"status\"],\n        )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_get/","title":"ResourceObjectGet","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP GET operations performed against resource object endpoints.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema associated with the validator.</p> <p> TYPE: <code>BaseResourceSchema</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = ResourceObjectGet(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: BaseResourceSchema,\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema associated with the validator.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; validator = ResourceObjectGet(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config)\n    self._schema = resource_schema\n    self._response_schema = resource_schema.clone(_resource_output_filter)\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_get/#scimpler.validator.ResourceObjectGet-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/resource_object_get/#scimpler.validator.ResourceObjectGet.response_schema","title":"<code>response_schema: BaseResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Contains attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>.</p>"},{"location":"api_reference/scimpler_validator/resource_object_get/#scimpler.validator.ResourceObjectGet-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resource_object_get/#scimpler.validator.ResourceObjectGet.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP GET responses returned from resource object endpoints.</p> <p>Except for body validation done by the inner schema, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li><code>Location</code> header matches <code>meta.location</code> from body, if header is provided,</li> <li><code>ETag</code> header is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>meta.version</code> is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>ETag</code> header matches <code>meta.version</code> when both are provided.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Returned response headers.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP GET** responses returned from **resource object** endpoints.\n\n    Except for body validation done by the inner schema, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - `Location` header matches `meta.location` from body, if header is provided,\n    - `ETag` header is provided if `etag` is enabled in the service provider configuration,\n    - `meta.version` is provided if `etag` is enabled in the service provider configuration,\n    - `ETag` header matches `meta.version` when both are provided.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Returned response headers.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    return _validate_resource_output_body(\n        schema=self._schema,\n        config=self.config,\n        location_header_required=False,\n        expected_status_code=200,\n        status_code=status_code,\n        body=ScimData(body or {}),\n        headers=headers or {},\n        presence_config=kwargs.get(\"presence_config\"),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_patch/","title":"ResourceObjectPatch","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP PATCH operations performed against resource object endpoints.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema associated with the validator.</p> <p> TYPE: <code>ResourceSchema</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If <code>patch</code> operation is not supported in the service provider configuration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = ResourceObjectPatch(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: ResourceSchema,\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema associated with the validator.\n\n    Raises:\n        RuntimeError: If `patch` operation is not supported in the service provider\n            configuration.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; validator = ResourceObjectPatch(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config)\n    if not self.config.patch.supported:\n        raise RuntimeError(\"patch operation is not supported\")\n    self._schema = PatchOpSchema(resource_schema)\n    self._request_schema = PatchOpSchema(\n        resource_schema.clone(\n            attr_filter=AttrFilter(\n                filter_=lambda attr: attr.mutability != AttributeMutability.READ_ONLY,\n            )\n        )\n    )\n    self._resource_schema = resource_schema\n    self._response_schema = resource_schema.clone(_resource_output_filter)\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch.request_schema","title":"<code>request_schema: PatchOpSchema</code>  <code>property</code>","text":"<p>Schema designed for request (de)serialization. Contains attributes whose <code>mutability</code> differs from <code>readOnly</code>.</p>"},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch.response_schema","title":"<code>response_schema: ResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Contains attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>.</p>"},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch.validate_request","title":"<code>validate_request(body=None)</code>","text":"<p>Validates the HTTP PATCH requests sent to resource object endpoints.</p> <p>Performs request body validation using inner <code>PatchOpSchema</code>, including attribute presence validation.</p> PARAMETER DESCRIPTION <code>body</code> <p>The request body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_request(self, body: Optional[Mapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP PATCH** requests sent to **resource object** endpoints.\n\n    Performs request body validation using inner `PatchOpSchema`, including attribute presence\n    validation.\n\n    Args:\n        body: The request body.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    normalized = ScimData(body or {})\n    issues.merge(\n        self._schema.validate(normalized, AttrValuePresenceConfig(\"REQUEST\")),\n        location=[\"body\"],\n    )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_patch/#scimpler.validator.ResourceObjectPatch.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP PATCH responses returned from resource object endpoints.</p> <p>Except for body validation done by the inner schema, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 204 if body is not returned, or 200, if body is returned     or <code>AttrValuePresenceConfig</code> is specified,</li> <li><code>Location</code> header matches <code>meta.location</code> from body, if header is provided,</li> <li><code>ETag</code> header is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>meta.version</code> is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>ETag</code> header matches <code>meta.version</code> when both are provided.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Returned response headers.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP PATCH** responses returned from **resource object** endpoints.\n\n    Except for body validation done by the inner schema, the validator checks if:\n\n    - returned `status_code` equals 204 if body is not returned, or 200, if body is returned\n        or `AttrValuePresenceConfig` is specified,\n    - `Location` header matches `meta.location` from body, if header is provided,\n    - `ETag` header is provided if `etag` is enabled in the service provider configuration,\n    - `meta.version` is provided if `etag` is enabled in the service provider configuration,\n    - `ETag` header matches `meta.version` when both are provided.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Returned response headers.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    presence_config = kwargs.get(\"presence_config\")\n    if status_code == 204:\n        if body is not None or presence_config is not None and presence_config.attr_reps:\n            issues.add_error(\n                issue=ValidationError.bad_status_code(200),\n                proceed=True,\n                location=(\"status\",),\n            )\n        return issues\n    return _validate_resource_output_body(\n        schema=self._resource_schema,\n        config=self.config,\n        location_header_required=False,\n        expected_status_code=200,\n        status_code=status_code,\n        body=ScimData(body or {}),\n        headers=headers or {},\n        presence_config=presence_config,\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_put/","title":"ResourceObjectPut","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP PUT operations performed against resource object endpoints.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema associated with the validator.</p> <p> TYPE: <code>ResourceSchema</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = ResourceObjectPut(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: ResourceSchema,\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema associated with the validator.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; validator = ResourceObjectPut(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config)\n    self._request_schema = resource_schema.clone(\n        attr_filter=AttrFilter(\n            filter_=lambda attr: (\n                attr.mutability != AttributeMutability.READ_ONLY or attr.required\n            ),\n        )\n    )\n    self._response_schema = resource_schema.clone(_resource_output_filter)\n    self._schema = resource_schema\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut.request_schema","title":"<code>request_schema: ResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for request (de)serialization. Contains attributes whose <code>mutability</code> differs from <code>readOnly</code> or are required.</p>"},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut.response_schema","title":"<code>response_schema: ResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Contains attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>.</p>"},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut.validate_request","title":"<code>validate_request(body=None)</code>","text":"<p>Validates the HTTP PUT requests sent to resource object endpoints.</p> <p>Performs request body validation using inner resource schema, including attribute presence validation that checks if all required attributes are provided (regardless the issuer).</p> PARAMETER DESCRIPTION <code>body</code> <p>The request body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_request(self, body: Optional[Mapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP PUT** requests sent to **resource object** endpoints.\n\n    Performs request body validation using inner resource schema, including attribute presence\n    validation that checks if all required attributes are provided (regardless the issuer).\n\n    Args:\n        body: The request body.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    issues.merge(\n        issues=self._schema.validate(\n            data=body or {},\n            presence_config=AttrValuePresenceConfig(\n                \"REQUEST\",\n                ignore_issuer=[\n                    attr_rep for attr_rep, attr in self._schema.attrs if attr.required\n                ],\n            ),\n        ),\n        location=[\"body\"],\n    )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resource_object_put/#scimpler.validator.ResourceObjectPut.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP PUT responses returned from resource object endpoints.</p> <p>Except for body validation done by inner schema, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li><code>Location</code> header matches <code>meta.location</code> from body, if header is provided,</li> <li><code>ETag</code> header is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>meta.version</code> is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>ETag</code> header matches <code>meta.version</code> when both are provided.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Returned response headers.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP PUT** responses returned from **resource object** endpoints.\n\n    Except for body validation done by inner schema, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - `Location` header matches `meta.location` from body, if header is provided,\n    - `ETag` header is provided if `etag` is enabled in the service provider configuration,\n    - `meta.version` is provided if `etag` is enabled in the service provider configuration,\n    - `ETag` header matches `meta.version` when both are provided.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Returned response headers.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    return _validate_resource_output_body(\n        schema=self._schema,\n        config=self.config,\n        location_header_required=False,\n        expected_status_code=200,\n        status_code=status_code,\n        body=ScimData(body or {}),\n        headers=headers or {},\n        presence_config=kwargs.get(\"presence_config\"),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/resources_post/","title":"ResourcesPost","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP POST operations performed against resource type endpoints.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema associated with the validator.</p> <p> TYPE: <code>ResourceSchema</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; validator = ResourcesPost(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: ResourceSchema,\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema associated with the validator.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; validator = ResourcesPost(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config)\n    self._schema = resource_schema\n    self._request_schema = resource_schema.clone(\n        attr_filter=AttrFilter(\n            filter_=lambda attr: (\n                attr.mutability != AttributeMutability.READ_ONLY\n                and attr.issuer != AttributeIssuer.SERVICE_PROVIDER\n            )\n        )\n    )\n    self._response_schema = resource_schema.clone(_resource_output_filter)\n</code></pre>"},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost.request_schema","title":"<code>request_schema: ResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for request (de)serialization. Contains attributes whose <code>mutability</code> differs from <code>readOnly</code>, and which are not issued by the service provider.</p>"},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost.response_schema","title":"<code>response_schema: ResourceSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Contains attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>.</p>"},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost.validate_request","title":"<code>validate_request(body=None)</code>","text":"<p>Validates the HTTP POST requests sent to resource type endpoints.</p> <p>Performs request body validation using inner resource schema, including attribute presence validation that checks if:</p> <ul> <li>attributes issued by the service provider are not provided,</li> <li>required attribute are provided.</li> </ul> PARAMETER DESCRIPTION <code>body</code> <p>The request body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_request(self, body: Optional[Mapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP POST** requests sent to **resource type** endpoints.\n\n    Performs request body validation using inner resource schema, including attribute presence\n    validation that checks if:\n\n    - attributes issued by the service provider are not provided,\n    - required attribute are provided.\n\n    Args:\n        body: The request body.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    normalized = ScimData(body or {})\n    issues.merge(\n        issues=self._schema.validate(normalized, AttrValuePresenceConfig(\"REQUEST\")),\n        location=[\"body\"],\n    )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resources_post/#scimpler.validator.ResourcesPost.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP POST responses returned from resource type endpoints.</p> <p>Except for body validation (if provided) done by the inner schema, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li><code>Location</code> header is provided,</li> <li><code>Location</code> header matches <code>meta.location</code> from body,</li> <li><code>ETag</code> header is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>meta.version</code> is provided if <code>etag</code> is enabled in the service provider configuration,</li> <li><code>ETag</code> header matches <code>meta.version</code> when both are provided,</li> <li><code>meta.created</code> equals <code>meta.lastModified</code>.</li> </ul> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Returned response headers.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP POST** responses returned from **resource type** endpoints.\n\n    Except for body validation (if provided) done by the inner schema, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - `Location` header is provided,\n    - `Location` header matches `meta.location` from body,\n    - `ETag` header is provided if `etag` is enabled in the service provider configuration,\n    - `meta.version` is provided if `etag` is enabled in the service provider configuration,\n    - `ETag` header matches `meta.version` when both are provided,\n    - `meta.created` equals `meta.lastModified`.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Returned response headers.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    if not body:\n        issues.add_warning(issue=ValidationWarning.missing(), location=[\"body\"])\n        return issues\n\n    normalized = ScimData(body)\n    issues = _validate_resource_output_body(\n        schema=self._schema,\n        config=self.config,\n        location_header_required=True,\n        expected_status_code=201,\n        status_code=status_code,\n        body=normalized,\n        headers=headers or {},\n        presence_config=kwargs.get(\"presence_config\"),\n    )\n    if normalized.get(self._schema.attrs.meta__created) != normalized.get(\n        self._schema.attrs.meta__lastModified\n    ):\n        issues.add_error(\n            issue=ValidationError.must_be_equal_to(\"'meta.created'\"),\n            proceed=True,\n            location=(\"body\", *self._schema.attrs.meta__lastModified.location),\n        )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/resources_query/","title":"ResourcesQuery","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for HTTP GET operations performed against resource type endpoints. It is able to handle different schemas in the same time, so can be used in resource root endpoint.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema(s) associated with the validator.</p> <p> TYPE: <code>Union[Sequence[BaseResourceSchema], BaseResourceSchema]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; # for resource root endpoint\n&gt;&gt;&gt; root_validator = ResourcesQuery(resource_schema=[UserSchema(), GroupSchema()])\n&gt;&gt;&gt; # for specific resource type endpoint\n&gt;&gt;&gt; validator = ResourcesQuery(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: Union[Sequence[BaseResourceSchema], BaseResourceSchema],\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema(s) associated with the validator.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # for resource root endpoint\n        &gt;&gt;&gt; root_validator = ResourcesQuery(resource_schema=[UserSchema(), GroupSchema()])\n        &gt;&gt;&gt; # for specific resource type endpoint\n        &gt;&gt;&gt; validator = ResourcesQuery(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config)\n    if isinstance(resource_schema, BaseResourceSchema):\n        resource_schema = [resource_schema]\n    self._response_validation_schema = ListResponseSchema(resource_schema)\n    self._response_schema = ListResponseSchema(\n        [item.clone(_resource_output_filter) for item in resource_schema]\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/resources_query/#scimpler.validator.ResourcesQuery-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/resources_query/#scimpler.validator.ResourcesQuery.response_schema","title":"<code>response_schema: ListResponseSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Resource schemas contain attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>. ListResponse schema contains all attributes.</p>"},{"location":"api_reference/scimpler_validator/resources_query/#scimpler.validator.ResourcesQuery-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/resources_query/#scimpler.validator.ResourcesQuery.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP GET responses returned from resource type endpoints.</p> <p>Except for body validation done by the inner <code>ListResponseSchema</code>, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li><code>startIndex</code> in the body is lesser or equal to the provided <code>start_index</code>,</li> <li><code>totalResults</code> greater or equal to number of <code>Resources</code>,</li> <li><code>totalResults</code> differs from number of <code>Resources</code> when <code>count</code> is not specified,</li> <li>number of <code>Resources</code> is lesser or equal to the <code>count</code>, if specified,</li> <li><code>startIndex</code> is specified in the body for pagination,</li> <li><code>itemsPerPage</code> is specified in the body for pagination,</li> <li><code>Resources</code> are filtered, according to the provided <code>filter</code>,</li> <li><code>Resources</code> are sorted, according to the provided <code>sorter</code>,</li> <li>every resource contains <code>meta.version</code>, if <code>etag</code> is supported.</li> </ul> <p>Filtering and sorting is not validated if attributes required to check filtering and sorting are meant to be excluded due to <code>AttrValuePresenceConfig</code>.</p> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Not used.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified. Applied on <code>Resources</code> only.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> <code>start_index</code> <p>The 1-based index of the first query result.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>count</code> <p>Specifies the desired number of query results per page.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>filter</code> <p>Filter that was applied on <code>Resources</code>.</p> <p> TYPE: <code>Optional[Filter]</code> </p> <code>sorter</code> <p>Sorter that was applied on <code>Resources</code>.</p> <p> TYPE: <code>Optional[Sorter]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP GET** responses returned from **resource type** endpoints.\n\n    Except for body validation done by the inner `ListResponseSchema`, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - `startIndex` in the body is lesser or equal to the provided `start_index`,\n    - `totalResults` greater or equal to number of `Resources`,\n    - `totalResults` differs from number of `Resources` when `count` is not specified,\n    - number of `Resources` is lesser or equal to the `count`, if specified,\n    - `startIndex` is specified in the body for pagination,\n    - `itemsPerPage` is specified in the body for pagination,\n    - `Resources` are filtered, according to the provided `filter`,\n    - `Resources` are sorted, according to the provided `sorter`,\n    - every resource contains `meta.version`, if `etag` is supported.\n\n    Filtering and sorting is not validated if attributes required to check filtering and\n    sorting are meant to be excluded due to `AttrValuePresenceConfig`.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Not used.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified. Applied on\n            `Resources` only.\n        start_index (Optional[int]): The 1-based index of the first query result.\n        count (Optional[int]): Specifies the desired number of query results per page.\n        filter (Optional[Filter]): Filter that was applied on `Resources`.\n        sorter (Optional[Sorter]): Sorter that was applied on `Resources`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    return _validate_resources_get_response(\n        schema=self._response_validation_schema,\n        config=self.config,\n        status_code=status_code,\n        body=ScimData(body or {}),\n        start_index=kwargs.get(\"start_index\", 1),\n        count=kwargs.get(\"count\"),\n        filter_=kwargs.get(\"filter\"),\n        sorter=kwargs.get(\"sorter\"),\n        resource_presence_config=kwargs.get(\"presence_config\"),\n    )\n</code></pre>"},{"location":"api_reference/scimpler_validator/search_request_post/","title":"SearchRequestPost","text":"<p>               Bases: <code>ResourcesQuery</code></p> <p>Validator for HTTP POST query operations. It is  able to handle different schemas in the same time, so can be used in resource root endpoint.</p> PARAMETER DESCRIPTION <code>config</code> <p>Service provider configuration. If not provided, defaults to <code>scimpler.config.service_provider_config</code></p> <p> TYPE: <code>Optional[ServiceProviderConfig]</code> DEFAULT: <code>None</code> </p> <code>resource_schema</code> <p>Resource schema(s) associated with the validator.</p> <p> TYPE: <code>Union[Sequence[ResourceSchema], ResourceSchema]</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n&gt;&gt;&gt;\n&gt;&gt;&gt; # for resource root endpoint\n&gt;&gt;&gt; root_validator = SearchRequestPost(resource_schema=[UserSchema(), GroupSchema()])\n&gt;&gt;&gt; # for specific resource type endpoint\n&gt;&gt;&gt; validator = SearchRequestPost(resource_schema=UserSchema())\n</code></pre> Source code in <code>src/scimpler/validator.py</code> <pre><code>def __init__(\n    self,\n    config: Optional[scimpler.config.ServiceProviderConfig] = None,\n    *,\n    resource_schema: Union[Sequence[ResourceSchema], ResourceSchema],\n):\n    \"\"\"\n    Args:\n        config: Service provider configuration. If not provided, defaults to\n            `scimpler.config.service_provider_config`\n        resource_schema: Resource schema(s) associated with the validator.\n\n    Examples:\n        &gt;&gt;&gt; from scimpler.schemas import UserSchema, GroupSchema\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # for resource root endpoint\n        &gt;&gt;&gt; root_validator = SearchRequestPost(resource_schema=[UserSchema(), GroupSchema()])\n        &gt;&gt;&gt; # for specific resource type endpoint\n        &gt;&gt;&gt; validator = SearchRequestPost(resource_schema=UserSchema())\n    \"\"\"\n    super().__init__(config, resource_schema=resource_schema)\n    self._request_validation_schema = SearchRequestSchema.from_config(self.config)\n</code></pre>"},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost-attributes","title":"Attributes","text":""},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost.request_schema","title":"<code>request_schema: SearchRequestSchema</code>  <code>property</code>","text":"<p>Schema designed for request (de)serialization.</p>"},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost.response_schema","title":"<code>response_schema: ListResponseSchema</code>  <code>property</code>","text":"<p>Schema designed for response (de)serialization. Resource schemas contain attributes whose <code>returnability</code> differs from <code>never</code>, and whose <code>mutability</code> differs from <code>writeOnly</code>. ListResponse schema contains all attributes.</p>"},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost-functions","title":"Functions","text":""},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost.validate_request","title":"<code>validate_request(body=None)</code>","text":"<p>Validates the HTTP POST query requests.</p> <p>Performs request body validation using inner <code>SearchRequestSchema</code>.</p> PARAMETER DESCRIPTION <code>body</code> <p>The request body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_request(self, body: Optional[Mapping[str, Any]] = None) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP POST** query requests.\n\n    Performs request body validation using inner `SearchRequestSchema`.\n\n    Args:\n        body: The request body.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    issues = ValidationIssues()\n    issues.merge(\n        self._request_validation_schema.validate(\n            ScimData(body or {}), AttrValuePresenceConfig(\"REQUEST\")\n        ),\n        location=[\"body\"],\n    )\n    return issues\n</code></pre>"},{"location":"api_reference/scimpler_validator/search_request_post/#scimpler.validator.SearchRequestPost.validate_response","title":"<code>validate_response(*, status_code, body=None, headers=None, **kwargs)</code>","text":"<p>Validates the HTTP GET responses returned from resource type endpoints.</p> <p>Except for body validation done by the inner <code>ListResponseSchema</code>, the validator checks if:</p> <ul> <li>returned <code>status_code</code> equals 200,</li> <li><code>startIndex</code> in the body is lesser or equal to the provided <code>start_index</code>,</li> <li><code>totalResults</code> greater or equal to number of <code>Resources</code>,</li> <li><code>totalResults</code> differs from number of <code>Resources</code> when <code>count</code> is not specified,</li> <li>number of <code>Resources</code> is lesser or equal to the <code>count</code>, if specified,</li> <li><code>startIndex</code> is specified in the body for pagination,</li> <li><code>itemsPerPage</code> is specified in the body for pagination,</li> <li><code>Resources</code> are filtered, according to the provided <code>filter</code>,</li> <li><code>Resources</code> are sorted, according to the provided <code>sorter</code>,</li> <li>every resource contains <code>meta.version</code>, if <code>etag</code> is supported.</li> </ul> <p>Filtering and sorting is not validated if attributes required to check filtering and sorting are meant to be excluded due to <code>AttrValuePresenceConfig</code>.</p> PARAMETER DESCRIPTION <code>status_code</code> <p>Returned HTTP status code.</p> <p> TYPE: <code>int</code> </p> <code>body</code> <p>Returned body.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Not used.</p> <p> TYPE: <code>Optional[Mapping[str, Any]]</code> DEFAULT: <code>None</code> </p> PARAMETER DESCRIPTION <code>presence_config</code> <p>If not provided, the default one is used, with no attribute inclusivity and exclusivity specified. Applied on <code>Resources</code> only.</p> <p> TYPE: <code>Optional[AttrValuePresenceConfig]</code> </p> <code>start_index</code> <p>The 1-based index of the first query result.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>count</code> <p>Specifies the desired number of query results per page.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>filter</code> <p>Filter that was applied on <code>Resources</code>.</p> <p> TYPE: <code>Optional[Filter]</code> </p> <code>sorter</code> <p>Sorter that was applied on <code>Resources</code>.</p> <p> TYPE: <code>Optional[Sorter]</code> </p> RETURNS DESCRIPTION <code>ValidationIssues</code> <p>Validation issues.</p> Source code in <code>src/scimpler/validator.py</code> <pre><code>def validate_response(\n    self,\n    *,\n    status_code: int,\n    body: Optional[Mapping[str, Any]] = None,\n    headers: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n) -&gt; ValidationIssues:\n    \"\"\"\n    Validates the **HTTP GET** responses returned from **resource type** endpoints.\n\n    Except for body validation done by the inner `ListResponseSchema`, the validator checks if:\n\n    - returned `status_code` equals 200,\n    - `startIndex` in the body is lesser or equal to the provided `start_index`,\n    - `totalResults` greater or equal to number of `Resources`,\n    - `totalResults` differs from number of `Resources` when `count` is not specified,\n    - number of `Resources` is lesser or equal to the `count`, if specified,\n    - `startIndex` is specified in the body for pagination,\n    - `itemsPerPage` is specified in the body for pagination,\n    - `Resources` are filtered, according to the provided `filter`,\n    - `Resources` are sorted, according to the provided `sorter`,\n    - every resource contains `meta.version`, if `etag` is supported.\n\n    Filtering and sorting is not validated if attributes required to check filtering and\n    sorting are meant to be excluded due to `AttrValuePresenceConfig`.\n\n    Args:\n        status_code: Returned HTTP status code.\n        body: Returned body.\n        headers: Not used.\n\n    Keyword Args:\n        presence_config (Optional[AttrValuePresenceConfig]): If not provided, the default one\n            is used, with no attribute inclusivity and exclusivity specified. Applied on\n            `Resources` only.\n        start_index (Optional[int]): The 1-based index of the first query result.\n        count (Optional[int]): Specifies the desired number of query results per page.\n        filter (Optional[Filter]): Filter that was applied on `Resources`.\n        sorter (Optional[Sorter]): Sorter that was applied on `Resources`.\n\n    Returns:\n        Validation issues.\n    \"\"\"\n    return _validate_resources_get_response(\n        schema=self._response_validation_schema,\n        config=self.config,\n        status_code=status_code,\n        body=ScimData(body or {}),\n        start_index=kwargs.get(\"start_index\", 1),\n        count=kwargs.get(\"count\"),\n        filter_=kwargs.get(\"filter\"),\n        sorter=kwargs.get(\"sorter\"),\n        resource_presence_config=kwargs.get(\"presence_config\"),\n    )\n</code></pre>"}]}